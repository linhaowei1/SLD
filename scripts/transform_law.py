#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generates self-contained Python scripts with a 'law' function for all
evolution results found in a directory.

This script recursively finds all 'best_program.py' files, parses their
corresponding 'best_eval.log' to extract fitted parameters, and combines them
into portable 'law.py' files.
"""

import argparse
import re
import sys
from pathlib import Path
from tqdm import tqdm

# This map is crucial for mapping task names to their input/output variables.
# It should be kept in sync with the project's data loader.
try:
    from data_loader import TASK_SCHEMA_MAP
except ImportError:
    print("Error: Could not import TASK_SCHEMA_MAP from data_loader.py.", file=sys.stderr)
    print("Please ensure data_loader.py is in the correct path.", file=sys.stderr)
    sys.exit(1)


def extract_code_from_program(program_path: Path) -> str:
    """Extracts the Python code from between the EVOLVE-BLOCK delimiters."""
    in_block = False
    code_lines = []
    with open(program_path, 'r', encoding='utf-8') as f:
        for line in f:
            code_lines.append(line)
    return "".join(code_lines)


def parse_log_file(log_path: Path) -> tuple[str, dict]:
    """Parses the log file to get the task name and fitted parameters."""
    if not log_path.exists():
        raise FileNotFoundError(f"Log file not found at: {log_path}")

    with open(log_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # 1. Extract Task Name
    task_match = re.search(r"Inferred Task:\s*(\S+)", content)
    if not task_match:
        raise ValueError(f"Could not infer task name from {log_path}")
    task_name = task_match.group(1)

    # 2. Extract Parameters
    params_map = {}
    param_section = re.search(r"Fitted parameters for.*?group\(s\):(.*)", content, re.DOTALL)
    if not param_section:
        raise ValueError(f"Could not find fitted parameters in {log_path}")

    # Regex to find each group and its (potentially multi-line) parameter array
    group_matches = re.finditer(r"-\s+Group\s+'([^']+)':\s+((?:\[.*?\])|(?:.*?))(?=\n\s+-\s+Group|\n-{10,})", param_section.group(1), re.DOTALL)

    for match in group_matches:
        group_name = match.group(1)
        # Clean up the parameter string: remove brackets, newlines, and extra spaces
        param_str = match.group(2).replace('[', '').replace(']', '').replace('\n', ' ').strip()
        # Split by space and convert to float, filtering out empty strings
        params = [float(p) for p in re.split(r'\s+', param_str) if p]
        params_map[group_name] = params

    if not params_map:
         raise ValueError(f"Failed to parse any parameter groups from {log_path}")

    return task_name, params_map


def create_law_function_file(program_path: Path, output_path: Path):
    """
    Generates the final python script with the law() function.
    Raises an exception on failure instead of exiting.
    """
    # 1. Define paths
    run_dir = program_path.parent.parent
    log_path = run_dir / "best_eval.log"

    # 2. Extract and Parse
    core_code = extract_code_from_program(program_path)
    task_name, fitted_params = parse_log_file(log_path)

    # 3. Get schema from the map
    if task_name not in TASK_SCHEMA_MAP:
        raise ValueError(f"Task '{task_name}' not found in TASK_SCHEMA_MAP for {program_path}")
    schema = TASK_SCHEMA_MAP[task_name]
    feature_names = schema["feature_names"]
    target_name = schema["target_name"]

    # 4. Generate the output file content using a template
    file_content = f"""
# -*- coding: utf-8 -*-
# This file was auto-generated by a script. Do not edit manually.
# Generated from: {program_path.name}
# Task: {task_name}
# Source: {program_path}

import numpy as np
from typing import List, Dict

# --- Core Scaling Law Function (from best_program.py) ---
{core_code.strip()}

# --- Pre-fitted Parameters (from best_eval.log) ---
FITTED_PARAMS = {fitted_params}

# --- Task Schema ---
FEATURE_NAMES = {feature_names}
TARGET_NAMES = {repr(target_name) if isinstance(target_name, list) else repr([target_name])}


def law(input_data: List[Dict[str, float]], group: str) -> List[Dict[str, float]]:
    \"\"\"
    Predicts output variables based on input variables according to a discovered scaling law.

    This function uses a pre-fitted model for a specific task and experimental group.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
               The functional form of the law must be the same for all groups,
               but the constant parameters/coefficients can differ per group.
               Available groups: {list(fitted_params.keys())}

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
        
    Raises:
        ValueError: If the specified group is not available or if input_data
                    is missing required features.
    \"\"\"
    if group not in FITTED_PARAMS:
        raise ValueError(f"Unknown group: '{{group}}'. Available groups are: {{list(FITTED_PARAMS.keys())}}")

    if not input_data:
        return []

    params = np.array(FITTED_PARAMS[group])

    # 1. Convert list of dicts to a NumPy array in the correct feature order
    try:
        X_list = [[point[fname] for fname in FEATURE_NAMES] for point in input_data]
        X = np.array(X_list, dtype=float)
    except KeyError as e:
        raise ValueError(f"Input data is missing required feature: {{e}}. Required features are: {{FEATURE_NAMES}}")

    # 2. Call the scaling law function to get predictions
    predictions = scaling_law_func(X, params)
    
    # Ensure predictions are 2D for consistent processing
    if predictions.ndim == 1:
        predictions = predictions.reshape(-1, 1)

    # 3. Convert predictions array back to a list of dicts
    results = []
    for pred_row in predictions:
        result_dict = {{name: value for name, value in zip(TARGET_NAMES, pred_row)}}
        results.append(result_dict)

    return results
"""
    # 5. Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(file_content.strip())


def main():
    """Main function to find and convert all best_program.py files."""
    parser = argparse.ArgumentParser(
        description="Recursively finds all 'best_program.py' files in a directory and converts them to 'law.py'.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        "results_dir",
        type=str,
        help="Path to the root results directory (e.g., '/WillDevExt/linhaoweiShare/evosld-results')."
    )
    args = parser.parse_args()

    root_dir = Path(args.results_dir).resolve()
    
    if not root_dir.is_dir():
        print(f"Error: Directory not found at '{root_dir}'", file=sys.stderr)
        sys.exit(1)

    # Find all relevant files using a pattern that matches the directory structure
    program_files = sorted(list(root_dir.rglob("**/best/best_program.py")))
    
    if not program_files:
        print(f"No 'best/best_program.py' files found under '{root_dir}'.")
        return

    print(f"Found {len(program_files)} 'best_program.py' files to process.")
    
    success_count = 0
    fail_count = 0

    # Iterate through all found files with a progress bar
    for program_path in tqdm(program_files, desc="Converting programs", unit="file"):
        output_path = program_path.with_name("law.py")
        try:
            create_law_function_file(program_path, output_path)
            success_count += 1
        except (FileNotFoundError, ValueError, KeyError) as e:
            # Print error without stopping the loop
            tqdm.write(f"❌ ERROR processing {program_path}:\n   {e}")
            fail_count += 1
    
    print("\n--- Conversion Complete ---")
    print(f"✅ Successfully converted: {success_count}")
    print(f"❌ Failed to convert:    {fail_count}")


if __name__ == "__main__":
    main()