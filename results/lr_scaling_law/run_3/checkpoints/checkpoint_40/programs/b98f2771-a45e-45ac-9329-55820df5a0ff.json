{"id": "b98f2771-a45e-45ac-9329-55820df5a0ff", "code": "\"\"\"\nImproved scaling\u2010law model for LLM training hyperparameters.\n\nWe model the log\u2010loss as a 2nd\u2010order polynomial in the log\u2010features:\n   log y_pred = c0\n              + \u2211_{i} c1_i log x_i\n              + \u2211_{i} c2_i (log x_i)^2\n              + \u2211_{i<j} c3_{ij} (log x_i)(log x_j)\n\nwhere x = [lr, bsz, data_size, non_embedding_param_size].\nWe fit this via ridge\u2010regularized linear regression in closed\u2010form for\nstability, efficiency, and good generalization across scales.\n\nThe returned parameter vector has length 15:\n   [c0,\n    c1_lr, c1_bsz, c1_data, c1_param,\n    c2_lr, c2_bsz, c2_data, c2_param,\n    c3_lr_bsz, c3_lr_data, c3_lr_param,\n    c3_bsz_data, c3_bsz_param, c3_data_param]\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef _build_design_matrix(logX):\n    \"\"\"\n    Build a design matrix for 2nd\u2010order polynomial expansion in log\u2010features.\n    Input:\n      logX: array of shape (N, F) of log\u2010features.\n    Output:\n      Phi:  array of shape (N, P) where\n            P = 1 + F + F + F*(F-1)//2\n    \"\"\"\n    N, F = logX.shape\n    P = 1 + F + F + F*(F-1)//2\n    Phi = np.ones((N, P), dtype=float)\n    idx = 1\n    # linear terms\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic terms\n    Phi[:, idx:idx+F] = logX * logX\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n    return Phi\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss from hyperparameters via a 2nd\u2010order log\u2010polynomial.\n\n    Args:\n      data_points: array of shape (N,4) with columns\n                   [lr, bsz, data_size, non_embedding_param_size]\n      params:      1D array of length 15:\n                   [c0,\n                    c1_lr, c1_bsz, c1_data, c1_param,\n                    c2_lr, c2_bsz, c2_data, c2_param,\n                    c3_lr_bsz, c3_lr_data, c3_lr_param,\n                    c3_bsz_data, c3_bsz_param, c3_data_param]\n\n    Returns:\n      y_pred: 1D array of length N of predicted LM losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected input with 4 features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    P_expected = 1 + F + F + (F*(F-1))//2\n    if p.size != P_expected:\n        raise ValueError(f\"Expected {P_expected} parameters, got {p.size}\")\n\n    # Avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    logX = np.log(X_clipped)\n\n    # Build design matrix and predict in log\u2010domain\n    Phi = _build_design_matrix(logX)\n    log_pred = Phi.dot(p)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2nd\u2010order log\u2010polynomial scaling law via ridge\u2010regularized regression.\n\n    Args:\n      data_points: array of shape (N,4)\n      loss_values: array of shape (N,)\n\n    Returns:\n      params: 1D array of length 15 of fitted coefficients.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected data_points with 4 features, got {F}\")\n    if y.size != N:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # Floor values to avoid log(0) and negative logs\n    X_clipped = np.maximum(X, 1e-12)\n    y_clipped = np.maximum(y, 1e-12)\n\n    # Log\u2010transform\n    logX = np.log(X_clipped)\n    logy = np.log(y_clipped)\n\n    # Build design matrix\n    Phi = _build_design_matrix(logX)\n\n    # Ridge regularization (small \u03bb for stability)\n    ridge = 1e-6\n    _, P = Phi.shape\n    A = Phi.T.dot(Phi)\n    # Do not regularize the intercept (index 0)\n    diag_idx = np.arange(1, P)\n    A[diag_idx, diag_idx] += ridge\n\n    b = Phi.T.dot(logy)\n    params = np.linalg.solve(A, b)\n    return params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "5edcc7d6-788d-4038-830e-87a26112a16b", "generation": 3, "timestamp": 1754807704.9351344, "iteration_found": 19, "metrics": {"nmse": 0.43745368419125447, "nmae": 0.6955391817494094, "r2": 0.5625463158087456, "combined_score": 0.6956745883347356}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 1.7852713642337685, "nmae": 1.6625078054821167, "r2": -0.7852713642337685, "combined_score": 0.35903144406006604}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between learning rate, batch size, data size, model parameters and training loss.\n\nYou are allowed to decide the number of parameters in the scaling law function.\n\nFocus on mathematical accuracy across different hyperparameter scales, cross-configuration generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [lr, bsz, data_size, non_embedding_param_size] - 4D input\n- Labels: lm loss - scalar output\n- lr: learning rate\n- bsz: batch size\n- data_size: amount of training data\n- non_embedding_param_size: number of non-embedding parameters in the model\n- lm loss: language model loss (filtered to <= 4.0 to remove outliers)\n- Data explores the relationship between training hyperparameters and model performance\n- Test set consists of points with the largest data_size or non_embedding_param_size\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,4) array with columns [lr, bsz, data_size, non_embedding_param_size]\n    # lr: Array of learning rates\n    # bsz: Array of batch sizes\n    # data_size: Array of data sizes\n    # non_embedding_param_size: Array of non-embedding parameter sizes\n    # Returns: Predicted lm loss values\n    - Model parameters (N) range: ~214M to ~1B parameters\n    - Training tokens (D) range: 4B to 100B tokens\n    - Learning rates range: 1.2e-4 to 2.2e-2\n    - Batch sizes range: 16 to 4096\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,4) array with columns [lr, bsz, data_size, non_embedding_param_size]\n    # loss_values: Array of corresponding lm loss values\n    # Returns: Optimized parameters \n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 1.7853\n- nmae: 1.6625\n- r2: -0.7853\n- combined_score: 0.3590\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 1.7853, nmae: 1.6625, r2: -0.7853, combined_score: 0.3590\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.4375, nmae: 0.6955, r2: 0.5625, combined_score: 0.6957\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5978)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling law model for LLM training hyperparameters.\nWe fit a second\u2010order polynomial in the log\u2010domain of each feature,\nincluding quadratic terms and pairwise interactions, via ridge\u2010regularized\nclosed\u2010form regression for stability, efficiency, and improved accuracy.\n\nModel form:\n   log(y_pred) = c0\n               + sum_i c1_i * log(x_i)\n               + sum_i c2_i * (log(x_i))^2\n               + sum_{i<j} c3_{ij} * log(x_i)*log(x_j)\n\nwhere x = [lr, bsz, data_size, non_embedding_param_size],\nand y_pred is the predicted LM loss.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict language\u2010model loss from hyperparameters via a 2nd\u2010order log\u2010polynomial.\n\n    Args:\n      data_points: array\u2010like of shape (N,4) with columns\n                   [lr, bsz, data_size, non_embedding_param_size]\n      params:      1D array of length 15:\n                   [c0,\n                    c1_lr, c1_bsz, c1_data, c1_param,\n                    c2_lr, c2_bsz, c2_data, c2_param,\n                    c3_lr_bsz, c3_lr_data, c3_lr_param,\n                    c3_bsz_data, c3_bsz_param, c3_data_param]\n\n    Returns:\n      y_pred:      1D array of length N of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected input with 4 features, got {F}\")\n\n    p = np.asarray(params, float).ravel()\n    # total parameters = 1 intercept + 4 linear + 4 quadratic + 6 interactions = 15\n    P_expected = 1 + F + F + (F*(F-1))//2\n    if p.shape[0] != P_expected:\n        raise ValueError(f\"Expected {P_expected} parameters, got {p.shape[0]}\")\n\n    # floor inputs to avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    logX = np.log(X_clipped)        # shape (N,4)\n\n    # build design matrix Phi\n    Phi = np.ones((N, P_expected), float)\n    # linear terms\n    idx = 1\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic terms\n    Phi[:, idx:idx+F] = logX**2\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n\n    # predict in log\u2010domain and exponentiate\n    log_pred = Phi.dot(p)           # shape (N,)\n    return np.exp(log_pred)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2nd\u2010order log\u2010polynomial scaling law via ridge\u2010regularized regression.\n\n    Args:\n      data_points: array\u2010like of shape (N,4)\n      loss_values: array\u2010like of shape (N,)\n\n    Returns:\n      params:      1D array of length 15 of fitted coefficients.\n    \"\"\"\n    X = np.asarray(data_points, float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, float).ravel()\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected data_points with 4 features, got {F}\")\n    if y.shape[0] != N:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # floor to avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    y_clipped = np.maximum(y, 1e-12)\n\n    # log\u2010transform\n    logX = np.log(X_clipped)        # shape (N,4)\n    logy = np.log(y_clipped)        # shape (N,)\n\n    # build design matrix Phi\n    P = 1 + F + F + (F*(F-1))//2     # 15\n    Phi = np.ones((N, P), float)\n    idx = 1\n    # linear\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic\n    Phi[:, idx:idx+F] = logX**2\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n\n    # ridge\u2010regularized normal equations\n    ridge = 1e-6\n    A = Phi.T.dot(Phi)\n    # apply ridge only to non\u2010intercept terms\n    A[np.arange(1, P), np.arange(1, P)] += ridge\n    b = Phi.T.dot(logy)\n\n    # solve for parameters\n    params = np.linalg.solve(A, b)\n    return params\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.4375), Performs well on nmae (0.6955), Performs well on r2 (0.5625), Performs well on combined_score (0.6957)\n\n\n### Program 2 (Score: 0.7554)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEvolved scaling\u2010law discovery for LLM training hyperparameters.\n\nModel form:\n    y_pred = y_inf + A * P^aP * D^aD * bsz^aB * lr^aL\n\nWe parameterize:\n    p = [logA, aP, aD, aB, aL, log_yinf]\n\nWe initialize by subtracting an initial y_inf guess and fitting\na linear least\u2010squares in log\u2010space, then refine all parameters\nvia L-BFGS-B with analytic gradients.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict language modeling loss from hyperparameters.\n    data_points: (N,4) array columns [lr, bsz, data_size, non_embedding_param_size]\n    params:      array of length 6 or shape (T,6):\n                 [logA, aP, aD, aB, aL, log_yinf]\n    Returns:\n      y_pred: shape (N,) if single param set or (N,T) for multiple sets.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected 4 features (lr,bsz,D,P), got {F}\")\n    # unpack features\n    lr    = X[:, 0]\n    bsz   = X[:, 1]\n    D     = X[:, 2]\n    Psize = X[:, 3]\n\n    p = np.asarray(params, dtype=float)\n    if p.ndim == 1:\n        p = p[None, :]\n    T, Pcount = p.shape\n    if Pcount != 6:\n        raise ValueError(f\"Expected 6 parameters, got {Pcount}\")\n\n    # Precompute logs\n    log_lr   = np.log(np.maximum(lr, 1e-12))\n    log_bsz  = np.log(np.maximum(bsz, 1.0))\n    log_D    = np.log(np.maximum(D, 1.0))\n    log_P    = np.log(np.maximum(Psize, 1.0))\n\n    y_all = np.zeros((N, T), dtype=float)\n    for t in range(T):\n        logA, aP, aD, aB, aL, log_yinf = p[t]\n        # log\u2010term for the power law piece\n        log_term = (logA\n                    + aP * log_P\n                    + aD * log_D\n                    + aB * log_bsz\n                    + aL * log_lr)\n        term = np.exp(log_term)\n        y_inf = np.exp(log_yinf)\n        y_all[:, t] = y_inf + term\n\n    return y_all[:, 0] if T == 1 else y_all\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by minimizing MSE on observed losses.\n    Returns optimized parameter vector [logA, aP, aD, aB, aL, log_yinf].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Number of data points and loss values must match.\")\n\n    # 1) Initial guess for y_inf and linear LS on log\u2010space\n    y_min = max(np.min(y), 1e-8)\n    y_inf0 = y_min * 0.5\n\n    # prevent zeros before logging\n    lr    = X[:, 0]; bsz  = X[:, 1]\n    D     = X[:, 2]; Psize = X[:, 3]\n    log_lr   = np.log(np.maximum(lr, 1e-12))\n    log_bsz  = np.log(np.maximum(bsz, 1.0))\n    log_D    = np.log(np.maximum(D, 1.0))\n    log_P    = np.log(np.maximum(Psize, 1.0))\n\n    # subtract floor and take logs\n    y_tilde = np.maximum(y - y_inf0, 1e-8)\n    log_y   = np.log(y_tilde)\n\n    # Design matrix for [logA, aP, aD, aB, aL]\n    M = np.vstack([\n        np.ones_like(log_y),\n        log_P,\n        log_D,\n        log_bsz,\n        log_lr\n    ]).T\n    # solve least squares\n    beta, *_ = np.linalg.lstsq(M, log_y, rcond=None)\n    # beta = [logA, aP, aD, aB, aL]\n    p0 = np.concatenate([beta, [np.log(y_inf0)]])\n\n    # 2) refine by minimizing MSE with analytic gradient\n    # bounds: keep exponents and logs in reasonable range\n    lb = [-20.0, -10.0, -10.0, -10.0, -10.0, np.log(1e-8)]\n    ub = [ 20.0,  10.0,  10.0,  10.0,  10.0, np.log(y_min)]\n    bounds = list(zip(lb, ub))\n\n    # reuse logs computed above inside objective\n    def obj_and_grad(p):\n        logA, aP, aD, aB, aL, log_yinf = p\n        y_inf = np.exp(log_yinf)\n        # power\u2010law term\n        log_term = (logA\n                    + aP * log_P\n                    + aD * log_D\n                    + aB * log_bsz\n                    + aL * log_lr)\n        term = np.exp(log_term)\n        y_pred = y_inf + term\n        r = y_pred - y\n        mse = np.mean(r * r)\n\n        # gradients\n        Ninv2 = 2.0 / float(y.size)\n        g_logA      = Ninv2 * np.sum(r * term)\n        g_aP        = Ninv2 * np.sum(r * term * log_P)\n        g_aD        = Ninv2 * np.sum(r * term * log_D)\n        g_aB        = Ninv2 * np.sum(r * term * log_bsz)\n        g_aL        = Ninv2 * np.sum(r * term * log_lr)\n        g_log_yinf  = Ninv2 * np.sum(r * y_inf)\n\n        grad = np.array([\n            g_logA,\n            g_aP,\n            g_aD,\n            g_aB,\n            g_aL,\n            g_log_yinf\n        ], dtype=float)\n        return mse, grad\n\n    result = minimize(\n        fun=lambda p: obj_and_grad(p)[0],\n        x0=p0,\n        jac=lambda p: obj_and_grad(p)[1],\n        bounds=bounds,\n        method=\"L-BFGS-B\",\n        options={\"maxiter\":1000, \"ftol\":1e-12}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to linear\u2010LS initial guess\n        return p0\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (1.7853), Performs well on nmae (1.6625), Performs well on r2 (-0.7853), Performs well on combined_score (0.3590)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5978, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling law model for LLM training hyperparameters.\nWe fit a second\u2010order polynomial in the log\u2010domain of each feature,\nincluding quadratic terms and pairwise interactions, via ridge\u2010regularized\nclosed\u2010form regression for stability, efficiency, and improved accuracy.\n\nModel form:\n   log(y_pred) = c0\n               + sum_i c1_i * log(x_i)\n               + sum_i c2_i * (log(x_i))^2\n               + sum_{i<j} c3_{ij} * log(x_i)*log(x_j)\n\nwhere x = [lr, bsz, data_size, non_embedding_param_size],\nand y_pred is the predicted LM loss.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict language\u2010model loss from hyperparameters via a 2nd\u2010order log\u2010polynomial.\n\n    Args:\n      data_points: array\u2010like of shape (N,4) with columns\n                   [lr, bsz, data_size, non_embedding_param_size]\n      params:      1D array of length 15:\n                   [c0,\n                    c1_lr, c1_bsz, c1_data, c1_param,\n                    c2_lr, c2_bsz, c2_data, c2_param,\n                    c3_lr_bsz, c3_lr_data, c3_lr_param,\n                    c3_bsz_data, c3_bsz_param, c3_data_param]\n\n    Returns:\n      y_pred:      1D array of length N of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected input with 4 features, got {F}\")\n\n    p = np.asarray(params, float).ravel()\n    # total parameters = 1 intercept + 4 linear + 4 quadratic + 6 interactions = 15\n    P_expected = 1 + F + F + (F*(F-1))//2\n    if p.shape[0] != P_expected:\n        raise ValueError(f\"Expected {P_expected} parameters, got {p.shape[0]}\")\n\n    # floor inputs to avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    logX = np.log(X_clipped)        # shape (N,4)\n\n    # build design matrix Phi\n    Phi = np.ones((N, P_expected), float)\n    # linear terms\n    idx = 1\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic terms\n    Phi[:, idx:idx+F] = logX**2\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n\n    # predict in log\u2010domain and exponentiate\n    log_pred = Phi.dot(p)           # shape (N,)\n    return np.exp(log_pred)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2nd\u2010order log\u2010polynomial scaling law via ridge\u2010regularized regression.\n\n    Args:\n      data_points: array\u2010like of shape (N,4)\n      loss_values: array\u2010like of shape (N,)\n\n    Returns:\n      params:      1D array of length 15 of fitted coefficients.\n    \"\"\"\n    X = np.asarray(data_points, float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, float).ravel()\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected data_points with 4 features, got {F}\")\n    if y.shape[0] != N:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # floor to avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    y_clipped = np.maximum(y, 1e-12)\n\n    # log\u2010transform\n    logX = np.log(X_clipped)        # shape (N,4)\n    logy = np.log(y_clipped)        # shape (N,)\n\n    # build design matrix Phi\n    P = 1 + F + F + (F*(F-1))//2     # 15\n    Phi = np.ones((N, P), float)\n    idx = 1\n    # linear\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic\n    Phi[:, idx:idx+F] = logX**2\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n\n    # ridge\u2010regularized normal equations\n    ridge = 1e-6\n    A = Phi.T.dot(Phi)\n    # apply ridge only to non\u2010intercept terms\n    A[np.arange(1, P), np.arange(1, P)] += ridge\n    b = Phi.T.dot(logy)\n\n    # solve for parameters\n    params = np.linalg.solve(A, b)\n    return params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEvolved scaling\u2010law discovery for LLM training hyperparameters.\n\nModel form:\n    y_pred = y_inf + A * P^aP * D^aD * bsz^aB * lr^aL\n\nWe parameterize:\n    p = [logA, aP, aD, aB, aL, log_yinf]\n\nWe initialize by subtracting an initial y_inf guess and fitting\na linear least\u2010squares in log\u2010space, then refine all parameters\nvia L-BFGS-B with analytic gradients.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict language modeling loss from hyperparameters.\n    data_points: (N,4) array columns [lr, bsz, data_size, non_embedding_param_size]\n    params:      array of length 6 or shape (T,6):\n                 [logA, aP, aD, aB, aL, log_yinf]\n    Returns:\n      y_pred: shape (N,) if single param set or (N,T) for multiple sets.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected 4 features (lr,bsz,D,P), got {F}\")\n    # unpack features\n    lr    = X[:, 0]\n    bsz   = X[:, 1]\n    D     = X[:, 2]\n    Psize = X[:, 3]\n\n    p = np.asarray(params, dtype=float)\n    if p.ndim == 1:\n        p = p[None, :]\n    T, Pcount = p.shape\n    if Pcount != 6:\n        raise ValueError(f\"Expected 6 parameters, got {Pcount}\")\n\n    # Precompute logs\n    log_lr   = np.log(np.maximum(lr, 1e-12))\n    log_bsz  = np.log(np.maximum(bsz, 1.0))\n    log_D    = np.log(np.maximum(D, 1.0))\n    log_P    = np.log(np.maximum(Psize, 1.0))\n\n    y_all = np.zeros((N, T), dtype=float)\n    for t in range(T):\n        logA, aP, aD, aB, aL, log_yinf = p[t]\n        # log\u2010term for the power law piece\n        log_term = (logA\n                    + aP * log_P\n                    + aD * log_D\n                    + aB * log_bsz\n                    + aL * log_lr)\n        term = np.exp(log_term)\n        y_inf = np.exp(log_yinf)\n        y_all[:, t] = y_inf + term\n\n    return y_all[:, 0] if T == 1 else y_all\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by minimizing MSE on observed losses.\n    Returns optimized parameter vector [logA, aP, aD, aB, aL, log_yinf].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Number of data points and loss values must match.\")\n\n    # 1) Initial guess for y_inf and linear LS on log\u2010space\n    y_min = max(np.min(y), 1e-8)\n    y_inf0 = y_min * 0.5\n\n    # prevent zeros before logging\n    lr    = X[:, 0]; bsz  = X[:, 1]\n    D     = X[:, 2]; Psize = X[:, 3]\n    log_lr   = np.log(np.maximum(lr, 1e-12))\n    log_bsz  = np.log(np.maximum(bsz, 1.0))\n    log_D    = np.log(np.maximum(D, 1.0))\n    log_P    = np.log(np.maximum(Psize, 1.0))\n\n    # subtract floor and take logs\n    y_tilde = np.maximum(y - y_inf0, 1e-8)\n    log_y   = np.log(y_tilde)\n\n    # Design matrix for [logA, aP, aD, aB, aL]\n    M = np.vstack([\n        np.ones_like(log_y),\n        log_P,\n        log_D,\n        log_bsz,\n        log_lr\n    ]).T\n    # solve least squares\n    beta, *_ = np.linalg.lstsq(M, log_y, rcond=None)\n    # beta = [logA, aP, aD, aB, aL]\n    p0 = np.concatenate([beta, [np.log(y_inf0)]])\n\n    # 2) refine by minimizing MSE with analytic gradient\n    # bounds: keep exponents and logs in reasonable range\n    lb = [-20.0, -10.0, -10.0, -10.0, -10.0, np.log(1e-8)]\n    ub = [ 20.0,  10.0,  10.0,  10.0,  10.0, np.log(y_min)]\n    bounds = list(zip(lb, ub))\n\n    # reuse logs computed above inside objective\n    def obj_and_grad(p):\n        logA, aP, aD, aB, aL, log_yinf = p\n        y_inf = np.exp(log_yinf)\n        # power\u2010law term\n        log_term = (logA\n                    + aP * log_P\n                    + aD * log_D\n                    + aB * log_bsz\n                    + aL * log_lr)\n        term = np.exp(log_term)\n        y_pred = y_inf + term\n        r = y_pred - y\n        mse = np.mean(r * r)\n\n        # gradients\n        Ninv2 = 2.0 / float(y.size)\n        g_logA      = Ninv2 * np.sum(r * term)\n        g_aP        = Ninv2 * np.sum(r * term * log_P)\n        g_aD        = Ninv2 * np.sum(r * term * log_D)\n        g_aB        = Ninv2 * np.sum(r * term * log_bsz)\n        g_aL        = Ninv2 * np.sum(r * term * log_lr)\n        g_log_yinf  = Ninv2 * np.sum(r * y_inf)\n\n        grad = np.array([\n            g_logA,\n            g_aP,\n            g_aD,\n            g_aB,\n            g_aL,\n            g_log_yinf\n        ], dtype=float)\n        return mse, grad\n\n    result = minimize(\n        fun=lambda p: obj_and_grad(p)[0],\n        x0=p0,\n        jac=lambda p: obj_and_grad(p)[1],\n        bounds=bounds,\n        method=\"L-BFGS-B\",\n        options={\"maxiter\":1000, \"ftol\":1e-12}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to linear\u2010LS initial guess\n        return p0\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nImproved scaling\u2010law model for LLM training hyperparameters.\n\nWe model the log\u2010loss as a 2nd\u2010order polynomial in the log\u2010features:\n   log y_pred = c0\n              + \u2211_{i} c1_i log x_i\n              + \u2211_{i} c2_i (log x_i)^2\n              + \u2211_{i<j} c3_{ij} (log x_i)(log x_j)\n\nwhere x = [lr, bsz, data_size, non_embedding_param_size].\nWe fit this via ridge\u2010regularized linear regression in closed\u2010form for\nstability, efficiency, and good generalization across scales.\n\nThe returned parameter vector has length 15:\n   [c0,\n    c1_lr, c1_bsz, c1_data, c1_param,\n    c2_lr, c2_bsz, c2_data, c2_param,\n    c3_lr_bsz, c3_lr_data, c3_lr_param,\n    c3_bsz_data, c3_bsz_param, c3_data_param]\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef _build_design_matrix(logX):\n    \"\"\"\n    Build a design matrix for 2nd\u2010order polynomial expansion in log\u2010features.\n    Input:\n      logX: array of shape (N, F) of log\u2010features.\n    Output:\n      Phi:  array of shape (N, P) where\n            P = 1 + F + F + F*(F-1)//2\n    \"\"\"\n    N, F = logX.shape\n    P = 1 + F + F + F*(F-1)//2\n    Phi = np.ones((N, P), dtype=float)\n    idx = 1\n    # linear terms\n    Phi[:, idx:idx+F] = logX\n    idx += F\n    # quadratic terms\n    Phi[:, idx:idx+F] = logX * logX\n    idx += F\n    # pairwise interactions\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX[:, i] * logX[:, j]\n            idx += 1\n    return Phi\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss from hyperparameters via a 2nd\u2010order log\u2010polynomial.\n\n    Args:\n      data_points: array of shape (N,4) with columns\n                   [lr, bsz, data_size, non_embedding_param_size]\n      params:      1D array of length 15:\n                   [c0,\n                    c1_lr, c1_bsz, c1_data, c1_param,\n                    c2_lr, c2_bsz, c2_data, c2_param,\n                    c3_lr_bsz, c3_lr_data, c3_lr_param,\n                    c3_bsz_data, c3_bsz_param, c3_data_param]\n\n    Returns:\n      y_pred: 1D array of length N of predicted LM losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected input with 4 features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    P_expected = 1 + F + F + (F*(F-1))//2\n    if p.size != P_expected:\n        raise ValueError(f\"Expected {P_expected} parameters, got {p.size}\")\n\n    # Avoid log(0)\n    X_clipped = np.maximum(X, 1e-12)\n    logX = np.log(X_clipped)\n\n    # Build design matrix and predict in log\u2010domain\n    Phi = _build_design_matrix(logX)\n    log_pred = Phi.dot(p)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2nd\u2010order log\u2010polynomial scaling law via ridge\u2010regularized regression.\n\n    Args:\n      data_points: array of shape (N,4)\n      loss_values: array of shape (N,)\n\n    Returns:\n      params: 1D array of length 15 of fitted coefficients.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 4:\n        raise ValueError(f\"Expected data_points with 4 features, got {F}\")\n    if y.size != N:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # Floor values to avoid log(0) and negative logs\n    X_clipped = np.maximum(X, 1e-12)\n    y_clipped = np.maximum(y, 1e-12)\n\n    # Log\u2010transform\n    logX = np.log(X_clipped)\n    logy = np.log(y_clipped)\n\n    # Build design matrix\n    Phi = _build_design_matrix(logX)\n\n    # Ridge regularization (small \u03bb for stability)\n    ridge = 1e-6\n    _, P = Phi.shape\n    A = Phi.T.dot(Phi)\n    # Do not regularize the intercept (index 0)\n    diag_idx = np.arange(1, P)\n    A[diag_idx, diag_idx] += ridge\n\n    b = Phi.T.dot(logy)\n    params = np.linalg.solve(A, b)\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\nExplanation of key improvements:\n1. Switched to a full second\u2010order polynomial in the log\u2010domain, capturing both curvature and feature interactions.\n2. Closed\u2010form solution with a small ridge term ensures numerical stability and parameter\u2010efficient fitting.\n3. Vectorized design\u2010matrix construction for clarity and maintainability.\n4. Strict input validation and zero\u2010flooring avoid numerical issues with logs."]}}}