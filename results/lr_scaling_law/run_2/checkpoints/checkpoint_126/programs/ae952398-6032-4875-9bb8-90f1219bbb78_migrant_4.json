{"id": "ae952398-6032-4875-9bb8-90f1219bbb78_migrant_4", "code": "import numpy as np\n\n# Precomputed log\u2010domain minima and maxima for each feature:\n#   [learning_rate, batch_size, data_size, non_embedding_param_size]\n_LOG_F_MINS = np.log(np.array([\n    1.2e-4,   # lr min\n    16.0,     # bsz min\n    4e9,      # data_size min\n    2.14e8    # non_embedding_param_size min\n], dtype=float))\n_LOG_F_MAXS = np.log(np.array([\n    2.2e-2,   # lr max\n    4096.0,   # bsz max\n    1e11,     # data_size max\n    1e9       # non_embedding_param_size max\n], dtype=float))\n_LOG_F_RANGES = _LOG_F_MAXS - _LOG_F_MINS  # used to normalize to [0,1]\n\ndef _build_design_matrix(logX_norm):\n    \"\"\"\n    Build design matrix for a second-order polynomial in the normalized\n    log-domain. Features:\n      - intercept\n      - linear terms: logX_norm_i for i in [0..3]\n      - squared terms: (logX_norm_i)^2\n      - pairwise interactions: logX_norm_i * logX_norm_j for i<j\n    Returns an (N,15) matrix.\n    \"\"\"\n    N, F = logX_norm.shape\n    # total parameters = 1 + F + F + (F*(F-1)//2)\n    P = 1 + F + F + (F * (F - 1)) // 2\n    Phi = np.empty((N, P), dtype=logX_norm.dtype)\n\n    # intercept\n    Phi[:, 0] = 1.0\n\n    # linear terms\n    Phi[:, 1:1+F] = logX_norm\n\n    # squared terms\n    start_sq = 1 + F\n    Phi[:, start_sq:start_sq+F] = logX_norm**2\n\n    # pairwise interactions\n    idx = start_sq + F\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX_norm[:, i] * logX_norm[:, j]\n            idx += 1\n\n    return Phi\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss from hyperparameters via a normalized-quadratic scaling law.\n\n    data_points: array-like of shape (N,4) with columns\n                 [lr, bsz, data_size, non_embedding_param_size]\n    params:      array-like of length 15: coefficients in the log-loss domain.\n\n    Returns:     array of shape (N,) of predicted LM loss values.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # allow single sample\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"Expected data_points shape (N,4), got {X.shape}\")\n\n    # avoid non-positive\n    X = np.clip(X, 1e-12, None)\n\n    # log-transform and normalize to [0,1]\n    logX = np.log(X)\n    logX_norm = (logX - _LOG_F_MINS) / _LOG_F_RANGES\n    logX_norm = np.clip(logX_norm, 0.0, 1.0)\n\n    # build design matrix and predict\n    Phi = _build_design_matrix(logX_norm)  # shape (N,15)\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != Phi.shape[1]:\n        raise ValueError(f\"Expected {Phi.shape[1]} parameters, got {p.size}\")\n\n    log_pred = Phi.dot(p)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the normalized-quadratic scaling law via closed-form ridge regression.\n\n    data_points: array-like of shape (N,4)\n    loss_values: array-like of shape (N,)\n\n    Returns:      params: array of length 15 (coefficients in log-loss domain)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # allow single sample\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"Expected data_points shape (N,4), got {X.shape}\")\n    if X.shape[0] != y.size:\n        raise ValueError(\"Number of data points and loss values must match.\")\n\n    # avoid non-positive\n    X = np.clip(X, 1e-12, None)\n    y = np.clip(y, 1e-12, None)\n\n    # log-transform and normalize\n    logX = np.log(X)\n    logX_norm = (logX - _LOG_F_MINS) / _LOG_F_RANGES\n    logX_norm = np.clip(logX_norm, 0.0, 1.0)\n\n    # build design matrix\n    Phi = _build_design_matrix(logX_norm)  # shape (N,15)\n\n    # log-target\n    logy = np.log(y)\n\n    # normal equations with adaptive ridge\n    A = Phi.T.dot(Phi)      # (15,15)\n    b = Phi.T.dot(logy)     # (15,)\n\n    P = A.shape[0]\n    ridge = 1e-6 * np.trace(A) / P\n    # penalize all but intercept\n    diag_idx = np.diag_indices(P)\n    A[diag_idx] += ridge\n    A[0, 0] -= ridge  # no penalty on intercept\n\n    # solve for params\n    params = np.linalg.solve(A, b)\n    return params", "language": "python", "parent_id": "ae952398-6032-4875-9bb8-90f1219bbb78", "generation": 4, "timestamp": 1754806559.1050596, "iteration_found": 0, "metrics": {"nmse": 0.009529812593006361, "nmae": 0.10319057777458805, "r2": 0.9904701874069937, "combined_score": 0.990560147432864}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.09757690575929612, "nmae": 0.3101095785135347, "r2": 0.9024230942407039, "combined_score": 0.9110978873122397}, "island": 4, "migrant": true}, "artifacts_json": null, "artifact_dir": null}