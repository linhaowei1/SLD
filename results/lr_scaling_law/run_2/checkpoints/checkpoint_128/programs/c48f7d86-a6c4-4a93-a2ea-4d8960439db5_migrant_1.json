{"id": "c48f7d86-a6c4-4a93-a2ea-4d8960439db5_migrant_1", "code": "\"\"\"\nSimplified second\u2010order log\u2010domain polynomial scaling law with\nnormalized features and adaptive ridge regression for stability.\n\"\"\"\nimport numpy as np\n\n# Pre\u2010computed log\u2010domain minima and maxima for each feature:\n# [learning_rate, batch_size, data_size, non_embedding_param_size]\n_LOG_F_MINS = np.log(np.array([\n    1.2e-4,    # lr min\n    16.0,      # bsz min\n    4e9,       # data size min\n    2.14e8     # non\u2010embedding param size min\n], dtype=float))\n_LOG_F_MAXS = np.log(np.array([\n    2.2e-2,    # lr max\n    4096.0,    # bsz max\n    1e11,      # data size max\n    1e9        # non\u2010embedding param size max\n], dtype=float))\n_LOG_F_RANGES = _LOG_F_MAXS - _LOG_F_MINS  # for normalization to [0,1]\n\n\ndef _normalize_log_features(X):\n    \"\"\"\n    Clip inputs to >0, take logs, and normalize each feature to [0,1]\n    based on global log\u2010min/max.\n    \"\"\"\n    # avoid log(0) and negatives\n    X_clipped = np.clip(X, 1e-12, None)\n    logX = np.log(X_clipped)\n    logX_norm = (logX - _LOG_F_MINS) / _LOG_F_RANGES\n    # clip any numerical drift\n    return np.clip(logX_norm, 0.0, 1.0)\n\n\ndef _build_design_matrix(logX_norm):\n    \"\"\"\n    Build design matrix for a normalized 2nd\u2010order polynomial:\n      [1,\n       u_i for i in 0..3,\n       u_i^2 for i in 0..3,\n       u_i * u_j for all 0 <= i < j < 4]\n    Returns an (N,15) matrix.\n    \"\"\"\n    N, F = logX_norm.shape  # F should be 4\n    # 1 intercept + F linear + F squared + F*(F-1)/2 interactions\n    P = 1 + F + F + (F * (F - 1)) // 2\n    Phi = np.empty((N, P), dtype=logX_norm.dtype)\n\n    # intercept\n    Phi[:, 0] = 1.0\n    # linear terms\n    Phi[:, 1:1+F] = logX_norm\n    # squared terms\n    sq_start = 1 + F\n    Phi[:, sq_start:sq_start+F] = logX_norm ** 2\n    # pairwise interactions\n    idx = sq_start + F\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = logX_norm[:, i] * logX_norm[:, j]\n            idx += 1\n\n    return Phi\n\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss from hyperparameters via a normalized\n    second\u2010order log\u2010domain polynomial.\n\n    Inputs:\n      data_points: array\u2010like, shape (N,4), columns = [lr, bsz, data_size, non_embed_param_size]\n      params:      array\u2010like of length 15 (coefficients in log\u2010loss domain)\n\n    Returns:\n      preds: numpy array of shape (N,) with predicted LM loss values\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # support single sample\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.ndim != 2 or X.shape[1] != _LOG_F_MINS.size:\n        raise ValueError(f\"Expected data_points shape (N,4), got {X.shape}\")\n\n    # normalize features in log\u2010domain\n    logX_norm = _normalize_log_features(X)\n\n    # build polynomial design matrix\n    Phi = _build_design_matrix(logX_norm)  # (N,15)\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != Phi.shape[1]:\n        raise ValueError(f\"Expected {Phi.shape[1]} params, got {p.size}\")\n\n    # predict log\u2010loss and exponentiate\n    logy_pred = Phi.dot(p)  # (N,)\n    return np.exp(logy_pred)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the normalized second\u2010order polynomial scaling law by closed\u2010form\n    ridge\u2010regularized least squares in the log\u2010loss domain.\n\n    Inputs:\n      data_points: array\u2010like, shape (N,4)\n      loss_values: array\u2010like, shape (N,)\n\n    Returns:\n      params: numpy array of length 15 (coefficients for log\u2010loss domain)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # support single sample\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.ndim != 2 or X.shape[1] != _LOG_F_MINS.size:\n        raise ValueError(f\"Expected data_points shape (N,4), got {X.shape}\")\n    if X.shape[0] != y.size:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # build normalized design matrix\n    logX_norm = _normalize_log_features(X)\n    Phi = _build_design_matrix(logX_norm)  # (N,15)\n\n    # transform target to log\u2010domain (avoid log(0))\n    logy = np.log(np.clip(y, 1e-12, None))\n\n    # normal equations\n    A = Phi.T.dot(Phi)   # (15,15)\n    b = Phi.T.dot(logy)  # (15,)\n\n    # adaptive ridge: scale by trace(A)/P\n    Pdim = A.shape[0]\n    ridge = 1e-6 * np.trace(A) / Pdim\n\n    # add ridge to all diagonal entries, then remove it from intercept\n    diag_idx = np.diag_indices(Pdim)\n    A[diag_idx] += ridge\n    A[0, 0] -= ridge  # no penalty on intercept\n\n    # solve for parameters\n    params = np.linalg.solve(A, b)\n    return params\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "c48f7d86-a6c4-4a93-a2ea-4d8960439db5", "generation": 5, "timestamp": 1754806559.1054287, "iteration_found": 0, "metrics": {"nmse": 0.009529812593006361, "nmae": 0.10319057777458805, "r2": 0.9904701874069937, "combined_score": 0.990560147432864}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.009529812593006361, "nmae": 0.10319057777458805, "r2": 0.9904701874069937, "combined_score": 0.990560147432864}, "island": 1, "migrant": true}, "artifacts_json": null, "artifact_dir": null}