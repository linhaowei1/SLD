{"id": "2f0ce955-733b-430e-8757-b96b83c7f5ec_migrant_2", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\n# We adopt a normalized\u2010log quadratic scaling law:\n#   log(loss) \u2248 \u03b20 + \u2211_i \u03b2_i u_i + \u2211_i \u03b3_i u_i^2 + \u2211_{i<j} \u03b4_{ij} u_i u_j\n# where u_i = (log x_i \u2212 log_min_i) / (log_max_i \u2212 log_min_i) clipped to [0,1].\n# We fit via closed\u2010form ridge regression in the log\u2010loss domain for stability.\n\n# Precomputed log\u2010domain minima and maxima for each feature:\n# feature order: [learning_rate, batch_size, data_size, non_embedding_param_size]\n_LOG_MINS  = np.log(np.array([1.2e-4, 16.0,   4e9,    2.14e8], dtype=float))\n_LOG_MAXS  = np.log(np.array([2.2e-2, 4096.0, 1e11,   1e9   ], dtype=float))\n_LOG_RANGE = _LOG_MAXS - _LOG_MINS  # to normalize logs to [0,1]\n\ndef _build_design_matrix(u):\n    \"\"\"\n    Build a second\u2010order polynomial design matrix in normalized log\u2010space.\n    Columns: [1,\n              u0, u1, u2, u3,\n              u0^2, u1^2, u2^2, u3^2,\n              u0*u1, u0*u2, u0*u3, u1*u2, u1*u3, u2*u3]\n    \"\"\"\n    N, F = u.shape\n    # total parameters = 1 intercept + F linear + F squared + F*(F-1)/2 interactions\n    P = 1 + F + F + (F*(F-1))//2\n    Phi = np.empty((N, P), dtype=u.dtype)\n    # intercept\n    Phi[:, 0] = 1.0\n    # linear terms\n    Phi[:, 1:1+F] = u\n    # squared terms\n    start = 1 + F\n    Phi[:, start:start+F] = u**2\n    # pairwise interactions\n    idx = start + F\n    for i in range(F):\n        for j in range(i+1, F):\n            Phi[:, idx] = u[:, i] * u[:, j]\n            idx += 1\n    return Phi\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss via the learned normalized\u2010log quadratic scaling law.\n    \n    Args:\n      data_points: np.ndarray of shape (N,4) columns [lr, bsz, data_size, non_embedding_param_size]\n      params:      np.ndarray of length 15 (\u03b20, \u03b2_i, \u03b3_i, \u03b4_ij)\n    Returns:\n      preds: np.ndarray of shape (N,) predicted LM loss\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # support single-sample input\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[1] != 4:\n        raise ValueError(f\"Expected 4 features, got shape {X.shape}\")\n\n    # avoid non-positive before log\n    X = np.clip(X, 1e-12, None)\n    logX = np.log(X)\n    # normalize log\u2010features to [0,1]\n    u = (logX - _LOG_MINS) / _LOG_RANGE\n    # guard against numerical out\u2010of\u2010bounds\n    u = np.clip(u, 0.0, 1.0)\n\n    # build design matrix and predict\n    Phi = _build_design_matrix(u)            # shape (N,15)\n    p   = np.asarray(params, dtype=float).ravel()\n    if p.size != Phi.shape[1]:\n        raise ValueError(f\"Expected {Phi.shape[1]} params, got {p.size}\")\n    log_pred = Phi.dot(p)                    # shape (N,)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the normalized\u2010log quadratic scaling law via ridge\u2010regularized least squares.\n    \n    Args:\n      data_points: np.ndarray of shape (N,4)\n      loss_values: np.ndarray of shape (N,)\n    Returns:\n      params: np.ndarray of length 15 of learned coefficients in the log\u2010loss domain\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # support single-sample input\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[0] != y.size or X.shape[1] != 4:\n        raise ValueError(\"data_points must be (N,4) and match length of loss_values.\")\n\n    # avoid zeros before log\n    X = np.clip(X, 1e-12, None)\n    y = np.clip(y, 1e-12, None)\n    logX = np.log(X)\n    logy = np.log(y)\n\n    # normalize log\u2010features\n    u = (logX - _LOG_MINS) / _LOG_RANGE\n    u = np.clip(u, 0.0, 1.0)\n\n    # build design matrix\n    Phi = _build_design_matrix(u)            # shape (N,15)\n\n    # normal equations with adaptive ridge regularization\n    A = Phi.T.dot(Phi)                       # (15,15)\n    b = Phi.T.dot(logy)                      # (15,)\n    P = A.shape[0]\n    # adapt ridge scale to average diagonal magnitude\n    ridge = 1e-6 * np.trace(A) / P\n    # apply ridge to all but intercept\n    for i in range(1, P):\n        A[i, i] += ridge\n\n    params = np.linalg.solve(A, b)\n    return params\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "2f0ce955-733b-430e-8757-b96b83c7f5ec", "generation": 3, "timestamp": 1754806559.1056046, "iteration_found": 0, "metrics": {"nmse": 0.009529812593006361, "nmae": 0.10319057777458805, "r2": 0.9904701874069937, "combined_score": 0.990560147432864}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 3.159989276322785, "nmae": 2.209298429505658, "r2": -2.159989276322785, "combined_score": 0.2403852350513625}, "island": 2, "migrant": true}, "artifacts_json": null, "artifact_dir": null}