{"id": "71ab96b9-248b-4d33-91a1-7f111f21cc1c_migrant_4", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\n\n# Fixed log\u2010ranges for normalization (from problem description)\n_LOG_MIN = np.log(np.array([\n    1.2e-4,   # learning rate min\n    16.0,     # batch size min\n    4e9,      # data size min\n    2.14e8    # non\u2010embedding param size min\n], dtype=np.float64))\n\n_LOG_MAX = np.log(np.array([\n    2.2e-2,   # learning rate max\n    4096.0,   # batch size max\n    1e11,     # data size max\n    1e9       # non\u2010embedding param size max\n], dtype=np.float64))\n\n# Precompute midpoint and half\u2010range in log\u2010space\n_LOG_MEAN  = 0.5 * (_LOG_MIN + _LOG_MAX)\n_LOG_SCALE = 0.5 * (_LOG_MAX - _LOG_MIN)\n\ndef _build_design_matrix(X):\n    \"\"\"\n    Build a 2nd\u2010degree polynomial design matrix on normalized log\u2010features.\n    Let z_i = (log(x_i) \u2212 _LOG_MEAN[i]) / _LOG_SCALE[i].\n    Columns:\n      1,\n      z1, z2, z3, z4,\n      z1^2, z2^2, z3^2, z4^2,\n      z1*z2, z1*z3, z1*z4, z2*z3, z2*z4, z3*z4\n    Returns A of shape (N,15).\n    \"\"\"\n    eps = 1e-12\n    # Natural log and normalization to roughly [-1,1]\n    logs = np.log(X + eps)                     # (N,4)\n    z = (logs - _LOG_MEAN) / _LOG_SCALE         # (N,4)\n    N, F = z.shape\n\n    # 1) intercept\n    cols = [np.ones((N, 1), dtype=np.float64)]\n    # 2) linear terms z_i\n    cols.append(z)\n    # 3) quadratic terms z_i^2\n    cols.append(z ** 2)\n    # 4) pairwise interactions z_i * z_j for i<j\n    inters = []\n    for i in range(F):\n        for j in range(i + 1, F):\n            inters.append((z[:, i] * z[:, j])[:, None])\n    if inters:\n        cols.append(np.hstack(inters))\n\n    # Concatenate to form (N,15)\n    return np.hstack(cols)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss via a 15\u2010parameter 2nd\u2010degree polynomial in normalized log\u2010features:\n      log_loss = A \u00b7 \u03b8\n      loss     = exp(log_loss)\n    Inputs:\n      data_points: array\u2010like shape (N,4) [lr, bsz, data_size, non_embed_param_size]\n      params:      array\u2010like length 15\n    Returns:\n      preds: ndarray shape (N,) predicted LM losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    # allow single\u2010sample input\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"scaling_law_func expects shape (N,4), got {X.shape}\")\n\n    theta = np.asarray(params, dtype=np.float64).ravel()\n    A = _build_design_matrix(X)   # (N,15)\n    if theta.size != A.shape[1]:\n        raise ValueError(f\"scaling_law_func expects {A.shape[1]} parameters, got {theta.size}\")\n\n    log_pred = A.dot(theta)       # (N,)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 15\u2010parameter polynomial scaling law by ridge\u2010regularized least squares\n    on log(loss):\n      minimize ||A \u03b8 \u2212 log(y)||^2 + \u03bb ||\u03b8_{1:}||^2  (no penalty on \u03b80)\n    Returns optimized \u03b8 of shape (15,).\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    # allow single\u2010sample\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"fit_scaling_law expects shape (N,4), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    if X.shape[0] != y.size:\n        raise ValueError(\"Number of data points and loss values must match\")\n\n    # Build design matrix and log\u2010target\n    A = _build_design_matrix(X)        # (N,15)\n    eps = 1e-12\n    y_log = np.log(y + eps)            # (N,)\n\n    # Normal equations with adaptive ridge \u03bb\n    ATA = A.T.dot(A)                   # (15,15)\n    P = ATA.shape[0]\n    # regularization scaled by average diagonal entry for scale\u2010invariance\n    lam = 1e-4 * np.trace(ATA) / P\n    reg = lam * np.eye(P, dtype=np.float64)\n    reg[0, 0] = 0.0                    # no penalty on intercept\n\n    ATA_reg = ATA + reg\n\n    # improve conditioning if necessary\n    cond_thresh = 1e8\n    cond_val = np.linalg.cond(ATA_reg)\n    if cond_val > cond_thresh:\n        for _ in range(3):\n            lam *= 10.0\n            reg = lam * np.eye(P, dtype=np.float64)\n            reg[0, 0] = 0.0\n            ATA_reg = ATA + reg\n            cond_val = np.linalg.cond(ATA_reg)\n            if cond_val <= cond_thresh:\n                break\n\n    ATy = A.T.dot(y_log)\n\n    # solve robustly\n    try:\n        theta_opt = np.linalg.solve(ATA_reg, ATy)\n    except np.linalg.LinAlgError:\n        theta_opt = np.linalg.pinv(ATA_reg).dot(ATy)\n\n    return theta_opt\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "71ab96b9-248b-4d33-91a1-7f111f21cc1c", "generation": 3, "timestamp": 1754804623.8645978, "iteration_found": 0, "metrics": {"nmse": 8.229751012380724, "nmae": 3.184248036510827, "r2": -7.229751012380724, "combined_score": 0.10834528457578183}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 41.60691886070649, "nmae": 8.506807054031343, "r2": -40.60691886070649, "combined_score": 0.023470366474263715}, "island": 4, "migrant": true}, "artifacts_json": null, "artifact_dir": null}