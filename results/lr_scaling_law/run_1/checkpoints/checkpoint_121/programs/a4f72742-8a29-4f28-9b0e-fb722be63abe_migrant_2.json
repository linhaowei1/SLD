{"id": "a4f72742-8a29-4f28-9b0e-fb722be63abe_migrant_2", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\n\n# Pre\u2010defined log\u2010ranges for normalization (from problem description)\n_LOG_MIN = np.log(np.array([\n    1.2e-4,   # learning rate minimum\n    16.0,     # batch size minimum\n    4e9,      # data size minimum\n    2.14e8    # non\u2010embedding parameter size minimum\n], dtype=np.float64))\n\n_LOG_MAX = np.log(np.array([\n    2.2e-2,   # learning rate maximum\n    4096.0,   # batch size maximum\n    1e11,     # data size maximum\n    1e9       # non\u2010embedding parameter size maximum\n], dtype=np.float64))\n\n# Compute midpoint and half\u2010range for each feature (for normalization to ~[-1,1])\n_LOG_MEAN = 0.5 * (_LOG_MIN + _LOG_MAX)\n_LOG_SCALE = 0.5 * (_LOG_MAX - _LOG_MIN)\n\ndef _build_design_matrix(X):\n    \"\"\"\n    Build a numerically stable design matrix using Chebyshev\u2010basis polynomials\n    on normalized log\u2010features z_i = (log x_i \u2212 _LOG_MEAN_i)/_LOG_SCALE_i.\n    Features for each sample:\n      [1,\n       z1, z2, z3, z4,\n       T2(z1), T2(z2), T2(z3), T2(z4),\n       z1*z2, z1*z3, z1*z4, z2*z3, z2*z4, z3*z4]\n    where T2(z) = 2*z^2 \u2212 1 is the 2nd\u2010degree Chebyshev polynomial.\n    Returns:\n      A: ndarray of shape (N, 15)\n    \"\"\"\n    eps = 1e-12\n    # Safe log\n    logs = np.log(X + eps)\n    # Normalize to roughly [-1,1]\n    z = (logs - _LOG_MEAN) / _LOG_SCALE\n    N, F = z.shape  # F should be 4\n\n    # Intercept\n    cols = [np.ones((N, 1), dtype=np.float64)]\n    # Linear Chebyshev feature = z\n    cols.append(z)\n    # Quadratic Chebyshev features T2(z) = 2 z^2 - 1\n    T2 = 2.0 * (z**2) - 1.0\n    cols.append(T2)\n\n    # Pairwise interaction terms on the normalized z\n    inters = []\n    for i in range(F):\n        for j in range(i+1, F):\n            inters.append((z[:, i] * z[:, j])[:, None])\n    if inters:\n        cols.append(np.hstack(inters))\n\n    # Concatenate into design matrix\n    A = np.hstack(cols)  # shape (N, 1+4+4+6 = 15)\n    return A\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss via a 15\u2010parameter Chebyshev\u2010polynomial model in normalized log\u2010features:\n      log_loss = A \u00b7 \u03b8\n      loss     = exp(log_loss)\n\n    Inputs:\n      data_points: array\u2010like of shape (N,4) [lr, bsz, data_size, non_embedding_param_size]\n      params:      array\u2010like of length 15\n\n    Returns:\n      preds: ndarray of shape (N,) of predicted LM losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    # allow single\u2010point\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"scaling_law_func expects data_points shape (N,4), got {X.shape}\")\n\n    theta = np.asarray(params, dtype=np.float64).ravel()\n    A = _build_design_matrix(X)  # (N,15)\n    if theta.size != A.shape[1]:\n        raise ValueError(f\"scaling_law_func expects {A.shape[1]} parameters, got {theta.size}\")\n\n    log_pred = A.dot(theta)      # (N,)\n    # Exponentiate to recover loss\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 15-parameter Chebyshev\u2010polynomial scaling law by ridge\u2010regularized\n    least squares on log(loss):\n      minimize ||A \u03b8 \u2212 log(y)||^2 + \u03bb ||\u03b8_{1:}||^2\n    (No penalty on the intercept \u03b80.)\n\n    Inputs:\n      data_points: (N,4) array\n      loss_values: (N,)   array\n\n    Returns:\n      theta_opt: ndarray of shape (15,) optimized parameters\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"fit_scaling_law expects data_points shape (N,4), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    if X.shape[0] != y.size:\n        raise ValueError(\"fit_scaling_law: number of data points must match number of loss values\")\n\n    # Build design matrix and log\u2010target\n    A = _build_design_matrix(X)    # (N,15)\n    eps = 1e-12\n    y_log = np.log(y + eps)        # (N,)\n\n    # Normal equations for ridge regression\n    ATA = A.T.dot(A)               # (15,15)\n    ATy = A.T.dot(y_log)           # (15,)\n\n    P = ATA.shape[0]\n    # Adaptive regularization strength\n    lam_base = 1e-3\n    lam = lam_base * np.trace(ATA) / P\n    # Build regularization matrix\n    reg = lam * np.eye(P, dtype=np.float64)\n    reg[0, 0] = 0.0  # do not penalize intercept\n\n    ATA_reg = ATA + reg\n\n    # If system is ill\u2010conditioned, increase regularization\n    cond_threshold = 1e8\n    cond_val = np.linalg.cond(ATA_reg)\n    if cond_val > cond_threshold:\n        # boost \u03bb until condition number is acceptable\n        for _ in range(3):\n            lam *= 10.0\n            reg = lam * np.eye(P, dtype=np.float64)\n            reg[0, 0] = 0.0\n            ATA_reg = ATA + reg\n            cond_val = np.linalg.cond(ATA_reg)\n            if cond_val <= cond_threshold:\n                break\n\n    # Solve robustly\n    try:\n        theta_opt = np.linalg.solve(ATA_reg, ATy)\n    except np.linalg.LinAlgError:\n        theta_opt = np.linalg.pinv(ATA_reg).dot(ATy)\n\n    return theta_opt\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "a4f72742-8a29-4f28-9b0e-fb722be63abe", "generation": 4, "timestamp": 1754804623.8648512, "iteration_found": 0, "metrics": {"nmse": 8.056121635175172, "nmae": 3.1365850349902997, "r2": -7.056121635175172, "combined_score": 0.11042254513409669}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 8.229751012380724, "nmae": 3.184248036510827, "r2": -7.229751012380724, "combined_score": 0.10834528457578183}, "island": 2, "migrant": true}, "artifacts_json": null, "artifact_dir": null}