{"id": "71a8f7d9-fb0f-4e13-b6c5-580b628af661_migrant_3", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\n# Pre-defined log-ranges for normalization (from problem description)\n_LOG_MIN = np.log(np.array([\n    1.2e-4,   # lr minimum\n    16.0,     # bsz minimum\n    4e9,      # data_size minimum\n    2.14e8    # non_embedding_param_size minimum\n], dtype=np.float64))\n\n_LOG_MAX = np.log(np.array([\n    2.2e-2,   # lr maximum\n    4096.0,   # bsz maximum\n    1e11,     # data_size maximum\n    1e9       # non_embedding_param_size maximum\n], dtype=np.float64))\n\n# Compute midpoint and half-range for each log\u2010feature (normalize to ~[-1,1])\n_LOG_MEAN  = 0.5 * (_LOG_MIN + _LOG_MAX)\n_LOG_SCALE = 0.5 * (_LOG_MAX - _LOG_MIN)\n\ndef _build_design_matrix(X):\n    \"\"\"\n    Build a 2nd-degree polynomial design matrix in normalized log\u2010features with pairwise interactions:\n      features = [1,\n                  z_i for i in 0..3,\n                  z_i^2 for i in 0..3,\n                  z_i * z_j for 0 <= i < j < 4]\n    where z = (log(x) - _LOG_MEAN) / _LOG_SCALE.\n    Returns A of shape (N,15).\n    \"\"\"\n    eps = 1e-12\n    logs = np.log(X + eps)                  # shape (N,4)\n    z = (logs - _LOG_MEAN) / _LOG_SCALE     # normalize to ~[-1,1]\n    N, F = z.shape\n\n    # intercept term\n    cols = [np.ones((N, 1), dtype=np.float64)]\n    # linear terms\n    cols.append(z)\n    # quadratic terms\n    cols.append(z ** 2)\n    # pairwise interactions\n    inters = []\n    for i in range(F):\n        for j in range(i + 1, F):\n            inters.append((z[:, i] * z[:, j])[:, None])\n    if inters:\n        cols.append(np.hstack(inters))\n\n    return np.hstack(cols)  # final shape (N, 1 + 4 + 4 + 6 = 15)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict LM loss via a 15-parameter 2nd-degree polynomial in normalized log\u2010features:\n      log_loss = A \u00b7 \u03b8\n      loss     = exp(log_loss)\n    Inputs:\n      data_points: array-like of shape (N,4)\n                   columns [lr, bsz, data_size, non_embedding_param_size]\n      params:      array-like of length 15\n    Returns:\n      preds: ndarray of shape (N,) of predicted LM losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    # allow single sample\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"scaling_law_func expects data_points shape (N,4), got {X.shape}\")\n\n    theta = np.asarray(params, dtype=np.float64).ravel()\n    A = _build_design_matrix(X)   # shape (N,15)\n    if theta.size != A.shape[1]:\n        raise ValueError(f\"scaling_law_func expects {A.shape[1]} parameters, got {theta.size}\")\n\n    log_pred = A.dot(theta)       # shape (N,)\n    return np.exp(log_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 15-parameter polynomial scaling law by adaptive ridge-regularized least squares on log(loss):\n      minimize ||A \u03b8 \u2212 log(y)||^2 + \u03bb ||\u03b8_{1:}||^2\n    (no penalty on the intercept \u03b80).\n    Inputs:\n      data_points: (N,4) array\n      loss_values: (N,)   array of corresponding LM loss values\n    Returns:\n      theta_opt: (15,) optimized parameters\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    # allow single sample\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.ndim != 2 or X.shape[1] != 4:\n        raise ValueError(f\"fit_scaling_law expects data_points shape (N,4), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    if X.shape[0] != y.size:\n        raise ValueError(\"fit_scaling_law: number of data points and losses must match\")\n\n    # Build design matrix and log\u2010target\n    A = _build_design_matrix(X)            # shape (N,15)\n    eps = 1e-12\n    y_log = np.log(y + eps)                # (N,)\n\n    # Normal equations with adaptive ridge regularization\n    ATA = A.T.dot(A)                       # (15,15)\n    P = ATA.shape[0]\n    # adaptive \u03bb: scale by average diagonal magnitude\n    lam = 1e-4 * np.trace(ATA) / P\n    reg = lam * np.eye(P, dtype=np.float64)\n    reg[0, 0] = 0.0                        # no penalty on intercept\n\n    ATA_reg = ATA + reg\n    ATy = A.T.dot(y_log)\n\n    # solve robustly\n    try:\n        theta_opt = np.linalg.solve(ATA_reg, ATy)\n    except np.linalg.LinAlgError:\n        theta_opt = np.linalg.pinv(ATA_reg).dot(ATy)\n\n    return theta_opt\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "71a8f7d9-fb0f-4e13-b6c5-580b628af661", "generation": 5, "timestamp": 1754804623.8650525, "iteration_found": 0, "metrics": {"nmse": 8.229751012380724, "nmae": 3.184248036510827, "r2": -7.229751012380724, "combined_score": 0.10834528457578183}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 8.237640076708638, "nmae": 3.186254040646542, "r2": -7.237640076708638, "combined_score": 0.10825275629880342}, "island": 3, "migrant": true}, "artifacts_json": null, "artifact_dir": null}