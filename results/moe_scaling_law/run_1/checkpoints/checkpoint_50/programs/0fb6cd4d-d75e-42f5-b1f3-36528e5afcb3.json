{"id": "0fb6cd4d-d75e-42f5-b1f3-36528e5afcb3", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nRefined 6-parameter combined-capacity scaling law with analytic Jacobian and\nrelative\u2010error residuals.\n\nModel:\n    L(N_e, D) = (a*Ne^alpha + b*D^beta)^(-p) + c\n\nParams: [a, alpha, b, beta, p, c]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n\n    data_points: shape (N,2) array [[Ne, D], ...]\n    params:     array-like [a, alpha, b, beta, p, c]\n\n    Returns:\n      loss_pred: shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    a, alpha, b, beta, p, c = params\n\n    cap = a * (Ne**alpha) + b * (D**beta)\n    cap = np.clip(cap, 1e-12, None)\n    return cap**(-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined-capacity power law to minimize relative error.\n    Returns optimized params [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # clamp features\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # Robust initial guesses\n    y_min = max(np.min(y), 1e-8)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n    # assume alpha=beta=0.5, p=1\n    alpha0, beta0, p0 = 0.5, 0.5, 1.0\n    a0 = (1.0 / y_min) / (Ne_med**alpha0)\n    b0 = (1.0 / y_min) / (D_med**beta0)\n    c0 = max(0.0, y_min * 0.1)\n    x0 = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds\n    lb = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    ub = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # small floor to avoid zero\u2010division in relative residuals\n    eps_rel = max(np.median(y) * 1e-2, 1e-8)\n\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return (pred - y) / (y + eps_rel)\n\n    def jac(params):\n        # analytic Jacobian of residuals wrt [a, alpha, b, beta, p, c]\n        a, alpha, b, beta, p, c = params\n        cap = a * (Ne**alpha) + b * (D**beta)\n        cap = np.clip(cap, 1e-12, None)\n        t = cap**(-p)  # = pred - c\n        # common factors\n        inv_cap = 1.0 / cap\n        lnNe = np.log(Ne)\n        lnD  = np.log(D)\n\n        # \u2202t/\u2202a, \u2202t/\u2202alpha, \u2202t/\u2202b, \u2202t/\u2202beta, \u2202t/\u2202p\n        dt_da     = -p * t * inv_cap * (Ne**alpha)\n        dt_db     = -p * t * inv_cap * (D**beta)\n        dt_dalpha = -p * t * inv_cap * (a * (Ne**alpha) * lnNe)\n        dt_dbeta  = -p * t * inv_cap * (b * (D**beta) * lnD)\n        dt_dp     = -t * np.log(cap)\n        # \u2202resid/\u2202param = (1/(y+eps)) * \u2202pred/\u2202param, \u2202pred/\u2202c = 1\n        scale = 1.0 / (y + eps_rel)\n        J = np.stack([\n            dt_da * scale,\n            dt_dalpha * scale,\n            dt_db * scale,\n            dt_dbeta * scale,\n            dt_dp * scale,\n            np.ones_like(y) * scale\n        ], axis=1)\n        return J\n\n    sol = least_squares(\n        residuals,\n        x0=x0,\n        jac=jac,\n        bounds=(lb, ub),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.01,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "1a501f70-80b6-49d9-9561-d32d34bc7c2e", "generation": 3, "timestamp": 1754718327.6456227, "iteration_found": 50, "metrics": {"nmse": 0.11912884296630977, "nmae": 0.3297279655252331, "r2": 0.8808711570336902, "combined_score": 0.8935521645116817}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.12988874620272026, "nmae": 0.3338196020472984, "r2": 0.8701112537972797, "combined_score": 0.8850428888337506}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.1299\n- nmae: 0.3338\n- r2: 0.8701\n- combined_score: 0.8850\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: r2, combined_score. Consider continuing with similar changes.\n- Metrics showing regression: nmse, nmae. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.2975, nmae: 0.5260, r2: 0.7025, combined_score: 0.7707\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.2975, nmae: 0.5260, r2: 0.7025, combined_score: 0.7707\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.1299, nmae: 0.3338, r2: 0.8701, combined_score: 0.8850\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5547)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter combined\u2010capacity power\u2010law model with offset:\n    L(N_e, D) = (a * N_e^alpha + b * D^beta)^(-p) + c\nParameters: [a, alpha, b, beta, p, c] (6 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    Model: L = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Inputs:\n      data_points: array of shape (N,2) with columns [num_experts, dense_parameter_count]\n      params: length-6 array [a, alpha, b, beta, p, c]\n\n    Returns:\n      loss_pred: array of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    a, alpha, b, beta, p, c = params\n\n    # combined capacity term\n    cap = a * (Ne**alpha) + b * (D**beta)\n    cap = np.clip(cap, 1e-12, None)\n\n    # inverted power-law plus offset\n    loss_pred = cap**(-p) + c\n    return loss_pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined-capacity scaling law to data.\n    Returns optimized params [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # ensure positive features\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # derive robust initial guesses\n    y_min = np.min(y)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n\n    # a and b such that a*Ne_med^alpha \u2248 b*D_med^beta \u2248 1/y_min\n    # start with alpha=beta=0.5, p=1\n    alpha0, beta0, p0 = 0.5, 0.5, 1.0\n    a0 = (1.0 / max(y_min, 1e-8)) / (Ne_med**alpha0)\n    b0 = (1.0 / max(y_min, 1e-8)) / (D_med**beta0)\n    c0 = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds: scales \u22650, exponents in [0,5], offset \u22650\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # robust least-squares fitting with soft_l1 loss to dampen outliers\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1299), Performs well on nmae (0.3338), Performs well on r2 (0.8701), Performs well on combined_score (0.8850)\n\n\n### Program 2 (Score: 0.5742)\n```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n_eps = np.finfo(float).eps\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count\n    using a 6-parameter log\u2013quadratic interaction model:\n      L(E, P) = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)\u00b2 + \u03b85\u00b7(lnE)\u00b2)\n    where E = num_experts, P = dense_parameter_count.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    # Separate features\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # Build design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    # Linear combination in log-space, then exponentiate\n    u = M.dot(\u03b8)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model in two stages:\n      1) Closed-form linear least squares in log-space.\n      2) Robust Levenberg\u2013Marquardt refinement (soft-L1) on original residuals.\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    y = np.asarray(loss_values, float).ravel()\n\n    # Avoid non-positive values\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    ln_y = np.log(np.maximum(y, _eps))\n\n    # Design matrix in log-space\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    # 1) Closed-form least squares in log-space\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # 2) Robust refinement on original residuals\n    def residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    try:\n        sol = least_squares(\n            residuals,\n            x0=\u03b8_init,\n            method='trf',\n            loss='soft_l1',\n            f_scale=0.1,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=1000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.2975), Performs well on nmae (0.5260), Performs well on r2 (0.7025), Performs well on combined_score (0.7707)\n\n\n### Program 3 (Score: 0.5742)\n```python\n\"\"\"\nSix-parameter log\u2013quadratic scaling law with robust refinement.\n\nModel:\n    L(E, P) = exp(\u03b80\n                 + \u03b81\u00b7ln P\n                 + \u03b82\u00b7ln E\n                 + \u03b83\u00b7(ln P\u00b7ln E)\n                 + \u03b84\u00b7(ln P)\u00b2\n                 + \u03b85\u00b7(ln E)\u00b2)\n\nFitting proceeds in two stages:\n  1) Closed-form linear least squares in log-space.\n  2) Robust refinement via Levenberg\u2013Marquardt with soft-L1 loss.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n_eps = np.finfo(float).eps\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of 6 coefficients [\u03b80\u2026\u03b85]\n    Returns: (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    # avoid zero or negative values for log\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # build the design matrix [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    u = M.dot(\u03b8)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model.\n    1) Solve linear least squares in log-space.\n    2) Robust Levenberg\u2013Marquardt refinement on true residuals.\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    y = np.asarray(loss_values, float).ravel()\n\n    # clamp inputs to avoid invalid logs\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    ln_y = np.log(np.maximum(y, _eps))\n\n    # design matrix for log-space regression\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    # closed-form least squares in log-space\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # define residuals in original-loss space\n    def _residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    # robust refinement with soft-L1 loss\n    try:\n        sol = least_squares(\n            _residuals,\n            x0=\u03b8_init,\n            method='trf',\n            loss='soft_l1',\n            f_scale=0.1,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=1000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.2975), Performs well on nmae (0.5260), Performs well on r2 (0.7025), Performs well on combined_score (0.7707)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.6308)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5760)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Six-parameter log\u2013quadratic scaling law:\n      L(E,P) = exp(\n          \u03b80 \n        + \u03b81 * ln P\n        + \u03b82 * ln E\n        + \u03b83 * (ln P * ln E)\n        + \u03b84 * (ln P)**2\n        + \u03b85 * (ln E)**2\n      )\n    Inputs:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: length-6 array [\u03b80\u2026\u03b85]\n    Returns:\n      losses: (N,) predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 params, got {\u03b8.size}\")\n    # avoid log(0)\n    E = np.clip(X[:,0], 1e-8, None)\n    P = np.clip(X[:,1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP**2)\n        + \u03b85 * (lnE**2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model:\n      1) closed-form least squares on ln(loss)\n      2) robust relative-error refinement:\n           minimize (L_pred - L_true)/L_true under soft_l1 loss\n           with simple box bounds for stability.\n    Returns:\n      \u03b8_opt: array of 6 fitted parameters\n    \"\"\"\n    # Prepare arrays\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of losses must match number of data points\")\n    # ensure strictly positive for logs\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # features in log-space\n    E = np.clip(X[:,0], 1e-8, None)\n    P = np.clip(X[:,1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix for [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])\n\n    # 1) closed-form least squares in log-loss\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # 2) refine for relative residuals under robust loss\n    def rel_resid(theta):\n        # relative error\n        return (scaling_law_func(X, theta) - y) / np.clip(y, 1e-8, None)\n\n    try:\n        sol = least_squares(\n            rel_resid,\n            \u03b8_init,\n            method='trf',\n            loss='soft_l1',\n            f_scale=0.1,\n            bounds=(-100.0, 100.0),\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=1000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.7194, Type: Alternative)\n```python\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a 6-parameter log\u2013quadratic interaction model.\n    L(P, E) = exp( \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7lnP\u00b7lnE + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2 )\n    where P = dense parameter count, E = num_experts.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    E = X[:, 0]\n    P = X[:, 1]\n    # avoid non-positive inputs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2013quadratic with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model via\n    ridge-regularized, Huber\u2010robust least squares in log-space.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positive losses\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # ridge regularization weight (scale-adaptive)\n    # \u03bb = small fraction of average eigenvalue of M^T M\n    G = M.T @ M\n    \u03bb = 1e-6 * np.trace(G) / G.shape[0]\n    I6 = np.eye(6)\n\n    # initial ridge solution\n    A = M\n    Q = G + \u03bb * I6\n    b = A.T @ ln_y\n    \u03b8 = np.linalg.solve(Q, b)\n\n    # Huber\u2010style IRLS (2 iterations)\n    for _ in range(2):\n        r = A @ \u03b8 - ln_y\n        # robust scale estimate (MAD)\n        s = 1.4826 * np.median(np.abs(r))\n        if s < 1e-12:\n            break\n        delta = 1.345 * s\n        # weights: 1 for small residuals, delta/|r| for large ones\n        w = np.minimum(1.0, delta / (np.abs(r) + 1e-16))\n        sqrt_w = np.sqrt(w)\n        # weighted matrices\n        A_w = A * sqrt_w[:, None]\n        y_w = ln_y * sqrt_w\n        G_w = A_w.T @ A_w\n        b_w = A_w.T @ y_w\n        # solve weighted ridge\n        \u03b8 = np.linalg.solve(G_w + \u03bb * I6, b_w)\n\n    return \u03b8\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (2.281), Excellent nmae (1.573)\n\n\n### Inspiration 2 (Score: 0.7194, Type: Alternative)\n```python\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a 6-parameter log\u2013quadratic interaction model.\n    L(P, E) = exp( \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7lnP\u00b7lnE + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2 )\n    where P = dense parameter count, E = num_experts.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    E = X[:, 0]\n    P = X[:, 1]\n    # avoid non-positive inputs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2013quadratic with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model via\n    ridge-regularized, Huber\u2010robust least squares in log-space.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positive losses\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # ridge regularization weight (scale-adaptive)\n    # \u03bb = small fraction of average eigenvalue of M^T M\n    G = M.T @ M\n    \u03bb = 1e-6 * np.trace(G) / G.shape[0]\n    I6 = np.eye(6)\n\n    # initial ridge solution\n    A = M\n    Q = G + \u03bb * I6\n    b = A.T @ ln_y\n    \u03b8 = np.linalg.solve(Q, b)\n\n    # Huber\u2010style IRLS (2 iterations)\n    for _ in range(2):\n        r = A @ \u03b8 - ln_y\n        # robust scale estimate (MAD)\n        s = 1.4826 * np.median(np.abs(r))\n        if s < 1e-12:\n            break\n        delta = 1.345 * s\n        # weights: 1 for small residuals, delta/|r| for large ones\n        w = np.minimum(1.0, delta / (np.abs(r) + 1e-16))\n        sqrt_w = np.sqrt(w)\n        # weighted matrices\n        A_w = A * sqrt_w[:, None]\n        y_w = ln_y * sqrt_w\n        G_w = A_w.T @ A_w\n        b_w = A_w.T @ y_w\n        # solve weighted ridge\n        \u03b8 = np.linalg.solve(G_w + \u03bb * I6, b_w)\n\n    return \u03b8\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (2.281), Excellent nmae (1.573)\n\n\n### Inspiration 3 (Score: 0.5742, Type: Experimental)\n```python\n\"\"\"\nSix-parameter log\u2013quadratic scaling law with robust refinement.\n\nModel:\n    L(E, P) = exp(\u03b80\n                 + \u03b81\u00b7ln P\n                 + \u03b82\u00b7ln E\n                 + \u03b83\u00b7(ln P\u00b7ln E)\n                 + \u03b84\u00b7(ln P)\u00b2\n                 + \u03b85\u00b7(ln E)\u00b2)\n\nFitting proceeds in two stages:\n  1) Closed-form linear least squares in log-space.\n  2) Robust refinement via Levenberg\u2013Marquardt with soft-L1 loss.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n_eps = np.finfo(float).eps\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of 6 coefficients [\u03b80\u2026\u03b85]\n    Returns: (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    # avoid zero or negative values for log\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # build the design matrix [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    u = M.dot(\u03b8)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model.\n    1) Solve linear least squares in log-space.\n    2) Robust Levenberg\u2013Marquardt refinement on true residuals.\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    y = np.asarray(loss_values, float).ravel()\n\n    # clamp inputs to avoid invalid logs\n    E = np.maximum(X[:, 0], _eps)\n    P = np.maximum(X[:, 1], _eps)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    ln_y = np.log(np.maximum(y, _eps))\n\n    # design matrix for log-space regression\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2,\n    ])  # shape (N,6)\n\n    # closed-form least squares in log-space\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # define residuals in original-loss space\n    def _residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    # robust refinement with soft-L1 loss\n    try:\n        sol = least_squares(\n            _residuals,\n            x0=\u03b8_init,\n            method='trf',\n            loss='soft_l1',\n            f_scale=0.1,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=1000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 4 (Score: 0.6308, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.256), Excellent nmae (1.080)\n\n\n### Inspiration 5 (Score: 0.5760, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Six-parameter log\u2013quadratic scaling law:\n      L(E,P) = exp(\n          \u03b80 \n        + \u03b81 * ln P\n        + \u03b82 * ln E\n        + \u03b83 * (ln P * ln E)\n        + \u03b84 * (ln P)**2\n        + \u03b85 * (ln E)**2\n      )\n    Inputs:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: length-6 array [\u03b80\u2026\u03b85]\n    Returns:\n      losses: (N,) predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 params, got {\u03b8.size}\")\n    # avoid log(0)\n    E = np.clip(X[:,0], 1e-8, None)\n    P = np.clip(X[:,1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP**2)\n        + \u03b85 * (lnE**2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model:\n      1) closed-form least squares on ln(loss)\n      2) robust relative-error refinement:\n           minimize (L_pred - L_true)/L_true under soft_l1 loss\n           with simple box bounds for stability.\n    Returns:\n      \u03b8_opt: array of 6 fitted parameters\n    \"\"\"\n    # Prepare arrays\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of losses must match number of data points\")\n    # ensure strictly positive for logs\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # features in log-space\n    E = np.clip(X[:,0], 1e-8, None)\n    P = np.clip(X[:,1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix for [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])\n\n    # 1) closed-form least squares in log-loss\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # 2) refine for relative residuals under robust loss\n    def rel_resid(theta):\n        # relative error\n        return (scaling_law_func(X, theta) - y) / np.clip(y, 1e-8, None)\n\n    try:\n        sol = least_squares(\n            rel_resid,\n            \u03b8_init,\n            method='trf',\n            loss='soft_l1',\n            f_scale=0.1,\n            bounds=(-100.0, 100.0),\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=1000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter combined\u2010capacity power\u2010law model with offset:\n    L(N_e, D) = (a * N_e^alpha + b * D^beta)^(-p) + c\nParameters: [a, alpha, b, beta, p, c] (6 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    Model: L = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Inputs:\n      data_points: array of shape (N,2) with columns [num_experts, dense_parameter_count]\n      params: length-6 array [a, alpha, b, beta, p, c]\n\n    Returns:\n      loss_pred: array of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    a, alpha, b, beta, p, c = params\n\n    # combined capacity term\n    cap = a * (Ne**alpha) + b * (D**beta)\n    cap = np.clip(cap, 1e-12, None)\n\n    # inverted power-law plus offset\n    loss_pred = cap**(-p) + c\n    return loss_pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined-capacity scaling law to data.\n    Returns optimized params [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # ensure positive features\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # derive robust initial guesses\n    y_min = np.min(y)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n\n    # a and b such that a*Ne_med^alpha \u2248 b*D_med^beta \u2248 1/y_min\n    # start with alpha=beta=0.5, p=1\n    alpha0, beta0, p0 = 0.5, 0.5, 1.0\n    a0 = (1.0 / max(y_min, 1e-8)) / (Ne_med**alpha0)\n    b0 = (1.0 / max(y_min, 1e-8)) / (D_med**beta0)\n    c0 = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds: scales \u22650, exponents in [0,5], offset \u22650\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # robust least-squares fitting with soft_l1 loss to dampen outliers\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["Here is a refined 6-parameter combined\u2010capacity power\u2010law model. We now fit in *relative* residual space and supply an analytic Jacobian to the solver. This tends to reduce both NMSE and NMAE while preserving\u2014or improving\u2014R\u00b2.\n\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nRefined 6-parameter combined-capacity scaling law with analytic Jacobian and\nrelative\u2010error residuals.\n\nModel:\n    L(N_e, D) = (a*Ne^alpha + b*D^beta)^(-p) + c\n\nParams: [a, alpha, b, beta, p, c]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n\n    data_points: shape (N,2) array [[Ne, D], ...]\n    params:     array-like [a, alpha, b, beta, p, c]\n\n    Returns:\n      loss_pred: shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    a, alpha, b, beta, p, c = params\n\n    cap = a * (Ne**alpha) + b * (D**beta)\n    cap = np.clip(cap, 1e-12, None)\n    return cap**(-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined-capacity power law to minimize relative error.\n    Returns optimized params [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # clamp features\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # Robust initial guesses\n    y_min = max(np.min(y), 1e-8)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n    # assume alpha=beta=0.5, p=1\n    alpha0, beta0, p0 = 0.5, 0.5, 1.0\n    a0 = (1.0 / y_min) / (Ne_med**alpha0)\n    b0 = (1.0 / y_min) / (D_med**beta0)\n    c0 = max(0.0, y_min * 0.1)\n    x0 = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds\n    lb = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    ub = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # small floor to avoid zero\u2010division in relative residuals\n    eps_rel = max(np.median(y) * 1e-2, 1e-8)\n\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return (pred - y) / (y + eps_rel)\n\n    def jac(params):\n        # analytic Jacobian of residuals wrt [a, alpha, b, beta, p, c]\n        a, alpha, b, beta, p, c = params\n        cap = a * (Ne**alpha) + b * (D**beta)\n        cap = np.clip(cap, 1e-12, None)\n        t = cap**(-p)  # = pred - c\n        # common factors\n        inv_cap = 1.0 / cap\n        lnNe = np.log(Ne)\n        lnD  = np.log(D)\n\n        # \u2202t/\u2202a, \u2202t/\u2202alpha, \u2202t/\u2202b, \u2202t/\u2202beta, \u2202t/\u2202p\n        dt_da     = -p * t * inv_cap * (Ne**alpha)\n        dt_db     = -p * t * inv_cap * (D**beta)\n        dt_dalpha = -p * t * inv_cap * (a * (Ne**alpha) * lnNe)\n        dt_dbeta  = -p * t * inv_cap * (b * (D**beta) * lnD)\n        dt_dp     = -t * np.log(cap)\n        # \u2202resid/\u2202param = (1/(y+eps)) * \u2202pred/\u2202param, \u2202pred/\u2202c = 1\n        scale = 1.0 / (y + eps_rel)\n        J = np.stack([\n            dt_da * scale,\n            dt_dalpha * scale,\n            dt_db * scale,\n            dt_dbeta * scale,\n            dt_dp * scale,\n            np.ones_like(y) * scale\n        ], axis=1)\n        return J\n\n    sol = least_squares(\n        residuals,\n        x0=x0,\n        jac=jac,\n        bounds=(lb, ub),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.01,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END\n```\n\nKey improvements:\n- We fit *relative* residuals `(pred\u2013true)/(true+\u03b5)` to directly target NMSE/NMAE.\n- We supply an analytic Jacobian to speed and stabilize convergence.\n- Initialization and bounds remain concise; exponents stay in [0,5].\n- The extra small floor `eps_rel` guards against division by zero for very small true losses."]}}}