{"id": "28d64dde-e651-4c29-84e4-5c1b2bf36cb5", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    5-parameter power-law model for MoE validation loss:\n      L = a * Ne^{-p1} + b * D^{-p2} + c\n    where:\n      Ne = number of experts (>=1e-8),\n      D  = dense parameter count (>=1e-8),\n      params = [a, p1, b, p2, c].\n    Returns an array of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    # clip to avoid zero or negative\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 5:\n        raise ValueError(f\"Expected 5 parameters [a,p1,b,p2,c], got {p.size}\")\n    a, p1, b, p2, c = p\n\n    # power-law contributions\n    return a * Ne**(-p1) + b * D**(-p2) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter power-law model:\n      params = [a, p1, b, p2, c]\n    by robust non-linear least squares (soft L1 loss).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values length must match number of data points\")\n\n    # features clipped for stability\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # initial parameter guesses\n    y_min, y_max = np.min(y), np.max(y)\n    c0 = max(0.0, 0.5 * y_min)\n    # split remaining amplitude equally for experts and dense\n    a0 = max(1e-6, 0.5 * (y_max - c0))\n    b0 = a0\n    p1_0, p2_0 = 0.5, 0.5\n    init = np.array([a0, p1_0, b0, p2_0, c0], dtype=float)\n\n    # bounds: a,b,c >=0; exponents in [0, 3]\n    lower = [0.0, 0.0, 0.0, 0.0, 0.0]\n    upper = [np.inf, 3.0, np.inf, 3.0, np.inf]\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    sol = least_squares(\n        fun=residuals,\n        x0=init,\n        bounds=(lower, upper),\n        method='trf',\n        loss='soft_l1',    # robust to outliers\n        f_scale=1.0,\n        x_scale='jac',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "a76c5407-831b-4a84-a33d-dd1f54830339", "generation": 3, "timestamp": 1754718292.0934472, "iteration_found": 47, "metrics": {"nmse": 1.2573520772031743, "nmae": 1.080760931812216, "r2": -0.2573520772031743, "combined_score": 0.4429969122224766}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 2.0657736882420803, "nmae": 1.5133705735906786, "r2": -1.0657736882420803, "combined_score": 0.32618193698876763}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 2.0658\n- nmae: 1.5134\n- r2: -1.0658\n- combined_score: 0.3262\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3250, nmae: 0.5474, r2: 0.6750, combined_score: 0.7547\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.1444, nmae: 0.3401, r2: 0.8556, combined_score: 0.8738\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.1444, nmae: 0.3401, r2: 0.8556, combined_score: 0.8738\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5535)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law model for MoE validation loss:\n    L(Ne, D) = (a\u00b7Ne^\u03b1 + b\u00b7D^\u03b2)^(-p) + c\nwhere\n    Ne = num_experts,\n    D  = dense_parameter_count,\n    params = [a, \u03b1, b, \u03b2, p, c].\n\nWe fit these 6 parameters via bounded non\u2010linear least squares.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss for each (num_experts, dense_param_count).\n\n    Inputs:\n      data_points: array-like of shape (N,2)\n                   columns = [num_experts, dense_parameter_count]\n      params:      array-like of length 6 [a, \u03b1, b, \u03b2, p, c]\n\n    Returns:\n      losses: np.ndarray of shape (N,) with predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    # ensure positive inputs\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n    # unpack parameters\n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne**alpha) + b * (D**beta)\n    # avoid numerical issues\n    cap = np.clip(cap, 1e-12, None)\n    # inverted power-law plus offset\n    return cap**(-p) + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law:\n      params = [a, \u03b1, b, \u03b2, p, c]\n\n    Inputs:\n      data_points: array-like of shape (N,2)\n      loss_values: array-like of shape (N,)\n\n    Returns:\n      params_opt: np.ndarray of length 6 with fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    y = np.ravel(loss_values).astype(float)\n    # quick checks\n    if X.shape[0] != y.shape[0] or X.shape[1] != 2:\n        raise ValueError(\"data_points must be (N,2) and match loss_values length\")\n\n    # derive simple initial guesses\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n    y_min  = np.min(y)\n\n    # init a, alpha, b, beta, p, c\n    init = np.array([\n        1.0 / max(Ne_med, 1e-6),  # a\n        0.5,                      # \u03b1\n        1.0 / max(D_med, 1e-6),   # b\n        0.5,                      # \u03b2\n        0.5,                      # p\n        max(0.0, y_min * 0.1)     # c\n    ], dtype=float)\n\n    # bounds to keep parameters in reasonable ranges\n    lower = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    def residuals(p):\n        return scaling_law_func(X, p) - y\n\n    sol = least_squares(\n        residuals,\n        init,\n        bounds=(lower, upper),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1444), Performs well on nmae (0.3401), Performs well on r2 (0.8556), Performs well on combined_score (0.8738)\n\n\n### Program 2 (Score: 0.5535)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1444), Performs well on nmae (0.3401), Performs well on r2 (0.8556), Performs well on combined_score (0.8738)\n\n\n### Program 3 (Score: 0.5755)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSix-parameter log-quadratic scaling law with interaction and a two-stage fit:\n  1) closed-form linear least squares on ln(loss)\n  2) Levenberg\u2013Marquardt refinement on the original loss residuals\n\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7ln P\n                  + \u03b82\u00b7ln E\n                  + \u03b83\u00b7(ln P \u00b7 ln E)\n                  + \u03b84\u00b7(ln P)**2\n                  + \u03b85\u00b7(ln E)**2)\nwhere E = num_experts, P = dense_parameter_count.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Compute the 6-parameter log-quadratic scaling law.\n    Inputs:\n      data_points: (N,2) array of [num_experts, dense_parameter_count]\n      params: length-6 array [\u03b80 \u2026 \u03b85]\n    Returns:\n      (N,) array of predicted validation loss\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # ensure strictly positive features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic form with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model to (num_experts, dense_params) \u2192 loss.\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Stage 1: linear least squares in log-loss space\n    # clip and log-transform\n    y_clip = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clip)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # Stage 2: refine with Levenberg\u2013Marquardt on original residuals\n    def _residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    try:\n        sol = least_squares(\n            _residuals,\n            \u03b8_init,\n            method='lm',\n            max_nfev=500,\n            ftol=1e-8,\n            xtol=1e-8\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        # fallback to Stage-1 solution if LM fails\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3250), Performs well on nmae (0.5474), Performs well on r2 (0.6750), Performs well on combined_score (0.7547)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model with interaction term.\nModel form:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\nFitting is done via linear least squares on ln(loss) for numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    # extract features and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    loss_values: (N,) array of validation loss (must be > 0)\n    Returns: params array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must be a 1D array of same length as data_points\")\n    # avoid log of zero or negative\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n    # feature logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix M of shape (N,6)\n    # columns: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n    # solve for \u03b8 in least squares sense: M \u00b7 \u03b8 = ln_y\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5535, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 2 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 3 (Score: 0.6309, Type: Alternative)\n```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\n\"\"\"\nRefined scaling law for Mixture\u2010of\u2010Experts LLM validation loss.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\nUses robust non\u2010linear least squares with soft L1 loss.\n\"\"\"\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split features\n    ne = X[:, 0]\n    dp = X[:, 1]\n    # Guard against zero\n    ne = np.clip(ne, 1e-8, None)\n    dp = np.clip(dp, 1e-8, None)\n    # Unpack parameters\n    a, p1, b, p2, c = params\n    # Power\u2010law contributions\n    return a * ne**(-p1) + b * dp**(-p2) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5\u2010parameter scaling law to minimize robust MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Residual function\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Initial guesses\n    y_min, y_max = np.min(y), np.max(y)\n    init_c = max(0.0, 0.5 * y_min)\n    init_a = max(1.0, y_max - init_c)\n    init_b = init_a\n    init_p1, init_p2 = 0.5, 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c], dtype=float)\n\n    # Parameter bounds: a,b,c >=0; exponents between 0 and 3\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 3.0, np.inf, 3.0, np.inf]\n\n    # Robust non\u2010linear least squares\n    result = least_squares(\n        fun=residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',      # soft L1 gives robustness to outliers\n        f_scale=1.0,\n        x_scale='jac',\n        ftol=1e-8,\n        xtol=1e-8,\n        gtol=1e-8,\n        max_nfev=2000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.257), Excellent nmae (1.081)\n\n\n### Inspiration 4 (Score: 0.5535, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law model for MoE validation loss:\n    L(Ne, D) = (a\u00b7Ne^\u03b1 + b\u00b7D^\u03b2)^(-p) + c\nwhere\n    Ne = num_experts,\n    D  = dense_parameter_count,\n    params = [a, \u03b1, b, \u03b2, p, c].\n\nWe fit these 6 parameters via bounded non\u2010linear least squares.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss for each (num_experts, dense_param_count).\n\n    Inputs:\n      data_points: array-like of shape (N,2)\n                   columns = [num_experts, dense_parameter_count]\n      params:      array-like of length 6 [a, \u03b1, b, \u03b2, p, c]\n\n    Returns:\n      losses: np.ndarray of shape (N,) with predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    # ensure positive inputs\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n    # unpack parameters\n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne**alpha) + b * (D**beta)\n    # avoid numerical issues\n    cap = np.clip(cap, 1e-12, None)\n    # inverted power-law plus offset\n    return cap**(-p) + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law:\n      params = [a, \u03b1, b, \u03b2, p, c]\n\n    Inputs:\n      data_points: array-like of shape (N,2)\n      loss_values: array-like of shape (N,)\n\n    Returns:\n      params_opt: np.ndarray of length 6 with fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, float))\n    y = np.ravel(loss_values).astype(float)\n    # quick checks\n    if X.shape[0] != y.shape[0] or X.shape[1] != 2:\n        raise ValueError(\"data_points must be (N,2) and match loss_values length\")\n\n    # derive simple initial guesses\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n    Ne_med = np.median(Ne)\n    D_med  = np.median(D)\n    y_min  = np.min(y)\n\n    # init a, alpha, b, beta, p, c\n    init = np.array([\n        1.0 / max(Ne_med, 1e-6),  # a\n        0.5,                      # \u03b1\n        1.0 / max(D_med, 1e-6),   # b\n        0.5,                      # \u03b2\n        0.5,                      # p\n        max(0.0, y_min * 0.1)     # c\n    ], dtype=float)\n\n    # bounds to keep parameters in reasonable ranges\n    lower = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    def residuals(p):\n        return scaling_law_func(X, p) - y\n\n    sol = least_squares(\n        residuals,\n        init,\n        bounds=(lower, upper),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 5 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model with interaction term.\nModel form:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\nFitting is done via linear least squares on ln(loss) for numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    # extract features and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    loss_values: (N,) array of validation loss (must be > 0)\n    Returns: params array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must be a 1D array of same length as data_points\")\n    # avoid log of zero or negative\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n    # feature logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix M of shape (N,6)\n    # columns: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n    # solve for \u03b8 in least squares sense: M \u00b7 \u03b8 = ln_y\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    6-parameter log-quadratic model with interaction:\n      ln L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\n    returns L = exp(ln L).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    # experts E, dense params P\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6 log-quadratic parameters by solving\n      (M^T M + \u03bb I) \u03b8 = M^T ln(y)\n    where M = [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # clip+log features and targets\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    ln_y = np.log(np.clip(y, 1e-8, None))\n\n    # build design matrix\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])  # shape (N,6)\n\n    # small ridge for stability\n    lam = 1e-6 * np.trace(M.T @ M) / M.shape[1]\n    A = M.T @ M + lam * np.eye(6)\n    b = M.T @ ln_y\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    5-parameter power-law model for MoE validation loss:\n      L = a * Ne^{-p1} + b * D^{-p2} + c\n    where:\n      Ne = number of experts (>=1e-8),\n      D  = dense parameter count (>=1e-8),\n      params = [a, p1, b, p2, c].\n    Returns an array of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    # clip to avoid zero or negative\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 5:\n        raise ValueError(f\"Expected 5 parameters [a,p1,b,p2,c], got {p.size}\")\n    a, p1, b, p2, c = p\n\n    # power-law contributions\n    return a * Ne**(-p1) + b * D**(-p2) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter power-law model:\n      params = [a, p1, b, p2, c]\n    by robust non-linear least squares (soft L1 loss).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values length must match number of data points\")\n\n    # features clipped for stability\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    # initial parameter guesses\n    y_min, y_max = np.min(y), np.max(y)\n    c0 = max(0.0, 0.5 * y_min)\n    # split remaining amplitude equally for experts and dense\n    a0 = max(1e-6, 0.5 * (y_max - c0))\n    b0 = a0\n    p1_0, p2_0 = 0.5, 0.5\n    init = np.array([a0, p1_0, b0, p2_0, c0], dtype=float)\n\n    # bounds: a,b,c >=0; exponents in [0, 3]\n    lower = [0.0, 0.0, 0.0, 0.0, 0.0]\n    upper = [np.inf, 3.0, np.inf, 3.0, np.inf]\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    sol = least_squares(\n        fun=residuals,\n        x0=init,\n        bounds=(lower, upper),\n        method='trf',\n        loss='soft_l1',    # robust to outliers\n        f_scale=1.0,\n        x_scale='jac',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000\n    )\n    return sol.x\n# EVOLVE-BLOCK-END\n```"]}}}