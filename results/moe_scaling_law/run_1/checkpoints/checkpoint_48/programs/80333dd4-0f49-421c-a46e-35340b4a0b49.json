{"id": "80333dd4-0f49-421c-a46e-35340b4a0b49", "code": "import numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Combined power\u2010law scaling for MoE validation loss:\n      L = (a * E^alpha + b * P^beta)^(-p) + c\n    where:\n      E = num_experts\n      P = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split features and enforce minimal positivity\n    E = np.clip(X[:, 0], 1.0, None)\n    P = np.clip(X[:, 1], 1.0, None)\n\n    # Unpack parameters\n    a, alpha, b, beta, p, c = params\n\n    # Compute combined capacity\n    cap = a * (E ** alpha) + b * (P ** beta)\n    cap = np.maximum(cap, 1e-12)  # guard against zero/negative\n\n    # Invert power-law and add offset\n    return cap ** (-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined power-law via robust nonlinear least squares.\n    Returns optimized params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Mismatched data_points and loss_values lengths\")\n\n    # Derive robust initial guesses\n    E = X[:, 0]\n    P = X[:, 1]\n    E_med = np.median(np.clip(E, 1.0, None))\n    P_med = np.median(np.clip(P, 1.0, None))\n    y_min = np.min(y)\n\n    a0 = 1.0 / max(E_med, 1e-6)\n    b0 = 1.0 / max(P_med, 1e-6)\n    alpha0 = 1.0\n    beta0 = 1.0\n    p0 = 1.0\n    c0 = max(0.0, y_min * 0.5)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Bounds to keep parameters in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # Residual function (original space)\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Huber scale based on median absolute deviation\n    scale = np.median(np.abs(y - np.median(y)))\n    f_scale = max(scale, 1e-8)\n\n    # Robust non\u2010linear least squares\n    try:\n        result = least_squares(\n            residuals,\n            x0=init_params,\n            bounds=(lower_bounds, upper_bounds),\n            method='trf',\n            loss='huber',\n            f_scale=f_scale,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=5000\n        )\n        return result.x\n    except Exception:\n        # Fallback to initial guess if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "1d7d429a-7917-4acb-bab9-49814de07a4a", "generation": 4, "timestamp": 1754718271.6443748, "iteration_found": 44, "metrics": {"nmse": 0.1459797502329571, "nmae": 0.34117669896302855, "r2": 0.8540202497670429, "combined_score": 0.8726157681204383}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.32497090490278296, "nmae": 0.5473991377321862, "r2": 0.6750290950972171, "combined_score": 0.7547335539970766}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3250\n- nmae: 0.5474\n- r2: 0.6750\n- combined_score: 0.7547\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3361, nmae: 0.5750, r2: 0.6639, combined_score: 0.7484\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3250, nmae: 0.5474, r2: 0.6750, combined_score: 0.7547\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.1444, nmae: 0.3401, r2: 0.8556, combined_score: 0.8738\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5535)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1444), Performs well on nmae (0.3401), Performs well on r2 (0.8556), Performs well on combined_score (0.8738)\n\n\n### Program 2 (Score: 0.5755)\n```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    6\u2010parameter log\u2010quadratic scaling law for MoE validation loss:\n      L(E, P) = exp(\u03b80\n                    + \u03b81\u00b7ln P\n                    + \u03b82\u00b7ln E\n                    + \u03b83\u00b7(ln P * ln E)\n                    + \u03b84\u00b7(ln P)**2\n                    + \u03b85\u00b7(ln E)**2)\n    Inputs:\n      data_points : array\u2010like, shape (N,2)\n                     columns [num_experts, dense_parameter_count]\n      params      : array\u2010like, length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      losses      : ndarray, shape (N,)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # Avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    exponent = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(exponent)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic model:\n      1) Tikhonov\u2010regularized linear least squares in log\u2010loss space for initial \u03b8.\n      2) Robust trust\u2010region (TRF) refinement on original\u2010loss residuals with Huber loss.\n    Returns:\n      \u03b8_opt : ndarray, length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of loss_values must match number of data points\")\n\n    # Ensure strictly positive for log transformation\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # Prepare log\u2010features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix for [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])\n\n    # Tikhonov regularization factor (small)\n    reg = 1e-4 * np.trace(M.T @ M) / M.shape[1]\n    A = M.T @ M + reg * np.eye(6)\n    b = M.T @ ln_y\n    \u03b8_init = np.linalg.solve(A, b)\n\n    # Define residuals in original\u2010loss space\n    def residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    # Robust TRF refinement with Huber loss\n    try:\n        sol = least_squares(\n            residuals,\n            \u03b8_init,\n            method='trf',\n            loss='huber',\n            f_scale=np.std(y) if y.size > 1 else 1.0,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=2000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3250), Performs well on nmae (0.5474), Performs well on r2 (0.6750), Performs well on combined_score (0.7547)\n\n\n### Program 3 (Score: 0.5809)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\"\"\"\nRobust log\u2013quadratic scaling law for MoE architectures.\nWe model:\n    L = exp(\u03b80\n            + \u03b81\u00b7lnP\n            + \u03b82\u00b7lnE\n            + \u03b83\u00b7(lnP\u00b7lnE)\n            + \u03b84\u00b7(lnP)^2\n            + \u03b85\u00b7(lnE)^2 )\nand fit \u03b8 via Iteratively Reweighted Least Squares (Huber loss) in log\u2010space.\nThis guards against outliers while retaining a closed\u2010form update.\n\"\"\"\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss:\n      data_points: (N,2) array [num_experts, dense_param_count]\n      params: array-like of length 6\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # split and clip to positive\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # log\u2010features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic model by Huber\u2010IRLS on log(loss).\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    # Prepare arrays\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # features clipped for log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # target in log\u2010space\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # Initial least\u2010squares estimate\n    \u03b8 = np.linalg.lstsq(M, ln_y, rcond=None)[0]\n\n    # IRLS parameters\n    lambda_reg = 1e-6  # small Tikhonov regularization\n    max_iters = 8\n\n    for _ in range(max_iters):\n        # residuals in log\u2010space\n        r = ln_y - M.dot(\u03b8)\n        # Huber threshold c = 1.345 * robust scale\n        mad = np.median(np.abs(r))\n        scale = mad if mad > 1e-8 else np.std(r)\n        c = 1.345 * max(scale, 1e-8)\n        # Huber weights\n        abs_r = np.abs(r)\n        w = np.where(abs_r <= c, 1.0, c / abs_r)\n        # weighted normal equations: (M^T W M + \u03bbI) \u03b8 = M^T W ln_y\n        Wm = M * w[:, None]\n        A = Wm.T.dot(M) + lambda_reg * np.eye(6)\n        b = Wm.T.dot(ln_y)\n        \u03b8_new = np.linalg.solve(A, b)\n        # convergence check\n        if np.allclose(\u03b8, \u03b8_new, atol=1e-8, rtol=1e-6):\n            \u03b8 = \u03b8_new\n            break\n        \u03b8 = \u03b8_new\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3361), Performs well on nmae (0.5750), Performs well on r2 (0.6639), Performs well on combined_score (0.7484)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5535, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 2 (Score: 2.0530, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nInitial program with a simple power law form that can be evolved\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    N, F = X.shape\n    params = np.asarray(params)\n\n    if params.ndim == 1:\n        params = params[None, :]                         # (1, P)\n    T, P = params.shape\n\n    coeffs    = params[:, :F]                            # (T, F)\n    exponents = params[:, F:2*F]                         # (T, F)\n    bias      = params[:, -1]                            # (T,)\n\n    pred = (coeffs[None, :, :] * (X[:, None, :] ** exponents[None, :, :])).sum(axis=2) + bias[None, :]\n\n    return pred[:, 0] if pred.shape[1] == 1 else pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    y = np.asarray(loss_values)\n    N, F = X.shape\n    P = 2 * F + 1\n\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    T = y2d.shape[1]\n\n    init = np.ones((T, P))\n\n    def objective(flat_params):\n        params = flat_params.reshape(T, P)\n        pred = scaling_law_func(X, params)               # (N, T)\n        mse = np.mean((pred - y2d) ** 2)\n        return mse\n\n    result = minimize(objective, init.ravel(), method='BFGS')\n    params_opt = result.x.reshape(T, P) if result.success else init\n\n    return params_opt[0] if T == 1 else params_opt\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Excellent nmse (40.106), Excellent nmae (7.188), Alternative r2 approach\n\n\n### Inspiration 3 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 4 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.7801, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    6-parameter log\u2013quadratic interaction model:\n      ln L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\n    L = exp(ln L)\n    Inputs:\n      data_points: (N,2) array [[E,P],...]\n      params: length-6 vector [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # experts E, dense params P\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    # unpack\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # log\u2010quadratic with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit \u03b80\u2026\u03b85 by solving a small ridge\u2010regularized least squares in log-space:\n      minimize ||M \u03b8 \u2013 ln(y)||^2 + \u03bb||\u03b8||^2\n    where M = [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # clip and log features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # clip and log target\n    ln_y = np.log(np.clip(y, 1e-8, None))\n\n    # design matrix (N\u00d76)\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])\n\n    # small ridge \u03bb based on trace for stability\n    lam = 1e-8 * np.trace(M.T @ M) / M.shape[1]\n    A = M.T @ M + lam * np.eye(M.shape[1])\n    b = M.T @ ln_y\n\n    # solve for \u03b8\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (2.710), Excellent nmae (1.851)\n\n\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    6\u2010parameter log\u2010quadratic scaling law for MoE validation loss:\n      L(E, P) = exp(\u03b80\n                    + \u03b81\u00b7ln P\n                    + \u03b82\u00b7ln E\n                    + \u03b83\u00b7(ln P * ln E)\n                    + \u03b84\u00b7(ln P)**2\n                    + \u03b85\u00b7(ln E)**2)\n    Inputs:\n      data_points : array\u2010like, shape (N,2)\n                     columns [num_experts, dense_parameter_count]\n      params      : array\u2010like, length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      losses      : ndarray, shape (N,)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # Avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    exponent = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(exponent)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic model:\n      1) Tikhonov\u2010regularized linear least squares in log\u2010loss space for initial \u03b8.\n      2) Robust trust\u2010region (TRF) refinement on original\u2010loss residuals with Huber loss.\n    Returns:\n      \u03b8_opt : ndarray, length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of loss_values must match number of data points\")\n\n    # Ensure strictly positive for log transformation\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # Prepare log\u2010features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix for [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ])\n\n    # Tikhonov regularization factor (small)\n    reg = 1e-4 * np.trace(M.T @ M) / M.shape[1]\n    A = M.T @ M + reg * np.eye(6)\n    b = M.T @ ln_y\n    \u03b8_init = np.linalg.solve(A, b)\n\n    # Define residuals in original\u2010loss space\n    def residuals(theta):\n        return scaling_law_func(X, theta) - y\n\n    # Robust TRF refinement with Huber loss\n    try:\n        sol = least_squares(\n            residuals,\n            \u03b8_init,\n            method='trf',\n            loss='huber',\n            f_scale=np.std(y) if y.size > 1 else 1.0,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=2000\n        )\n        \u03b8_opt = sol.x\n    except Exception:\n        \u03b8_opt = \u03b8_init\n\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Combined power\u2010law scaling for MoE validation loss:\n      L = (a * E^alpha + b * P^beta)^(-p) + c\n    where:\n      E = num_experts\n      P = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split features and enforce minimal positivity\n    E = np.clip(X[:, 0], 1.0, None)\n    P = np.clip(X[:, 1], 1.0, None)\n\n    # Unpack parameters\n    a, alpha, b, beta, p, c = params\n\n    # Compute combined capacity\n    cap = a * (E ** alpha) + b * (P ** beta)\n    cap = np.maximum(cap, 1e-12)  # guard against zero/negative\n\n    # Invert power-law and add offset\n    return cap ** (-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter combined power-law via robust nonlinear least squares.\n    Returns optimized params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Mismatched data_points and loss_values lengths\")\n\n    # Derive robust initial guesses\n    E = X[:, 0]\n    P = X[:, 1]\n    E_med = np.median(np.clip(E, 1.0, None))\n    P_med = np.median(np.clip(P, 1.0, None))\n    y_min = np.min(y)\n\n    a0 = 1.0 / max(E_med, 1e-6)\n    b0 = 1.0 / max(P_med, 1e-6)\n    alpha0 = 1.0\n    beta0 = 1.0\n    p0 = 1.0\n    c0 = max(0.0, y_min * 0.5)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Bounds to keep parameters in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # Residual function (original space)\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Huber scale based on median absolute deviation\n    scale = np.median(np.abs(y - np.median(y)))\n    f_scale = max(scale, 1e-8)\n\n    # Robust non\u2010linear least squares\n    try:\n        result = least_squares(\n            residuals,\n            x0=init_params,\n            bounds=(lower_bounds, upper_bounds),\n            method='trf',\n            loss='huber',\n            f_scale=f_scale,\n            ftol=1e-9,\n            xtol=1e-9,\n            gtol=1e-9,\n            max_nfev=5000\n        )\n        return result.x\n    except Exception:\n        # Fallback to initial guess if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```"]}}}