{"id": "e4cdd8bc-15da-474b-8649-d61ae67ba61f", "code": "\"\"\"\nRobust log\u2013quadratic interaction scaling law for Mixture\u2010of\u2010Experts (MoE) validation loss.\nModel form (in log\u2010space):\n    ln L = \u03b80\n         + \u03b81\u00b7lnE\n         + \u03b82\u00b7lnP\n         + \u03b83\u00b7(lnE\u00b7lnP)\n         + \u03b84\u00b7(lnE)^2\n         + \u03b85\u00b7(lnP)^2\nWe fit via ridge\u2010regularized least squares followed by Huber IRLS for robustness\nand numerical stability across diverse MoE configurations.\n\"\"\"\nimport numpy as np\n\n# Small constant to ensure positivity\n_EPS = 1e-8\n# Ridge penalty on interaction/quadratic features\n_RIDGE_LAMBDA = 1e-6\n# Number of IRLS iterations\n_IRLS_ITERS = 3\n\ndef _build_design_matrix(E, P):\n    \"\"\"\n    Build design matrix M with columns:\n      [1, lnE, lnP, lnE*lnP, (lnE)^2, (lnP)^2]\n    E, P: arrays of shape (N,)\n    Returns: M of shape (N,6)\n    \"\"\"\n    E_safe = np.maximum(E, _EPS)\n    P_safe = np.maximum(P, _EPS)\n    lnE = np.log(E_safe)\n    lnP = np.log(P_safe)\n    return np.column_stack([\n        np.ones_like(lnE),\n        lnE,\n        lnP,\n        lnE * lnP,\n        lnE**2,\n        lnP**2,\n    ])\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given data_points and params.\n    data_points: array\u2010like of shape (N,2) with columns [num_experts, dense_parameter_count]\n    params: array\u2010like of length 6 [\u03b80,\u2026,\u03b85]\n    Returns: array of shape (N,) of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points of shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    E = X[:, 0]\n    P = X[:, 1]\n    M = _build_design_matrix(E, P)   # (N,6)\n    ln_pred = M.dot(\u03b8)\n    return np.exp(ln_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law.\n    Uses ridge\u2010regularized least squares in log-space followed by Huber IRLS.\n    data_points: array\u2010like of shape (N,2)\n    loss_values: array\u2010like of shape (N,)\n    Returns: array of optimized parameters [\u03b80,\u2026,\u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points of shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must have same length as data_points\")\n\n    # Prepare log-target\n    y_safe = np.maximum(y, _EPS)\n    ln_y = np.log(y_safe)\n\n    # Build design matrix\n    E = X[:, 0]\n    P = X[:, 1]\n    M = _build_design_matrix(E, P)   # (N,6)\n\n    # Construct ridge matrix penalizing interaction/quadratics (cols 3,4,5)\n    R = np.zeros((6, 6), dtype=float)\n    for idx in (3, 4, 5):\n        R[idx, idx] = _RIDGE_LAMBDA\n\n    # Initial ridge\u2010regularized solve: (M\u1d40M + R) \u03b8 = M\u1d40 ln_y\n    A = M.T.dot(M) + R\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # Huber IRLS for robustness\n    for _ in range(_IRLS_ITERS):\n        r = M.dot(\u03b8) - ln_y\n        # Scale estimate via MAD\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + _EPS\n        delta = 1.345 * mad\n        abs_r = np.abs(r)\n        # Huber weights\n        w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n        # Weighted normal equations\n        W = w[:, None]\n        A_w = M.T.dot(W * M) + R\n        b_w = M.T.dot(w * ln_y)\n        \u03b8 = np.linalg.solve(A_w, b_w)\n\n    return \u03b8", "language": "python", "parent_id": "b2fa42ad-de1a-488c-abe9-ca9d7294da39", "generation": 3, "timestamp": 1754718961.1807284, "iteration_found": 46, "metrics": {"nmse": 0.31365484502750324, "nmae": 0.5469430002810093, "r2": 0.6863451549724968, "combined_score": 0.7612349650178192}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.36751514046727124, "nmae": 0.5937087780384879, "r2": 0.6324848595327288, "combined_score": 0.7312533297863937}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3675\n- nmae: 0.5937\n- r2: 0.6325\n- combined_score: 0.7313\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3137, nmae: 0.5469, r2: 0.6863, combined_score: 0.7612\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5770)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEfficient, robust log\u2013quadratic interaction scaling law for Mixture\u2010of\u2010Experts (MoE) validation loss.\nModel form (in log\u2010space):\n    ln L = \u03b80 \n         + \u03b81\u00b7lnE \n         + \u03b82\u00b7lnP \n         + \u03b83\u00b7(lnE\u00b7lnP) \n         + \u03b84\u00b7(lnE)^2 \n         + \u03b85\u00b7(lnP)^2\nWe fit via iteratively reweighted least squares (Huber IRLS) with a small ridge regularization\non the interaction/quadratic terms for numerical stability and better generalization.\n\"\"\"\n\nimport numpy as np\n\n# Small constant to keep inputs strictly positive\n_EPS = 1e-8\n# Regularization strength for [lnE\u00b7lnP, (lnE)^2, (lnP)^2] terms\n_RIDGE_LAMBDA = 1e-6\n# Number of IRLS iterations\n_IRLS_ITERS = 3\n\ndef _build_design_matrix(num_experts, dense_params):\n    \"\"\"\n    Construct the design matrix M of shape (N,6) for inputs:\n      - constant term\n      - lnE\n      - lnP\n      - lnE * lnP\n      - (lnE)^2\n      - (lnP)^2\n    \"\"\"\n    E = np.maximum(num_experts, _EPS)\n    P = np.maximum(dense_params, _EPS)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    return np.column_stack([\n        np.ones_like(lnE),    # intercept\n        lnE,\n        lnP,\n        lnE * lnP,\n        lnE**2,\n        lnP**2,\n    ])\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: array\u2010like of shape (N,2) with [num_experts, dense_parameter_count]\n      params: array\u2010like of length 6 [\u03b80 \u2026 \u03b85]\n    Returns:\n      preds: (N,) array of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    M = _build_design_matrix(X[:, 0], X[:, 1])  # shape (N,6)\n    ln_preds = M.dot(\u03b8)\n    return np.exp(ln_preds)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model by minimizing\n    squared error in log-space with Huber IRLS and small ridge regularization.\n    Returns:\n      \u03b8_opt: array of optimized parameters [\u03b80 \u2026 \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must be a 1D array of same length as data_points\")\n\n    # Prepare log\u2010loss target, avoid zeros\n    y_safe = np.maximum(y, _EPS)\n    ln_y = np.log(y_safe)\n\n    # Build design matrix M (N\u00d76)\n    M = _build_design_matrix(X[:, 0], X[:, 1])\n\n    # Initial \u03b8 via ridge\u2010regularized least squares in log-space:\n    # Solve (M\u1d40M + \u03bb\u00b7R) \u03b8 = M\u1d40 ln_y\n    # where R penalizes only the interaction/quadratic terms (indices 3,4,5)\n    N_params = M.shape[1]\n    R = np.zeros((N_params, N_params), dtype=float)\n    # penalize columns [lnE\u00b7lnP, lnE^2, lnP^2]\n    for idx in (3, 4, 5):\n        R[idx, idx] = _RIDGE_LAMBDA\n    A = M.T.dot(M) + R\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # Huber IRLS iterations\n    for _ in range(_IRLS_ITERS):\n        # Residuals in log-space\n        r = M.dot(\u03b8) - ln_y\n        # Robust estimate of scale (MAD)\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + _EPS\n        delta = 1.345 * mad\n        # Huber weights\n        abs_r = np.abs(r)\n        w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n        # Form weighted normal equations: (M\u1d40 W M + R) \u03b8 = M\u1d40 W ln_y\n        W = w[:, None]  # shape (N,1)\n        A_w = M.T.dot(W * M) + R\n        b_w = M.T.dot(w * ln_y)\n        \u03b8 = np.linalg.solve(A_w, b_w)\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3137), Performs well on nmae (0.5469), Performs well on r2 (0.6863), Performs well on combined_score (0.7612)\n\n\n### Program 2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery using a log\u2013quadratic interaction model.\nModel: L(E, P) = exp(\u03b80\n                   + \u03b81\u00b7lnP\n                   + \u03b82\u00b7lnE\n                   + \u03b83\u00b7(lnP\u00b7lnE)\n                   + \u03b84\u00b7(lnP)^2\n                   + \u03b85\u00b7(lnE)^2)\nwhere\n  E = num_experts,\n  P = dense parameter count.\nThis 6-parameter form captures both multiplicative interactions and curvature in log-space.\nFitting is done via a single linear least-squares solve on log(loss), ensuring efficiency\nand numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n    data_points: shape (N,2)\n    params: array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns: array of length N\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split and stabilize inputs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute the log\u2010quadratic form\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Return to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law by minimizing\n    squared error in log-space:\n      minimize || M\u00b7\u03b8 \u2212 ln(y) ||^2\n    where M = [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2].\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive loss for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Prepare features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Build design matrix\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N, 6)\n    # Solve linear least squares in log-space\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a 6-parameter log\u2013quadratic interaction model.\nModel:\n    L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere\n    P = dense parameter count,\n    E = num_experts.\nFitting is performed by ordinary least squares on ln(loss), yielding a closed-form solution.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss from [num_experts, dense_parameter_count].\n    \n    Args:\n        data_points: array of shape (N,2) or (2,) with columns [E, P]\n        params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n        preds: array of shape (N,) of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure 2D\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack and validate parameter count\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log-quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by least squares on ln(loss).\n    \n    Args:\n        data_points: array of shape (N,2) with columns [E, P]\n        loss_values: array of shape (N,) of observed validation losses\n    Returns:\n        \u03b8_opt: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log of zero or negative\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n    # extract and stabilize features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix for [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares: M @ \u03b8 \u2248 ln_y\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nLog\u2013quadratic interaction model in log-space with 6 parameters:\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnE\n      + \u03b82\u00b7lnP\n      + \u03b83\u00b7(lnE \u00b7 lnP)\n      + \u03b84\u00b7(lnE)^2\n      + \u03b85\u00b7(lnP)^2\n    )\nwhere\n  E = num_experts,\n  P = dense parameter count.\nFitting is performed by linear least squares on ln(loss), ensuring numerical stability\nand efficient estimation of all six parameters.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Extract and stabilize features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute the quadratic form in log-space\n    u = (\n        \u03b80\n      + \u03b81 * lnE\n      + \u03b82 * lnP\n      + \u03b83 * (lnE * lnP)\n      + \u03b84 * (lnE ** 2)\n      + \u03b85 * (lnP ** 2)\n    )\n    # Return to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law by minimizing\n    squared error in log-space:\n      minimize || M\u00b7\u03b8 \u2212 ln(y) ||^2\n    where M = [1, lnE, lnP, lnE\u00b7lnP, (lnE)^2, (lnP)^2].\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive targets for log\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n    # Prepare features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Build design matrix M: columns [1, lnE, lnP, lnE*lnP, (lnE)^2, (lnP)^2]\n    M = np.vstack([\n        np.ones_like(lnE),\n        lnE,\n        lnP,\n        lnE * lnP,\n        lnE ** 2,\n        lnP ** 2\n    ]).T  # shape (N,6)\n    # Solve the linear least-squares problem in log-space\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5807)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5770, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEfficient, robust log\u2013quadratic interaction scaling law for Mixture\u2010of\u2010Experts (MoE) validation loss.\nModel form (in log\u2010space):\n    ln L = \u03b80 \n         + \u03b81\u00b7lnE \n         + \u03b82\u00b7lnP \n         + \u03b83\u00b7(lnE\u00b7lnP) \n         + \u03b84\u00b7(lnE)^2 \n         + \u03b85\u00b7(lnP)^2\nWe fit via iteratively reweighted least squares (Huber IRLS) with a small ridge regularization\non the interaction/quadratic terms for numerical stability and better generalization.\n\"\"\"\n\nimport numpy as np\n\n# Small constant to keep inputs strictly positive\n_EPS = 1e-8\n# Regularization strength for [lnE\u00b7lnP, (lnE)^2, (lnP)^2] terms\n_RIDGE_LAMBDA = 1e-6\n# Number of IRLS iterations\n_IRLS_ITERS = 3\n\ndef _build_design_matrix(num_experts, dense_params):\n    \"\"\"\n    Construct the design matrix M of shape (N,6) for inputs:\n      - constant term\n      - lnE\n      - lnP\n      - lnE * lnP\n      - (lnE)^2\n      - (lnP)^2\n    \"\"\"\n    E = np.maximum(num_experts, _EPS)\n    P = np.maximum(dense_params, _EPS)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    return np.column_stack([\n        np.ones_like(lnE),    # intercept\n        lnE,\n        lnP,\n        lnE * lnP,\n        lnE**2,\n        lnP**2,\n    ])\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: array\u2010like of shape (N,2) with [num_experts, dense_parameter_count]\n      params: array\u2010like of length 6 [\u03b80 \u2026 \u03b85]\n    Returns:\n      preds: (N,) array of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    M = _build_design_matrix(X[:, 0], X[:, 1])  # shape (N,6)\n    ln_preds = M.dot(\u03b8)\n    return np.exp(ln_preds)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model by minimizing\n    squared error in log-space with Huber IRLS and small ridge regularization.\n    Returns:\n      \u03b8_opt: array of optimized parameters [\u03b80 \u2026 \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must be a 1D array of same length as data_points\")\n\n    # Prepare log\u2010loss target, avoid zeros\n    y_safe = np.maximum(y, _EPS)\n    ln_y = np.log(y_safe)\n\n    # Build design matrix M (N\u00d76)\n    M = _build_design_matrix(X[:, 0], X[:, 1])\n\n    # Initial \u03b8 via ridge\u2010regularized least squares in log-space:\n    # Solve (M\u1d40M + \u03bb\u00b7R) \u03b8 = M\u1d40 ln_y\n    # where R penalizes only the interaction/quadratic terms (indices 3,4,5)\n    N_params = M.shape[1]\n    R = np.zeros((N_params, N_params), dtype=float)\n    # penalize columns [lnE\u00b7lnP, lnE^2, lnP^2]\n    for idx in (3, 4, 5):\n        R[idx, idx] = _RIDGE_LAMBDA\n    A = M.T.dot(M) + R\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # Huber IRLS iterations\n    for _ in range(_IRLS_ITERS):\n        # Residuals in log-space\n        r = M.dot(\u03b8) - ln_y\n        # Robust estimate of scale (MAD)\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + _EPS\n        delta = 1.345 * mad\n        # Huber weights\n        abs_r = np.abs(r)\n        w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n        # Form weighted normal equations: (M\u1d40 W M + R) \u03b8 = M\u1d40 W ln_y\n        W = w[:, None]  # shape (N,1)\n        A_w = M.T.dot(W * M) + R\n        b_w = M.T.dot(w * ln_y)\n        \u03b8 = np.linalg.solve(A_w, b_w)\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 2 (Score: 0.6308, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.256), Excellent nmae (1.080)\n\n\n### Inspiration 3 (Score: 0.5807, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 4 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a 6-parameter log\u2013quadratic interaction model.\nModel:\n    L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere\n    P = dense parameter count,\n    E = num_experts.\nFitting is performed by ordinary least squares on ln(loss), yielding a closed-form solution.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss from [num_experts, dense_parameter_count].\n    \n    Args:\n        data_points: array of shape (N,2) or (2,) with columns [E, P]\n        params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n        preds: array of shape (N,) of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure 2D\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack and validate parameter count\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log-quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by least squares on ln(loss).\n    \n    Args:\n        data_points: array of shape (N,2) with columns [E, P]\n        loss_values: array of shape (N,) of observed validation losses\n    Returns:\n        \u03b8_opt: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log of zero or negative\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n    # extract and stabilize features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix for [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares: M @ \u03b8 \u2248 ln_y\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.5807, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery using a log\u2013quadratic interaction model.\nModel: L(E, P) = exp(\u03b80\n                   + \u03b81\u00b7lnP\n                   + \u03b82\u00b7lnE\n                   + \u03b83\u00b7(lnP\u00b7lnE)\n                   + \u03b84\u00b7(lnP)^2\n                   + \u03b85\u00b7(lnE)^2)\nwhere\n  E = num_experts,\n  P = dense parameter count.\nThis 6-parameter form captures both multiplicative interactions and curvature in log-space.\nFitting is done via a single linear least-squares solve on log(loss), ensuring efficiency\nand numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n    data_points: shape (N,2)\n    params: array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns: array of length N\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split and stabilize inputs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute the log\u2010quadratic form\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Return to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law by minimizing\n    squared error in log-space:\n      minimize || M\u00b7\u03b8 \u2212 ln(y) ||^2\n    where M = [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2].\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive loss for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Prepare features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Build design matrix\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N, 6)\n    # Solve linear least squares in log-space\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nRobust log\u2013quadratic interaction scaling law for Mixture\u2010of\u2010Experts (MoE) validation loss.\nModel form (in log\u2010space):\n    ln L = \u03b80\n         + \u03b81\u00b7lnE\n         + \u03b82\u00b7lnP\n         + \u03b83\u00b7(lnE\u00b7lnP)\n         + \u03b84\u00b7(lnE)^2\n         + \u03b85\u00b7(lnP)^2\nWe fit via ridge\u2010regularized least squares followed by Huber IRLS for robustness\nand numerical stability across diverse MoE configurations.\n\"\"\"\nimport numpy as np\n\n# Small constant to ensure positivity\n_EPS = 1e-8\n# Ridge penalty on interaction/quadratic features\n_RIDGE_LAMBDA = 1e-6\n# Number of IRLS iterations\n_IRLS_ITERS = 3\n\ndef _build_design_matrix(E, P):\n    \"\"\"\n    Build design matrix M with columns:\n      [1, lnE, lnP, lnE*lnP, (lnE)^2, (lnP)^2]\n    E, P: arrays of shape (N,)\n    Returns: M of shape (N,6)\n    \"\"\"\n    E_safe = np.maximum(E, _EPS)\n    P_safe = np.maximum(P, _EPS)\n    lnE = np.log(E_safe)\n    lnP = np.log(P_safe)\n    return np.column_stack([\n        np.ones_like(lnE),\n        lnE,\n        lnP,\n        lnE * lnP,\n        lnE**2,\n        lnP**2,\n    ])\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given data_points and params.\n    data_points: array\u2010like of shape (N,2) with columns [num_experts, dense_parameter_count]\n    params: array\u2010like of length 6 [\u03b80,\u2026,\u03b85]\n    Returns: array of shape (N,) of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points of shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    E = X[:, 0]\n    P = X[:, 1]\n    M = _build_design_matrix(E, P)   # (N,6)\n    ln_pred = M.dot(\u03b8)\n    return np.exp(ln_pred)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law.\n    Uses ridge\u2010regularized least squares in log-space followed by Huber IRLS.\n    data_points: array\u2010like of shape (N,2)\n    loss_values: array\u2010like of shape (N,)\n    Returns: array of optimized parameters [\u03b80,\u2026,\u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points of shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must have same length as data_points\")\n\n    # Prepare log-target\n    y_safe = np.maximum(y, _EPS)\n    ln_y = np.log(y_safe)\n\n    # Build design matrix\n    E = X[:, 0]\n    P = X[:, 1]\n    M = _build_design_matrix(E, P)   # (N,6)\n\n    # Construct ridge matrix penalizing interaction/quadratics (cols 3,4,5)\n    R = np.zeros((6, 6), dtype=float)\n    for idx in (3, 4, 5):\n        R[idx, idx] = _RIDGE_LAMBDA\n\n    # Initial ridge\u2010regularized solve: (M\u1d40M + R) \u03b8 = M\u1d40 ln_y\n    A = M.T.dot(M) + R\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # Huber IRLS for robustness\n    for _ in range(_IRLS_ITERS):\n        r = M.dot(\u03b8) - ln_y\n        # Scale estimate via MAD\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + _EPS\n        delta = 1.345 * mad\n        abs_r = np.abs(r)\n        # Huber weights\n        w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n        # Weighted normal equations\n        W = w[:, None]\n        A_w = M.T.dot(W * M) + R\n        b_w = M.T.dot(w * ln_y)\n        \u03b8 = np.linalg.solve(A_w, b_w)\n\n    return \u03b8\n```"]}}}