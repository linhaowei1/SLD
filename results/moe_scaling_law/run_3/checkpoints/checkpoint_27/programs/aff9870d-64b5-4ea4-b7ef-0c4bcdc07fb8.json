{"id": "aff9870d-64b5-4ea4-b7ef-0c4bcdc07fb8", "code": "\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nImproved 6-parameter log-quadratic interaction model with robust IRLS fitting.\nModel form (in log-domain):\n    ln L = \u03b80\n         + \u03b81\u00b7lnN_e\n         + \u03b82\u00b7lnD\n         + \u03b83\u00b7(lnN_e\u00b7lnD)\n         + \u03b84\u00b7(lnN_e)^2\n         + \u03b85\u00b7(lnD)^2\nThen L = exp(ln L).\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    # ensure positivity before log\n    ne = np.maximum(X[:, 0], 1e-8)\n    D  = np.maximum(X[:, 1], 1e-8)\n    ln_ne = np.log(ne)\n    ln_D  = np.log(D)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = np.asarray(params, dtype=np.float64).ravel()\n    # log-quadratic interaction\n    u = (\n        \u03b80\n        + \u03b81 * ln_ne\n        + \u03b82 * ln_D\n        + \u03b83 * (ln_ne * ln_D)\n        + \u03b84 * (ln_ne ** 2)\n        + \u03b85 * (ln_D  ** 2)\n    )\n    # back to original scale\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law using\n    iteratively re-weighted least squares (Huber) in log-space.\n    Returns optimized params [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    # clip targets to positive for log\n    y_clipped = np.maximum(y, 1e-8)\n    ln_y = np.log(y_clipped)\n\n    # features for design matrix\n    ne = np.maximum(X[:, 0], 1e-8)\n    D  = np.maximum(X[:, 1], 1e-8)\n    ln_ne = np.log(ne)\n    ln_D  = np.log(D)\n\n    # build design matrix M: columns [1, ln_ne, ln_D, ln_ne*ln_D, (ln_ne)^2, (ln_D)^2]\n    M = np.vstack([\n        np.ones_like(ln_ne),\n        ln_ne,\n        ln_D,\n        ln_ne * ln_D,\n        ln_ne**2,\n        ln_D**2\n    ]).T  # shape (N, 6)\n\n    # initial ordinary least squares solution\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # Huber IRLS to reduce outlier influence\n    for _ in range(5):\n        # residual in log-domain\n        r = M.dot(\u03b8) - ln_y\n        # robust scale estimate via MAD\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + 1e-8\n        delta = 1.345 * mad\n        # Huber weights\n        w = np.ones_like(r)\n        # large residuals get downweighted\n        mask = np.abs(r) > delta\n        w[mask] = delta / np.abs(r[mask])\n        # weighted least squares: solve (M^T W M) \u03b8 = M^T W ln_y\n        W = w[:, None]  # shape (N,1)\n        A = M.T.dot(W * M)  # (6,6)\n        b = M.T.dot(w * ln_y)  # (6,)\n        \u03b8 = np.linalg.solve(A + 1e-12 * np.eye(6), b)  # small reg for stability\n\n    return \u03b8\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "e1ce4cc1-0694-4a6b-a7d8-cb0eb5bd6f82", "generation": 3, "timestamp": 1754718817.519716, "iteration_found": 28, "metrics": {"nmse": 0.31318299907022196, "nmae": 0.5464927201195608, "r2": 0.686817000929778, "combined_score": 0.7615084879320201}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.41790252302928127, "nmae": 0.617508748167058, "r2": 0.5820974769707188, "combined_score": 0.7052670996476877}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.4179\n- nmae: 0.6175\n- r2: 0.5821\n- combined_score: 0.7053\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 1.2561, nmae: 1.0801, r2: -0.2561, combined_score: 0.4432\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.4179, nmae: 0.6175, r2: 0.5821, combined_score: 0.7053\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3137, nmae: 0.5469, r2: 0.6863, combined_score: 0.7612\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5770)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\"\"\"\nRobust log\u2013quadratic interaction scaling law:\n  ln L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\nWe fit by iteratively re\u2010weighted least squares (Huber) on ln(loss)\nto reduce sensitivity to outliers while retaining a closed\u2010form solve.\n\"\"\"\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positive losses for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # initial ordinary least\u2010squares\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # robustify via Huber IRLS (a few iterations)\n    for _ in range(3):\n        # residuals in log\u2010space\n        r = M.dot(\u03b8) - ln_y\n        # robust scale estimate (MAD)\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + 1e-8\n        delta = 1.345 * mad\n        # Huber weights\n        w = np.ones_like(r)\n        mask = np.abs(r) > delta\n        w[mask] = delta / np.abs(r[mask])\n        # weighted least squares: solve (M^T W M) \u03b8 = M^T W ln_y\n        Wm = w[:, None] * M            # shape (N,6)\n        A = M.T.dot(Wm)                # (6,6)\n        b = M.T.dot(w * ln_y)          # (6,)\n        \u03b8 = np.linalg.lstsq(A, b, rcond=None)[0]\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3137), Performs well on nmae (0.5469), Performs well on r2 (0.6863), Performs well on combined_score (0.7612)\n\n\n### Program 2 (Score: 0.5807)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.4179), Performs well on nmae (0.6175), Performs well on r2 (0.5821), Performs well on combined_score (0.7053)\n\n\n### Program 3 (Score: 0.6308)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (1.2561), Performs well on nmae (1.0801), Performs well on r2 (-0.2561), Performs well on combined_score (0.4432)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5770, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\"\"\"\nRobust log\u2013quadratic interaction scaling law:\n  ln L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\nWe fit by iteratively re\u2010weighted least squares (Huber) on ln(loss)\nto reduce sensitivity to outliers while retaining a closed\u2010form solve.\n\"\"\"\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positive losses for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # initial ordinary least\u2010squares\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # robustify via Huber IRLS (a few iterations)\n    for _ in range(3):\n        # residuals in log\u2010space\n        r = M.dot(\u03b8) - ln_y\n        # robust scale estimate (MAD)\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + 1e-8\n        delta = 1.345 * mad\n        # Huber weights\n        w = np.ones_like(r)\n        mask = np.abs(r) > delta\n        w[mask] = delta / np.abs(r[mask])\n        # weighted least squares: solve (M^T W M) \u03b8 = M^T W ln_y\n        Wm = w[:, None] * M            # shape (N,6)\n        A = M.T.dot(Wm)                # (6,6)\n        b = M.T.dot(w * ln_y)          # (6,)\n        \u03b8 = np.linalg.lstsq(A, b, rcond=None)[0]\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Mixed iteration strategies\n\n\n### Inspiration 2 (Score: 0.6308, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.256), Excellent nmae (1.080)\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nImproved 6-parameter log-quadratic interaction model with robust IRLS fitting.\nModel form (in log-domain):\n    ln L = \u03b80\n         + \u03b81\u00b7lnN_e\n         + \u03b82\u00b7lnD\n         + \u03b83\u00b7(lnN_e\u00b7lnD)\n         + \u03b84\u00b7(lnN_e)^2\n         + \u03b85\u00b7(lnD)^2\nThen L = exp(ln L).\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    # ensure positivity before log\n    ne = np.maximum(X[:, 0], 1e-8)\n    D  = np.maximum(X[:, 1], 1e-8)\n    ln_ne = np.log(ne)\n    ln_D  = np.log(D)\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = np.asarray(params, dtype=np.float64).ravel()\n    # log-quadratic interaction\n    u = (\n        \u03b80\n        + \u03b81 * ln_ne\n        + \u03b82 * ln_D\n        + \u03b83 * (ln_ne * ln_D)\n        + \u03b84 * (ln_ne ** 2)\n        + \u03b85 * (ln_D  ** 2)\n    )\n    # back to original scale\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law using\n    iteratively re-weighted least squares (Huber) in log-space.\n    Returns optimized params [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    # clip targets to positive for log\n    y_clipped = np.maximum(y, 1e-8)\n    ln_y = np.log(y_clipped)\n\n    # features for design matrix\n    ne = np.maximum(X[:, 0], 1e-8)\n    D  = np.maximum(X[:, 1], 1e-8)\n    ln_ne = np.log(ne)\n    ln_D  = np.log(D)\n\n    # build design matrix M: columns [1, ln_ne, ln_D, ln_ne*ln_D, (ln_ne)^2, (ln_D)^2]\n    M = np.vstack([\n        np.ones_like(ln_ne),\n        ln_ne,\n        ln_D,\n        ln_ne * ln_D,\n        ln_ne**2,\n        ln_D**2\n    ]).T  # shape (N, 6)\n\n    # initial ordinary least squares solution\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # Huber IRLS to reduce outlier influence\n    for _ in range(5):\n        # residual in log-domain\n        r = M.dot(\u03b8) - ln_y\n        # robust scale estimate via MAD\n        mad = np.median(np.abs(r - np.median(r))) * 1.4826 + 1e-8\n        delta = 1.345 * mad\n        # Huber weights\n        w = np.ones_like(r)\n        # large residuals get downweighted\n        mask = np.abs(r) > delta\n        w[mask] = delta / np.abs(r[mask])\n        # weighted least squares: solve (M^T W M) \u03b8 = M^T W ln_y\n        W = w[:, None]  # shape (N,1)\n        A = M.T.dot(W * M)  # (6,6)\n        b = M.T.dot(w * ln_y)  # (6,)\n        \u03b8 = np.linalg.solve(A + 1e-12 * np.eye(6), b)  # small reg for stability\n\n    return \u03b8\n# EVOLVE-BLOCK-END\n```\n\nExplanation of improvements:\n- Adopted a 6-parameter log-quadratic form with interaction and squared terms to capture nonlinear coupling between expert count and dense size.\n- Fitted in log-space to linearize multiplicative behaviors, then exponentiated to return loss predictions.\n- Used Huber iteratively re-weighted least squares (IRLS) for robustness to outliers, with a small Tikhonov term for numerical stability.\n- Removed external dependencies beyond NumPy for simplicity and maintainability."]}}}