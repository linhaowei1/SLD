{"id": "a67abe7a-8be8-46b8-8af0-88209c0e7ddf", "code": "import numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Power\u2010law scaling model for MoE architectures:\n      L(Ne, D) = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Inputs:\n      data_points: array-like of shape (N,2), columns [num_experts, dense_parameter_count]\n      params:      array-like of 6 parameters [a, alpha, b, beta, p, c]\n\n    Returns:\n      (N,) array of predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Ensure strictly positive inputs for powers\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n\n    a, alpha, b, beta, p, c = params\n    # Combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.clip(cap, 1e-12, None)  # avoid zero or negative\n    # Inverted power law plus offset\n    return cap**(-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by robust nonlinear least squares\n    in log-loss space to reduce sensitivity to scale and outliers.\n\n    Inputs:\n      data_points: array-like of shape (N,2), [num_experts, dense_parameter_count]\n      loss_values: array-like of shape (N,), observed validation losses\n\n    Returns:\n      params_opt: (6,) array of fitted parameters [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Clip to avoid log(0)\n    y = np.clip(y, 1e-12, None)\n\n    # Initial guesses via medians\n    Ne = X[:, 0]\n    D  = X[:, 1]\n    Ne_med = np.median(np.clip(Ne, 1.0, None))\n    D_med  = np.median(np.clip(D,  1.0, None))\n    y_min  = np.min(y)\n\n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med,  1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Define residuals in log-space for relative-error fitting\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return np.log(pred) - np.log(y)\n\n    # Bounds: scales \u2265 0, exponents limited to [0,5]\n    lower_bounds = [0.0, 0.0,    0.0, 0.0,    0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0,  5.0, np.inf]\n\n    # Robust least-squares with soft_l1 loss in log-space\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "74ee544b-3b29-472b-b052-22d8d6151df9", "generation": 3, "timestamp": 1754718908.4099486, "iteration_found": 39, "metrics": {"nmse": 0.14389626705549405, "nmae": 0.3398481998821975, "r2": 0.8561037329445059, "combined_score": 0.8742051432461637}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.3131548460153104, "nmae": 0.5464630450700062, "r2": 0.6868451539846896, "combined_score": 0.7615248141027998}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3132\n- nmae: 0.5465\n- r2: 0.6868\n- combined_score: 0.7615\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3132, nmae: 0.5465, r2: 0.6868, combined_score: 0.7615\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.1444, nmae: 0.3401, r2: 0.8556, combined_score: 0.8738\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5535)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Combined power\u2010law scaling model:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where\n        Ne = number of experts,\n        D  = dense parameter count,\n        params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n\n    a, alpha, b, beta, p, c = params\n    # capacity combination\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)  # avoid zero or negative\n    # inverted power\u2010law plus offset\n    return cap ** (-p) + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by nonlinear least squares.\n    Returns optimized params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # split features\n    Ne = X[:, 0]\n    D  = X[:, 1]\n\n    # robust initial guesses using medians\n    Ne_pos = Ne[Ne > 0]\n    D_pos  = D[D > 0]\n    Ne_med = np.median(Ne_pos) if Ne_pos.size > 0 else 1.0\n    D_med  = np.median(D_pos)  if D_pos.size > 0 else 1.0\n    y_min  = np.min(y)\n\n    # initialize parameters\n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds to keep parameters in reasonable ranges\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # residual function for least squares\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # perform optimization\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1444), Performs well on nmae (0.3401), Performs well on r2 (0.8556), Performs well on combined_score (0.8738)\n\n\n### Program 2 (Score: 0.5770)\n```python\n\"\"\"\nRobust log\u2013quadratic scaling law for MoE architectures.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\n\nWe fit \u03b8 by an iteratively reweighted least\u2010squares (IRLS) Huber M\u2010estimator\nin log\u2010loss space. This reduces sensitivity to outliers while preserving\nthe expressive 6\u2010parameter form.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n\n    Arguments:\n      data_points: array\u2010like of shape (N,2) -- [num_experts, dense_parameter_count]\n      params: array\u2010like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n      preds: (N,) array of predicted validation losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2013quadratic model using a robust IRLS Huber fit.\n\n    Arguments:\n      data_points: array\u2010like of shape (N,2) -- [num_experts, dense_parameter_count]\n      loss_values: array\u2010like of shape (N,) -- validation losses\n\n    Returns:\n      \u03b8_opt: (6,) array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Log\u2010transform target\n    y_clip = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clip)\n\n    # Log features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # Initial ordinary least squares solution\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # IRLS Huber parameters\n    max_iter = 20\n    tol = 1e-6\n\n    for _ in range(max_iter):\n        # Residuals in log\u2010space\n        r = M.dot(\u03b8) - ln_y\n\n        # Robust scale estimate via MAD\n        med_r = np.median(r)\n        mad = np.median(np.abs(r - med_r))\n        if mad < 1e-12:\n            break\n        # Huber threshold \u03b4\n        s = mad * 1.4826\n        \u03b4 = 1.345 * s\n\n        # Compute Huber weights\n        abs_r = np.abs(r)\n        w = np.where(abs_r <= \u03b4, 1.0, \u03b4 / abs_r)\n\n        # Weighted least squares update\n        sqrt_w = np.sqrt(w)\n        M_w = M * sqrt_w[:, None]\n        y_w = ln_y * sqrt_w\n        \u03b8_new, *_ = np.linalg.lstsq(M_w, y_w, rcond=None)\n\n        # Check convergence\n        if np.linalg.norm(\u03b8_new - \u03b8) < tol * max(1.0, np.linalg.norm(\u03b8)):\n            \u03b8 = \u03b8_new\n            break\n        \u03b8 = \u03b8_new\n\n    return \u03b8\n```\nKey features: Performs well on nmse (0.3132), Performs well on nmae (0.5465), Performs well on r2 (0.6868), Performs well on combined_score (0.7615)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via a closed-form least squares on ln(loss), ensuring numerical stability\nand avoiding costly nonlinear optimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    \n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) predicted loss values\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # ensure positivity for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log\u2010quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # exponentiate to return loss\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by linear least squares\n    on the logarithm of the loss.\n    \n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    loss_values: (N,) array of observed validation losses\n    Returns: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log of zero or negatives\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n    # features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix columns: [1, lnP, lnE, lnP\u00b7lnE, lnP^2, lnE^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve M \u03b8 \u2248 ln_y in least\u2010squares sense\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5807)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5535, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Combined power\u2010law scaling model:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where\n        Ne = number of experts,\n        D  = dense parameter count,\n        params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n\n    a, alpha, b, beta, p, c = params\n    # capacity combination\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)  # avoid zero or negative\n    # inverted power\u2010law plus offset\n    return cap ** (-p) + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by nonlinear least squares.\n    Returns optimized params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # split features\n    Ne = X[:, 0]\n    D  = X[:, 1]\n\n    # robust initial guesses using medians\n    Ne_pos = Ne[Ne > 0]\n    D_pos  = D[D > 0]\n    Ne_med = np.median(Ne_pos) if Ne_pos.size > 0 else 1.0\n    D_med  = np.median(D_pos)  if D_pos.size > 0 else 1.0\n    y_min  = np.min(y)\n\n    # initialize parameters\n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # bounds to keep parameters in reasonable ranges\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n\n    # residual function for least squares\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # perform optimization\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 2 (Score: 2.0530, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nInitial program with a simple power law form that can be evolved\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    N, F = X.shape\n    params = np.asarray(params)\n\n    if params.ndim == 1:\n        params = params[None, :]                         # (1, P)\n    T, P = params.shape\n\n    coeffs    = params[:, :F]                            # (T, F)\n    exponents = params[:, F:2*F]                         # (T, F)\n    bias      = params[:, -1]                            # (T,)\n\n    pred = (coeffs[None, :, :] * (X[:, None, :] ** exponents[None, :, :])).sum(axis=2) + bias[None, :]\n\n    return pred[:, 0] if pred.shape[1] == 1 else pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    y = np.asarray(loss_values)\n    N, F = X.shape\n    P = 2 * F + 1\n\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    T = y2d.shape[1]\n\n    init = np.ones((T, P))\n\n    def objective(flat_params):\n        params = flat_params.reshape(T, P)\n        pred = scaling_law_func(X, params)               # (N, T)\n        mse = np.mean((pred - y2d) ** 2)\n        return mse\n\n    result = minimize(objective, init.ravel(), method='BFGS')\n    params_opt = result.x.reshape(T, P) if result.success else init\n\n    return params_opt[0] if T == 1 else params_opt\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Excellent nmse (40.106), Excellent nmae (7.188), Alternative r2 approach\n\n\n### Inspiration 3 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via a closed-form least squares on ln(loss), ensuring numerical stability\nand avoiding costly nonlinear optimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    \n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) predicted loss values\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # ensure positivity for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log\u2010quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # exponentiate to return loss\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by linear least squares\n    on the logarithm of the loss.\n    \n    data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    loss_values: (N,) array of observed validation losses\n    Returns: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log of zero or negatives\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n    # features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix columns: [1, lnP, lnE, lnP\u00b7lnE, lnP^2, lnE^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve M \u03b8 \u2248 ln_y in least\u2010squares sense\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 4 (Score: 0.5807, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nEnhanced 6-parameter power-law model with an interaction term.\nModel form:\n    L(N_e, D) = a * N_e^{-p1}\n               + b * D^{-p2}\n               + c * (N_e * D)^{-p3}\nParameters: [a, p1, b, p2, c, p3]\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params: array [a, p1, b, p2, c, p3]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    ne = X[:, 0]\n    D  = X[:, 1]\n    # avoid zero or negative values inside negative powers\n    ne_clip = np.maximum(ne, 1e-8)\n    D_clip  = np.maximum(D,  1e-8)\n    a, p1, b, p2, c, p3 = params\n    term1 = a * ne_clip ** (-p1)\n    term2 = b * D_clip  ** (-p2)\n    term3 = c * (ne_clip * D_clip) ** (-p3)\n    return term1 + term2 + term3\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c, p3].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Simple initialization based on range of y\n    y_min, y_max = np.min(y), np.max(y)\n    y_range = (y_max - y_min) if (y_max > y_min) else 1.0\n    init_a, init_b, init_c = y_range * 0.5, y_range * 0.3, y_range * 0.2\n    init_p1 = init_p2 = init_p3 = 0.5\n    init_params = np.array([init_a, init_p1, init_b, init_p2, init_c, init_p3])\n\n    # Bounds: all scales >= 0, exponents in [0,5]\n    lower_bounds = [0.0, 0.0,  0.0, 0.0,  0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf, 5.0]\n\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n\"\"\"\nRobust log\u2013quadratic scaling law for MoE architectures.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\n\nWe fit \u03b8 by an iteratively reweighted least\u2010squares (IRLS) Huber M\u2010estimator\nin log\u2010loss space. This reduces sensitivity to outliers while preserving\nthe expressive 6\u2010parameter form.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n\n    Arguments:\n      data_points: array\u2010like of shape (N,2) -- [num_experts, dense_parameter_count]\n      params: array\u2010like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n      preds: (N,) array of predicted validation losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2013quadratic model using a robust IRLS Huber fit.\n\n    Arguments:\n      data_points: array\u2010like of shape (N,2) -- [num_experts, dense_parameter_count]\n      loss_values: array\u2010like of shape (N,) -- validation losses\n\n    Returns:\n      \u03b8_opt: (6,) array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Log\u2010transform target\n    y_clip = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clip)\n\n    # Log features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # Initial ordinary least squares solution\n    \u03b8, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n\n    # IRLS Huber parameters\n    max_iter = 20\n    tol = 1e-6\n\n    for _ in range(max_iter):\n        # Residuals in log\u2010space\n        r = M.dot(\u03b8) - ln_y\n\n        # Robust scale estimate via MAD\n        med_r = np.median(r)\n        mad = np.median(np.abs(r - med_r))\n        if mad < 1e-12:\n            break\n        # Huber threshold \u03b4\n        s = mad * 1.4826\n        \u03b4 = 1.345 * s\n\n        # Compute Huber weights\n        abs_r = np.abs(r)\n        w = np.where(abs_r <= \u03b4, 1.0, \u03b4 / abs_r)\n\n        # Weighted least squares update\n        sqrt_w = np.sqrt(w)\n        M_w = M * sqrt_w[:, None]\n        y_w = ln_y * sqrt_w\n        \u03b8_new, *_ = np.linalg.lstsq(M_w, y_w, rcond=None)\n\n        # Check convergence\n        if np.linalg.norm(\u03b8_new - \u03b8) < tol * max(1.0, np.linalg.norm(\u03b8)):\n            \u03b8 = \u03b8_new\n            break\n        \u03b8 = \u03b8_new\n\n    return \u03b8\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Power\u2010law scaling model for MoE architectures:\n      L(Ne, D) = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Inputs:\n      data_points: array-like of shape (N,2), columns [num_experts, dense_parameter_count]\n      params:      array-like of 6 parameters [a, alpha, b, beta, p, c]\n\n    Returns:\n      (N,) array of predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Ensure strictly positive inputs for powers\n    Ne = np.clip(X[:, 0], 1.0, None)\n    D  = np.clip(X[:, 1], 1.0, None)\n\n    a, alpha, b, beta, p, c = params\n    # Combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.clip(cap, 1e-12, None)  # avoid zero or negative\n    # Inverted power law plus offset\n    return cap**(-p) + c\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter scaling law by robust nonlinear least squares\n    in log-loss space to reduce sensitivity to scale and outliers.\n\n    Inputs:\n      data_points: array-like of shape (N,2), [num_experts, dense_parameter_count]\n      loss_values: array-like of shape (N,), observed validation losses\n\n    Returns:\n      params_opt: (6,) array of fitted parameters [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # Clip to avoid log(0)\n    y = np.clip(y, 1e-12, None)\n\n    # Initial guesses via medians\n    Ne = X[:, 0]\n    D  = X[:, 1]\n    Ne_med = np.median(np.clip(Ne, 1.0, None))\n    D_med  = np.median(np.clip(D,  1.0, None))\n    y_min  = np.min(y)\n\n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med,  1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Define residuals in log-space for relative-error fitting\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return np.log(pred) - np.log(y)\n\n    # Bounds: scales \u2265 0, exponents limited to [0,5]\n    lower_bounds = [0.0, 0.0,    0.0, 0.0,    0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0,  5.0, np.inf]\n\n    # Robust least-squares with soft_l1 loss in log-space\n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        loss='soft_l1',\n        f_scale=0.1,\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=20000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```"]}}}