{"id": "9bbf2ad9-50e7-4c1f-bf39-13af408907bf", "code": "\"\"\"\nImproved power\u2010law scaling law for MoE architectures with robust Huber fitting.\n\nModel:\n    L(N_e, D) = (a\u00b7N_e^\u03b1 + b\u00b7D^\u03b2)^(-p) + c\n\nwhere\n  N_e = number of experts,\n  D   = dense parameter count,\n  {a, \u03b1, b, \u03b2, p, c} are learnable parameters (6 total).\n\nFitting procedure:\n  1) Derive robust initial guesses from medians.\n  2) Use scipy.optimize.least_squares with Huber loss for robustness.\n\nThis form has shown superior empirical performance across MoE configurations,\ncapturing the diminishing\u2010returns power\u2010law behavior of both expert count and\ndense parameter size.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [num_experts, dense_parameter_count]\n        params: array-like of length 6 [a, alpha, b, beta, p, c]\n\n    Returns:\n        preds: np.ndarray of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # ensure positivity\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    a, alpha, b, beta, p, c = params\n    # capacity mix term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)            # avoid numerical underflow\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter power-law scaling law by robust non-linear least squares.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [num_experts, dense_parameter_count]\n        loss_values: array-like of shape (N,) of observed validation losses\n\n    Returns:\n        params_opt: np.ndarray of length 6 [a, alpha, b, beta, p, c]\n    \"\"\"\n    # Prepare arrays\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # filter out invalid targets\n    mask = np.isfinite(y)\n    X = X[mask]\n    y = y[mask]\n    # clip to avoid zero or negative losses\n    y = np.clip(y, 1e-8, None)\n\n    # Feature medians for initialization\n    Ne = X[:, 0]\n    D  = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n\n    # Initial parameter guesses\n    # a, b scale inversely with median capacity; exponents start at 0.5; p small; c small offset\n    a0     = 1.0 / max(Ne_med ** 0.5, 1e-6)\n    b0     = 1.0 / max(D_med  ** 0.5, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Parameter bounds\n    lower_bounds = [0.0,   0.0,    0.0,   0.0,   0.0, 0.0]\n    upper_bounds = [np.inf, 5.0,    np.inf, 5.0,   5.0, np.inf]\n\n    # Residual function\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Estimate robust scale for Huber loss\n    init_res = residuals(init_params)\n    f_scale = np.maximum(1e-3, np.percentile(np.abs(init_res), 75))\n\n    # Perform robust non-linear least squares\n    result = least_squares(\n        fun=residuals,\n        x0=init_params,\n        loss='huber',\n        f_scale=f_scale,\n        bounds=(lower_bounds, upper_bounds),\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000,\n    )\n\n    return result.x", "language": "python", "parent_id": "199f854b-40c8-4630-8fc7-45ce3633a0ca", "generation": 4, "timestamp": 1754718983.0968332, "iteration_found": 47, "metrics": {"nmse": 0.14440588378334931, "nmae": 0.3401006042143677, "r2": 0.8555941162166507, "combined_score": 0.8738158499273435}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.3376962895870993, "nmae": 0.5734124163805868, "r2": 0.6623037104129007, "combined_score": 0.7475538414692512}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3377\n- nmae: 0.5734\n- r2: 0.6623\n- combined_score: 0.7476\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3377, nmae: 0.5734, r2: 0.6623, combined_score: 0.7476\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.2769, nmae: 0.5102, r2: 0.7231, combined_score: 0.7832\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.1444, nmae: 0.3401, r2: 0.8556, combined_score: 0.8738\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5535)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.1444), Performs well on nmae (0.3401), Performs well on r2 (0.8556), Performs well on combined_score (0.8738)\n\n\n### Program 2 (Score: 0.5733)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling law discovery using a 6-parameter log-quadratic model\nwith a two-stage fitting procedure:\n  1) closed-form least squares in log-space for an initial estimate\n  2) robust non-linear refinement on original losses (Huber) to\n     balance MSE and MAE improvements.\n\nModel:\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense parameter count,\n  {\u03b80\u2026\u03b85} are learnable parameters (6 total).\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n    data_points: shape (N,2)\n    params: array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns: array of length N\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Clip inputs to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # log-quadratic form\n    u = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP * lnE)\n      + \u03b84 * (lnP ** 2)\n      + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law via:\n      1) least squares on ln(loss) for a closed-form initial \u03b8\n      2) robust refinement on original losses using Huber loss.\n\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive for logs\n    y_pos = np.clip(y, 1e-8, None)\n\n    # Build log-space design matrix M for initial linear solve\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # 1) Closed-form least squares in log space\n    \u03b8_init, *_ = np.linalg.lstsq(M, np.log(y_pos), rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # 2) Robust non-linear refinement on original residuals\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # Estimate scale for Huber loss from initial residuals\n    init_res = residuals(\u03b8_init)\n    f_scale = np.maximum(1e-3, np.percentile(np.abs(init_res), 75))\n\n    # No explicit bounds (parameters can be positive or negative)\n    lower_bounds = -np.inf * np.ones(6)\n    upper_bounds =  np.inf * np.ones(6)\n\n    result = least_squares(\n        fun=residuals,\n        x0=\u03b8_init,\n        loss='huber',\n        f_scale=f_scale,\n        bounds=(lower_bounds, upper_bounds),\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000,\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.2769), Performs well on nmae (0.5102), Performs well on r2 (0.7231), Performs well on combined_score (0.7832)\n\n\n### Program 3 (Score: 0.5802)\n```python\n\"\"\"\nRobust log\u2013quadratic interaction scaling law with ridge regularization and Huber-style IRLS fitting.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense parameter count.\nThis implementation fits the 6 parameters by performing a small ridge regularization\nand a 2-step Huber-style IRLS in log-loss space to improve robustness to outliers\nand generalization across expert counts and model sizes.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [E, P]\n        params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n        preds: np.ndarray of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # Stabilize inputs and take logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=np.float64).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # Log-quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law by minimizing\n    squared error in log-space, with ridge regularization and a Huber-style IRLS.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [E, P]\n        loss_values: array-like of shape (N,) of observed validation losses\n\n    Returns:\n        \u03b8_opt: np.ndarray of shape (6,) optimized parameters [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    N = y.size\n\n    # Avoid log of zero or negative\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # Prepare features in log-space\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Build design matrix M of shape (N,6)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n\n    # Small ridge regularization to improve numerical conditioning\n    lam = 1e-6\n\n    # Initial ridge least\u2010squares solution: \u03b8 = (M^T M + lam I)^{-1} M^T ln_y\n    A = M.T.dot(M)\n    diag_indices = np.arange(A.shape[0])\n    A[diag_indices, diag_indices] += lam\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # One step of Huber-style IRLS to reduce outlier influence\n    # Compute residuals in log-space\n    r = M.dot(\u03b8) - ln_y\n    # Estimate robust scale via median absolute deviation\n    mad = np.median(np.abs(r - np.median(r))) or 1.0\n    delta = 1.345 * mad  # Huber threshold\n    # Compute weights: w_i = 1 if |r_i| <= delta else delta/|r_i|\n    abs_r = np.abs(r)\n    w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n\n    # Solve weighted ridge least-squares: (M^T W M + lam I) \u03b8 = M^T W ln_y\n    W = w  # weights vector of length N\n    # Efficiently form M^T W M and M^T W ln_y\n    MW = M * W[:, None]\n    A_w = MW.T.dot(M)\n    A_w[diag_indices, diag_indices] += lam\n    b_w = MW.T.dot(ln_y)\n    \u03b8_opt = np.linalg.solve(A_w, b_w)\n\n    return \u03b8_opt\n```\nKey features: Performs well on nmse (0.3377), Performs well on nmae (0.5734), Performs well on r2 (0.6623), Performs well on combined_score (0.7476)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given MoE expert count and dense parameter count\n    using a 6-parameter log\u2013quadratic interaction model:\n      L = exp(b0\n              + b1\u00b7lnNe\n              + b2\u00b7lnD\n              + b3\u00b7(lnNe\u00b7lnD)\n              + b4\u00b7(lnNe)^2\n              + b5\u00b7(lnD)^2)\n    where Ne = num_experts, D = dense_parameter_count.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and stabilize inputs\n    ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    # log\u2010transform\n    lnNe = np.log(ne)\n    lnD  = np.log(D)\n    # unpack parameters\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {p.size}\")\n    b0, b1, b2, b3, b4, b5 = p\n    # log\u2010quadratic form with interaction\n    u = (\n        b0\n        + b1 * lnNe\n        + b2 * lnD\n        + b3 * (lnNe * lnD)\n        + b4 * (lnNe**2)\n        + b5 * (lnD**2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by solving a linear least\u2010squares\n    problem on the logarithm of the loss.\n    Returns optimized parameters [b0, b1, b2, b3, b4, b5].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log(0) or negatives\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n    # features and log\u2010transform\n    ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    lnNe = np.log(ne)\n    lnD  = np.log(D)\n    # build design matrix: [1, lnNe, lnD, lnNe\u00b7lnD, (lnNe)^2, (lnD)^2]\n    M = np.vstack([\n        np.ones_like(lnNe),\n        lnNe,\n        lnD,\n        lnNe * lnD,\n        lnNe**2,\n        lnD**2\n    ]).T\n    # solve for parameters in least\u2010squares sense\n    theta, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via a closed-form linear least squares on ln(loss),\nwhich is fast, numerically stable, and requires no iterative optimizer.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # ensure positivity for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # compute logs\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log\u2010quadratic model with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # exponentiate to return to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model to minimize squared error\n    in log-loss space.\n    Returns: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positivity for target log\n    y_clip = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clip)\n    # extract features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix with 6 columns\n    # [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares: minimize ||M \u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5535, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n    where:\n        Ne = num_experts\n        D  = dense_parameter_count\n    params = [a, alpha, b, beta, p, c]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Ne = np.maximum(X[:, 0], 1.0)    # ensure positivity\n    D  = np.maximum(X[:, 1], 1.0)\n    \n    a, alpha, b, beta, p, c = params\n    # combined capacity term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)\n    # inverted power-law plus offset\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by non-linear least squares.\n    Returns params = [a, alpha, b, beta, p, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    \n    # derive robust initial guesses\n    Ne = X[:, 0]; D = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n    \n    a0     = 1.0 / max(Ne_med, 1e-6)\n    b0     = 1.0 / max(D_med, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    \n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n    \n    # bounds to keep exponents and scales in a reasonable range\n    lower_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, 5.0, np.inf]\n    \n    def residuals(params):\n        return scaling_law_func(X, params) - y\n    \n    result = least_squares(\n        residuals,\n        x0=init_params,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n    \n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 2 (Score: 0.6308, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.256), Excellent nmae (1.080)\n\n\n### Inspiration 3 (Score: 0.5733, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling law discovery using a 6-parameter log-quadratic model\nwith a two-stage fitting procedure:\n  1) closed-form least squares in log-space for an initial estimate\n  2) robust non-linear refinement on original losses (Huber) to\n     balance MSE and MAE improvements.\n\nModel:\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense parameter count,\n  {\u03b80\u2026\u03b85} are learnable parameters (6 total).\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n    data_points: shape (N,2)\n    params: array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns: array of length N\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Clip inputs to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # log-quadratic form\n    u = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP * lnE)\n      + \u03b84 * (lnP ** 2)\n      + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law via:\n      1) least squares on ln(loss) for a closed-form initial \u03b8\n      2) robust refinement on original losses using Huber loss.\n\n    Returns optimized \u03b8 of length 6.\n    \"\"\"\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive for logs\n    y_pos = np.clip(y, 1e-8, None)\n\n    # Build log-space design matrix M for initial linear solve\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # 1) Closed-form least squares in log space\n    \u03b8_init, *_ = np.linalg.lstsq(M, np.log(y_pos), rcond=None)\n    \u03b8_init = \u03b8_init.ravel()\n\n    # 2) Robust non-linear refinement on original residuals\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # Estimate scale for Huber loss from initial residuals\n    init_res = residuals(\u03b8_init)\n    f_scale = np.maximum(1e-3, np.percentile(np.abs(init_res), 75))\n\n    # No explicit bounds (parameters can be positive or negative)\n    lower_bounds = -np.inf * np.ones(6)\n    upper_bounds =  np.inf * np.ones(6)\n\n    result = least_squares(\n        fun=residuals,\n        x0=\u03b8_init,\n        loss='huber',\n        f_scale=f_scale,\n        bounds=(lower_bounds, upper_bounds),\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=5000,\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, NumPy-based implementation\n\n\n### Inspiration 4 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via a closed-form linear least squares on ln(loss),\nwhich is fast, numerically stable, and requires no iterative optimizer.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # ensure positivity for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # compute logs\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log\u2010quadratic model with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # exponentiate to return to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model to minimize squared error\n    in log-loss space.\n    Returns: array of fitted parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positivity for target log\n    y_clip = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clip)\n    # extract features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix with 6 columns\n    # [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares: minimize ||M \u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.5812, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given MoE expert count and dense parameter count\n    using a 6-parameter log\u2013quadratic interaction model:\n      L = exp(b0\n              + b1\u00b7lnNe\n              + b2\u00b7lnD\n              + b3\u00b7(lnNe\u00b7lnD)\n              + b4\u00b7(lnNe)^2\n              + b5\u00b7(lnD)^2)\n    where Ne = num_experts, D = dense_parameter_count.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and stabilize inputs\n    ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    # log\u2010transform\n    lnNe = np.log(ne)\n    lnD  = np.log(D)\n    # unpack parameters\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {p.size}\")\n    b0, b1, b2, b3, b4, b5 = p\n    # log\u2010quadratic form with interaction\n    u = (\n        b0\n        + b1 * lnNe\n        + b2 * lnD\n        + b3 * (lnNe * lnD)\n        + b4 * (lnNe**2)\n        + b5 * (lnD**2)\n    )\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic scaling law by solving a linear least\u2010squares\n    problem on the logarithm of the loss.\n    Returns optimized parameters [b0, b1, b2, b3, b4, b5].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # avoid log(0) or negatives\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n    # features and log\u2010transform\n    ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n    lnNe = np.log(ne)\n    lnD  = np.log(D)\n    # build design matrix: [1, lnNe, lnD, lnNe\u00b7lnD, (lnNe)^2, (lnD)^2]\n    M = np.vstack([\n        np.ones_like(lnNe),\n        lnNe,\n        lnD,\n        lnNe * lnD,\n        lnNe**2,\n        lnD**2\n    ]).T\n    # solve for parameters in least\u2010squares sense\n    theta, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n\"\"\"\nRobust log\u2013quadratic interaction scaling law with ridge regularization and Huber-style IRLS fitting.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\nwhere\n    E = num_experts,\n    P = dense parameter count.\nThis implementation fits the 6 parameters by performing a small ridge regularization\nand a 2-step Huber-style IRLS in log-loss space to improve robustness to outliers\nand generalization across expert counts and model sizes.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_param_count] pairs and 6 parameters.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [E, P]\n        params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n        preds: np.ndarray of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # Stabilize inputs and take logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=np.float64).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # Log-quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction scaling law by minimizing\n    squared error in log-space, with ridge regularization and a Huber-style IRLS.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [E, P]\n        loss_values: array-like of shape (N,) of observed validation losses\n\n    Returns:\n        \u03b8_opt: np.ndarray of shape (6,) optimized parameters [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=np.float64).ravel()\n    N = y.size\n\n    # Avoid log of zero or negative\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # Prepare features in log-space\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Build design matrix M of shape (N,6)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n\n    # Small ridge regularization to improve numerical conditioning\n    lam = 1e-6\n\n    # Initial ridge least\u2010squares solution: \u03b8 = (M^T M + lam I)^{-1} M^T ln_y\n    A = M.T.dot(M)\n    diag_indices = np.arange(A.shape[0])\n    A[diag_indices, diag_indices] += lam\n    b = M.T.dot(ln_y)\n    \u03b8 = np.linalg.solve(A, b)\n\n    # One step of Huber-style IRLS to reduce outlier influence\n    # Compute residuals in log-space\n    r = M.dot(\u03b8) - ln_y\n    # Estimate robust scale via median absolute deviation\n    mad = np.median(np.abs(r - np.median(r))) or 1.0\n    delta = 1.345 * mad  # Huber threshold\n    # Compute weights: w_i = 1 if |r_i| <= delta else delta/|r_i|\n    abs_r = np.abs(r)\n    w = np.where(abs_r <= delta, 1.0, delta / abs_r)\n\n    # Solve weighted ridge least-squares: (M^T W M + lam I) \u03b8 = M^T W ln_y\n    W = w  # weights vector of length N\n    # Efficiently form M^T W M and M^T W ln_y\n    MW = M * W[:, None]\n    A_w = MW.T.dot(M)\n    A_w[diag_indices, diag_indices] += lam\n    b_w = MW.T.dot(ln_y)\n    \u03b8_opt = np.linalg.solve(A_w, b_w)\n\n    return \u03b8_opt\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nImproved power\u2010law scaling law for MoE architectures with robust Huber fitting.\n\nModel:\n    L(N_e, D) = (a\u00b7N_e^\u03b1 + b\u00b7D^\u03b2)^(-p) + c\n\nwhere\n  N_e = number of experts,\n  D   = dense parameter count,\n  {a, \u03b1, b, \u03b2, p, c} are learnable parameters (6 total).\n\nFitting procedure:\n  1) Derive robust initial guesses from medians.\n  2) Use scipy.optimize.least_squares with Huber loss for robustness.\n\nThis form has shown superior empirical performance across MoE configurations,\ncapturing the diminishing\u2010returns power\u2010law behavior of both expert count and\ndense parameter size.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss using a combined power-law:\n        L = (a * Ne^alpha + b * D^beta)^(-p) + c\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [num_experts, dense_parameter_count]\n        params: array-like of length 6 [a, alpha, b, beta, p, c]\n\n    Returns:\n        preds: np.ndarray of shape (N,) of predicted validation losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # ensure positivity\n    Ne = np.clip(X[:, 0], 1e-8, None)\n    D  = np.clip(X[:, 1], 1e-8, None)\n\n    a, alpha, b, beta, p, c = params\n    # capacity mix term\n    cap = a * (Ne ** alpha) + b * (D ** beta)\n    cap = np.maximum(cap, 1e-12)            # avoid numerical underflow\n    loss_pred = cap ** (-p) + c\n    return loss_pred\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter power-law scaling law by robust non-linear least squares.\n\n    Args:\n        data_points: array-like of shape (N,2) with columns [num_experts, dense_parameter_count]\n        loss_values: array-like of shape (N,) of observed validation losses\n\n    Returns:\n        params_opt: np.ndarray of length 6 [a, alpha, b, beta, p, c]\n    \"\"\"\n    # Prepare arrays\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # filter out invalid targets\n    mask = np.isfinite(y)\n    X = X[mask]\n    y = y[mask]\n    # clip to avoid zero or negative losses\n    y = np.clip(y, 1e-8, None)\n\n    # Feature medians for initialization\n    Ne = X[:, 0]\n    D  = X[:, 1]\n    Ne_med = np.median(Ne[Ne > 0])\n    D_med  = np.median(D[D   > 0])\n    y_min  = np.min(y)\n\n    # Initial parameter guesses\n    # a, b scale inversely with median capacity; exponents start at 0.5; p small; c small offset\n    a0     = 1.0 / max(Ne_med ** 0.5, 1e-6)\n    b0     = 1.0 / max(D_med  ** 0.5, 1e-6)\n    alpha0 = 0.5\n    beta0  = 0.5\n    p0     = 0.5\n    c0     = max(0.0, y_min * 0.1)\n    init_params = np.array([a0, alpha0, b0, beta0, p0, c0], dtype=float)\n\n    # Parameter bounds\n    lower_bounds = [0.0,   0.0,    0.0,   0.0,   0.0, 0.0]\n    upper_bounds = [np.inf, 5.0,    np.inf, 5.0,   5.0, np.inf]\n\n    # Residual function\n    def residuals(params):\n        return scaling_law_func(X, params) - y\n\n    # Estimate robust scale for Huber loss\n    init_res = residuals(init_params)\n    f_scale = np.maximum(1e-3, np.percentile(np.abs(init_res), 75))\n\n    # Perform robust non-linear least squares\n    result = least_squares(\n        fun=residuals,\n        x0=init_params,\n        loss='huber',\n        f_scale=f_scale,\n        bounds=(lower_bounds, upper_bounds),\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000,\n    )\n\n    return result.x\n```"]}}}