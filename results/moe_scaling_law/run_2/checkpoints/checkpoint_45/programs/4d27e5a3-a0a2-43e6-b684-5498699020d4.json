{"id": "4d27e5a3-a0a2-43e6-b684-5498699020d4", "code": "import numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given MoE configuration:\n      data_points: array-like of shape (N,2) or (2,), columns = [num_experts, dense_param_count]\n      params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Model:\n      ln\u2009L = \u03b80 \n           + \u03b81\u00b7ln(P) \n           + \u03b82\u00b7ln(E) \n           + \u03b83\u00b7(1/P) \n           + \u03b84\u00b7(1/E) \n           + \u03b85\u00b7(1/(P\u00b7E))\n      L = exp(ln\u2009L)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # handle single data point\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected 2 features, got shape {X.shape}\")\n        X = X.reshape(1, 2)\n    elif X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    # split features and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    # compute transformed features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = theta\n    # linear model in transformed space\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * invP\n        + \u03b84 * invE\n        + \u03b85 * invPE\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by ridge-regularized least squares\n    on ln(loss):\n\n      ln\u2009L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns:\n      theta_opt: ndarray of length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected shape (2,) for a single sample, got {X.shape}\")\n        X = X.reshape(1, 2)\n    elif X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Number of samples in data_points and loss_values must match\")\n\n    # enforce positivity for logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    y_clip = np.clip(y, 1e-8, None)\n    lnY = np.log(y_clip)\n\n    # design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P\u00b7E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        1.0 / P,\n        1.0 / E,\n        (1.0 / P) * (1.0 / E)\n    ]).T  # shape (N,6)\n\n    # ridge regularization weight proportional to trace\n    MtM = M.T @ M\n    ridge_weight = 1e-6 * np.trace(MtM) / MtM.shape[0]\n    A = MtM + ridge_weight * np.eye(6)\n    b = M.T @ lnY\n\n    theta_opt = np.linalg.solve(A, b)\n    return theta_opt", "language": "python", "parent_id": "ecc35547-6682-4bef-b93f-1f08d8d3b18a", "generation": 2, "timestamp": 1754718595.9526348, "iteration_found": 44, "metrics": {"nmse": 0.4659881968004486, "nmae": 0.6220278803595075, "r2": 0.5340118031995513, "combined_score": 0.6821337321695509}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 1.256098519662987, "nmae": 1.0801085520333324, "r2": -0.256098519662987, "combined_score": 0.44324305489521737}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 1.2561\n- nmae: 1.0801\n- r2: -0.2561\n- combined_score: 0.4432\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3659, nmae: 0.5920, r2: 0.6341, combined_score: 0.7321\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3482, nmae: 0.5695, r2: 0.6518, combined_score: 0.7417\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5778)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Parametric scaling law:\n      ln L = \u03b80 \n           + \u03b81 * ln(P) \n           + \u03b82 * ln(E) \n           + \u03b83 * (1 / P) \n           + \u03b84 * (1 / E) \n           + \u03b85 * (1 / (P * E))\n    => L = exp( ln L ).\n\n    Inputs:\n      data_points : (N,2) array of [E, P]\n      params       : array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      preds        : (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = X[:, 0]\n    P = X[:, 1]\n\n    # numerical safeguards\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * invP\n         + \u03b84 * invE\n         + \u03b85 * invPE)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by linear least squares on ln(loss):\n      ln y \u2248 \u03b80\u00b71 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns the optimal \u03b8 of shape (6,).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # to keep ln well\u2010defined\n    y = np.clip(y, 1e-8, None)\n    lnY = np.log(y)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    # build design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P*E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        invP,\n        invE,\n        invPE\n    ]).T\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3482), Performs well on nmae (0.5695), Performs well on r2 (0.6518), Performs well on combined_score (0.7417)\n\n\n### Program 2 (Score: 0.5810)\n```python\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given MoE configuration:\n      data_points: array-like of shape (N,2), columns=[num_experts, dense_param_count]\n      params: array-like of length 6\n    Model (log\u2010quadratic interaction with regularization in fit):\n      ln\u2009L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\n      L = exp(ln\u2009L)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    # Split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # Clip to avoid log(0)\n    eps = 1e-8\n    lnE = np.log(np.clip(E, eps, None))\n    lnP = np.log(np.clip(P, eps, None))\n    # Build design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    F = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    # Compute log\u2010loss and exponentiate\n    lnL = F.dot(\u03b8)\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2010quadratic interaction scaling law by solving\n    a small ridge\u2010regularized linear system in log-space.\n      data_points: array-like of shape (N,2), columns=[num_experts, dense_param_count]\n      loss_values: array-like of shape (N,)\n    Returns:\n      \u03b8 array of length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same number of rows\")\n\n    # Split and clip features and targets\n    eps = 1e-8\n    E = np.clip(X[:, 0], eps, None)\n    P = np.clip(X[:, 1], eps, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    y_clipped = np.clip(y, eps, None)\n    ln_y = np.log(y_clipped)\n\n    # Build design matrix\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # Ridge regularization for numerical stability\n    alpha = 1e-6\n    A = M.T.dot(M) + alpha * np.eye(6)\n    b = M.T.dot(ln_y)\n\n    # Solve for \u03b8\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n```\nKey features: Performs well on nmse (0.3659), Performs well on nmae (0.5920), Performs well on r2 (0.6341), Performs well on combined_score (0.7321)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law model: Log-quadratic with interaction terms.\n\nWe model the validation loss L given:\n  E = num_experts\n  P = dense_parameter_count\n\nas:\n\n  L(E,P) \u2248 exp(\n      \u03b80\n    + \u03b81 \u00b7 ln(P)\n    + \u03b82 \u00b7 ln(E)\n    + \u03b83 \u00b7 (ln(P) \u00b7 ln(E))\n    + \u03b84 \u00b7 (ln(P))^2\n    + \u03b85 \u00b7 (ln(E))^2\n  )\n\nThis form captures both individual effects of P and E in log-space\nand their interaction and curvature. We fit \u03b80\u2026\u03b85 by performing\nordinary least squares on ln(loss), which is efficient,\nnumerically stable, and uses at most 6 parameters.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss for given MoE configurations.\n\n    Args:\n      data_points: array\u2010like of shape (N,2) or (2,)\n                   each row = [num_experts, dense_parameter_count]\n      params:      array\u2010like of length 6 = [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n      preds: ndarray of shape (N,) with predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # If single sample given as shape (2,), reshape to (1,2)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected 2 elements for a single data_point, got {X.size}\")\n        X = X.reshape(1, 2)\n    # Split features and enforce positivity for log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = theta\n\n    # Log-quadratic with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Back to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by linear least squares\n    on the log of the validation loss.\n\n    Args:\n      data_points: array\u2010like of shape (N,2)\n      loss_values: array\u2010like of shape (N,)\n\n    Returns:\n      theta_opt: ndarray of length 6 with optimized [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected shape (2,) for a single sample, got {X.shape}\")\n        X = X.reshape(1, 2)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(f\"Number of data points {X.shape[0]} \"\n                         f\"does not match number of targets {y.shape[0]}\")\n\n    # Clamp to avoid log(0), then take log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # Build features in log-space\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # Solve M \u00b7 \u03b8 \u2248 ln_y in least-squares sense\n    theta_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.6308)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5852)\n```python\n\"\"\"\nImproved scaling law discovery using a parsimonious log\u2013quadratic interaction model.\nWe drop the (ln E)^2 term to reduce parameter count and overfitting,\nkeeping 5 parameters total:\n\n    L = exp( \u03b80\n           + \u03b81\u00b7lnP\n           + \u03b82\u00b7lnE\n           + \u03b83\u00b7(lnP\u00b7lnE)\n           + \u03b84\u00b7(lnP)^2 )\n\nwhere\n  P = dense parameter count,\n  E = num_experts.\n\nWe fit \u03b8 by ordinary least squares on ln L, which is fast,\nnumerically stable, and generalizes better with fewer parameters.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given num_experts E and dense parameter count P.\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    params: array-like of length 5: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84]\n\n    Returns: numpy array of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 5:\n        raise ValueError(f\"Expected 5 parameters (\u03b80\u2026\u03b84), got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84 = \u03b8\n    # log\u2010quadratic model with one curvature term and interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter log-quadratic model to observed validation losses.\n    Minimizes squared error on ln(loss):\n        \u03b8_opt = argmin || M\u00b7\u03b8 \u2013 ln(y) ||^2\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    loss_values: array-like of shape (N,): observed validation losses\n\n    Returns: numpy array of shape (5,) with optimized [\u03b80\u2026\u03b84].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # ensure positivity for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # build design matrix M with columns:\n    # [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2\n    ]).T  # shape (N,5)\n\n    # solve least squares: minimize ||M \u03b8 \u2013 ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5778, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Parametric scaling law:\n      ln L = \u03b80 \n           + \u03b81 * ln(P) \n           + \u03b82 * ln(E) \n           + \u03b83 * (1 / P) \n           + \u03b84 * (1 / E) \n           + \u03b85 * (1 / (P * E))\n    => L = exp( ln L ).\n\n    Inputs:\n      data_points : (N,2) array of [E, P]\n      params       : array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      preds        : (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = X[:, 0]\n    P = X[:, 1]\n\n    # numerical safeguards\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * invP\n         + \u03b84 * invE\n         + \u03b85 * invPE)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by linear least squares on ln(loss):\n      ln y \u2248 \u03b80\u00b71 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns the optimal \u03b8 of shape (6,).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # to keep ln well\u2010defined\n    y = np.clip(y, 1e-8, None)\n    lnY = np.log(y)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    # build design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P*E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        invP,\n        invE,\n        invPE\n    ]).T\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 2 (Score: 0.7099, Type: Alternative)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced 6-parameter log-quadratic scaling law with Tikhonov (ridge) regularization\nfor improved numerical stability and generalization.\n\nModel: \n    L(E, P) = exp(\u03b80 \n                   + \u03b81\u00b7lnP \n                   + \u03b82\u00b7lnE \n                   + \u03b83\u00b7(lnP\u00b7lnE) \n                   + \u03b84\u00b7(lnP)^2 \n                   + \u03b85\u00b7(lnE)^2)\n\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\n\nWe fit by solving a small Tikhonov\u2010regularized least\u2010squares problem in log\u2010space:\n    minimize ||M\u00b7\u03b8 \u2212 ln(loss)||^2 + \u03bb\u00b7||\u03b8||^2\nwith \u03bb set automatically as a small fraction of tr(M\u1d40M).\n\"\"\"\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    Args:\n      data_points: array_like of shape (N,2) with columns [num_experts, dense_parameter_count]\n      params: array_like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      losses: ndarray of shape (N,) predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,2)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    elif X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # split and clip positives\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # compute logs\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic form with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by ridge\u2010regularized least squares\n    on log(loss), returning the fitted parameters [\u03b80...\u03b85].\n    Args:\n      data_points: array_like of shape (N,2) with columns [num_experts, dense_parameter_count]\n      loss_values: array_like of shape (N,) observed validation losses\n    Returns:\n      theta_opt: ndarray of length 6, the optimized parameters\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    elif X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same length\")\n    # split and clip for stability\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    ln_y = np.log(np.clip(y, 1e-8, None))\n    # build design matrix [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # automatic ridge weight: small fraction of trace(M^T M)\n    MtM = M.T @ M\n    \u03bb = 1e-6 * np.trace(MtM) / MtM.shape[0]\n    # solve (M^T M + \u03bb I) \u03b8 = M^T ln_y\n    A = MtM + \u03bb * np.eye(MtM.shape[0])\n    b = M.T @ ln_y\n    theta_opt = np.linalg.solve(A, b)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (2.066), Excellent nmae (1.513)\n\n\n### Inspiration 3 (Score: 0.5810, Type: Experimental)\n```python\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given MoE configuration:\n      data_points: array-like of shape (N,2), columns=[num_experts, dense_param_count]\n      params: array-like of length 6\n    Model (log\u2010quadratic interaction with regularization in fit):\n      ln\u2009L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2\n      L = exp(ln\u2009L)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    # Split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # Clip to avoid log(0)\n    eps = 1e-8\n    lnE = np.log(np.clip(E, eps, None))\n    lnP = np.log(np.clip(P, eps, None))\n    # Build design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    F = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    # Compute log\u2010loss and exponentiate\n    lnL = F.dot(\u03b8)\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2010quadratic interaction scaling law by solving\n    a small ridge\u2010regularized linear system in log-space.\n      data_points: array-like of shape (N,2), columns=[num_experts, dense_param_count]\n      loss_values: array-like of shape (N,)\n    Returns:\n      \u03b8 array of length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same number of rows\")\n\n    # Split and clip features and targets\n    eps = 1e-8\n    E = np.clip(X[:, 0], eps, None)\n    P = np.clip(X[:, 1], eps, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    y_clipped = np.clip(y, eps, None)\n    ln_y = np.log(y_clipped)\n\n    # Build design matrix\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # Ridge regularization for numerical stability\n    alpha = 1e-6\n    A = M.T.dot(M) + alpha * np.eye(6)\n    b = M.T.dot(ln_y)\n\n    # Solve for \u03b8\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 4 (Score: 0.5852, Type: Experimental)\n```python\n\"\"\"\nImproved scaling law discovery using a parsimonious log\u2013quadratic interaction model.\nWe drop the (ln E)^2 term to reduce parameter count and overfitting,\nkeeping 5 parameters total:\n\n    L = exp( \u03b80\n           + \u03b81\u00b7lnP\n           + \u03b82\u00b7lnE\n           + \u03b83\u00b7(lnP\u00b7lnE)\n           + \u03b84\u00b7(lnP)^2 )\n\nwhere\n  P = dense parameter count,\n  E = num_experts.\n\nWe fit \u03b8 by ordinary least squares on ln L, which is fast,\nnumerically stable, and generalizes better with fewer parameters.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given num_experts E and dense parameter count P.\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    params: array-like of length 5: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84]\n\n    Returns: numpy array of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 5:\n        raise ValueError(f\"Expected 5 parameters (\u03b80\u2026\u03b84), got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84 = \u03b8\n    # log\u2010quadratic model with one curvature term and interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter log-quadratic model to observed validation losses.\n    Minimizes squared error on ln(loss):\n        \u03b8_opt = argmin || M\u00b7\u03b8 \u2013 ln(y) ||^2\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    loss_values: array-like of shape (N,): observed validation losses\n\n    Returns: numpy array of shape (5,) with optimized [\u03b80\u2026\u03b84].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # ensure positivity for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # build design matrix M with columns:\n    # [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2\n    ]).T  # shape (N,5)\n\n    # solve least squares: minimize ||M \u03b8 \u2013 ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law model: Log-quadratic with interaction terms.\n\nWe model the validation loss L given:\n  E = num_experts\n  P = dense_parameter_count\n\nas:\n\n  L(E,P) \u2248 exp(\n      \u03b80\n    + \u03b81 \u00b7 ln(P)\n    + \u03b82 \u00b7 ln(E)\n    + \u03b83 \u00b7 (ln(P) \u00b7 ln(E))\n    + \u03b84 \u00b7 (ln(P))^2\n    + \u03b85 \u00b7 (ln(E))^2\n  )\n\nThis form captures both individual effects of P and E in log-space\nand their interaction and curvature. We fit \u03b80\u2026\u03b85 by performing\nordinary least squares on ln(loss), which is efficient,\nnumerically stable, and uses at most 6 parameters.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss for given MoE configurations.\n\n    Args:\n      data_points: array\u2010like of shape (N,2) or (2,)\n                   each row = [num_experts, dense_parameter_count]\n      params:      array\u2010like of length 6 = [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns:\n      preds: ndarray of shape (N,) with predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # If single sample given as shape (2,), reshape to (1,2)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected 2 elements for a single data_point, got {X.size}\")\n        X = X.reshape(1, 2)\n    # Split features and enforce positivity for log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = theta\n\n    # Log-quadratic with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Back to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by linear least squares\n    on the log of the validation loss.\n\n    Args:\n      data_points: array\u2010like of shape (N,2)\n      loss_values: array\u2010like of shape (N,)\n\n    Returns:\n      theta_opt: ndarray of length 6 with optimized [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected shape (2,) for a single sample, got {X.shape}\")\n        X = X.reshape(1, 2)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(f\"Number of data points {X.shape[0]} \"\n                         f\"does not match number of targets {y.shape[0]}\")\n\n    # Clamp to avoid log(0), then take log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n\n    # Build features in log-space\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n\n    # Solve M \u00b7 \u03b8 \u2248 ln_y in least-squares sense\n    theta_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given MoE configuration:\n      data_points: array-like of shape (N,2) or (2,), columns = [num_experts, dense_param_count]\n      params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Model:\n      ln\u2009L = \u03b80 \n           + \u03b81\u00b7ln(P) \n           + \u03b82\u00b7ln(E) \n           + \u03b83\u00b7(1/P) \n           + \u03b84\u00b7(1/E) \n           + \u03b85\u00b7(1/(P\u00b7E))\n      L = exp(ln\u2009L)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # handle single data point\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected 2 features, got shape {X.shape}\")\n        X = X.reshape(1, 2)\n    elif X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    # split features and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    # compute transformed features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = theta\n    # linear model in transformed space\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * invP\n        + \u03b84 * invE\n        + \u03b85 * invPE\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter scaling law by ridge-regularized least squares\n    on ln(loss):\n\n      ln\u2009L = \u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns:\n      theta_opt: ndarray of length 6\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        if X.size != 2:\n            raise ValueError(f\"Expected shape (2,) for a single sample, got {X.shape}\")\n        X = X.reshape(1, 2)\n    elif X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(\"Number of samples in data_points and loss_values must match\")\n\n    # enforce positivity for logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    y_clip = np.clip(y, 1e-8, None)\n    lnY = np.log(y_clip)\n\n    # design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P\u00b7E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        1.0 / P,\n        1.0 / E,\n        (1.0 / P) * (1.0 / E)\n    ]).T  # shape (N,6)\n\n    # ridge regularization weight proportional to trace\n    MtM = M.T @ M\n    ridge_weight = 1e-6 * np.trace(MtM) / MtM.shape[0]\n    A = MtM + ridge_weight * np.eye(6)\n    b = M.T @ lnY\n\n    theta_opt = np.linalg.solve(A, b)\n    return theta_opt\n```"]}}}