{"id": "bd0c334d-b44a-459f-8981-f67eadc262b6", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nStable scaling law: 6-parameter log\u2013quadratic interaction model\n\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\n\nWe fit \u03b80\u2026\u03b85 by solving a ridge\u2010regularized least squares on ln(loss),\nwith \u03bb scaled by the trace of the feature covariance for numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:      array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # allow flat input\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must be of shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # extract and clip features to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # unpack parameters\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log-loss\n    lnL = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP * lnE)\n      + \u03b84 * (lnP ** 2)\n      + \u03b85 * (lnE ** 2)\n    )\n    # back-transform\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model by\n    ridge-regularized least squares on ln(loss).\n    Returns:\n      ndarray of shape (6,) with fitted [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must be of shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same length\")\n\n    # log-transform target\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n\n    # build log-features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ])  # shape (N,6)\n\n    # ridge regularization scaled by data trace for stability\n    MtM = M.T.dot(M)\n    lambda_reg = 1e-6 * np.trace(MtM)\n    A = MtM + lambda_reg * np.eye(6)\n    b = M.T.dot(ln_y)\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "3b671527-09f4-4ed9-9cbc-0bd1757fe812", "generation": 3, "timestamp": 1754718587.543356, "iteration_found": 42, "metrics": {"nmse": 0.7719929215982115, "nmae": 0.8106495358371106, "r2": 0.22800707840178847, "combined_score": 0.5643363400673582}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.8614702342934307, "nmae": 0.8577973508276402, "r2": 0.13852976570656927, "combined_score": 0.5372097719196547}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.8615\n- nmae: 0.8578\n- r2: 0.1385\n- combined_score: 0.5372\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nFitting is done via linear least squares on log(loss), which is fast and numerically stable.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_parameter_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # logarithms\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positivity for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # feature logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares on log-loss\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n### Program 2 (Score: 0.5812)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nImproved 6-parameter log\u2013quadratic interaction model in log-space:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere:\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are the 6 learnable parameters.\nFitting is performed via linear least squares on ln(loss), which is\nfast, numerically stable, and captures multiplicative and curvature effects.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n      params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \n    # Split features\n    E = X[:, 0]  # num_experts\n    P = X[:, 1]  # dense_parameter_count\n    \n    # Clip to avoid log(0)\n    eps = 1e-8\n    E_clipped = np.clip(E, eps, None)\n    P_clipped = np.clip(P, eps, None)\n    \n    # Compute logs\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    \n    # Unpack \u03b8\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    \n    # Log\u2013quadratic interaction model\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    \n    # Convert back to actual loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model to the data.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    loss_values: (N,) array of validation loss values\n    Returns:\n      params: ndarray of shape (6,), the fitted [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same length\")\n    \n    # Clip and log-transform target to work in log-space\n    eps = 1e-8\n    y_clipped = np.clip(y, eps, None)\n    ln_y = np.log(y_clipped)\n    \n    # Features for design matrix\n    E = np.clip(X[:, 0], eps, None)\n    P = np.clip(X[:, 1], eps, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \n    # Build design matrix M of shape (N,6):\n    #  [1,\n    #   lnP,\n    #   lnE,\n    #   lnP\u00b7lnE,\n    #   (lnP)^2,\n    #   (lnE)^2]\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    )).T  # shape = (N,6)\n    \n    # Solve \u03b8 = argmin ||M\u00b7\u03b8 - ln_y||^2 via least squares\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \n    return \u03b8_opt\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law using a 6-parameter log\u2013quadratic interaction model:\n  L(E, P) = exp(\u03b80\n                + \u03b81\u00b7lnP\n                + \u03b82\u00b7lnE\n                + \u03b83\u00b7(lnP\u00b7lnE)\n                + \u03b84\u00b7(lnP)^2\n                + \u03b85\u00b7(lnE)^2)\nFits by linear least squares on log(loss) for robustness and speed.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    # split and clamp to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # parameters\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    t0, t1, t2, t3, t4, t5 = theta\n    # log\u2010quadratic form with interaction\n    u = (\n        t0\n        + t1 * lnP\n        + t2 * lnE\n        + t3 * (lnP * lnE)\n        + t4 * (lnP ** 2)\n        + t5 * (lnE ** 2)\n    )\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model by solving\n    linear least squares on ln(loss), returning [\u03b80...\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # clamp and take log of target\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve for \u03b8 in M\u00b7\u03b8 \u2248 ln_y\n    theta_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5937)\n```python\n\"\"\"\nScaling law discovery for Mixture\u2010of\u2010Experts LLM finetuning scenarios.\nWe use a 6-parameter log-quadratic interaction model:\n\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are learned parameters.\n\nFitting is performed via ridge-regularized least squares on ln(loss)\nfor numerical stability and better generalization with limited data.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:      array of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"Expected data_points with 2 columns [num_experts, dense_param_count]\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # split and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    # log-transform\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # build design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    )).T  # shape (N,6)\n\n    # compute log-loss and exponentiate\n    lnL = M.dot(\u03b8)\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model via\n    ridge-regularized least squares on ln(loss).\n    Returns optimized parameters [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"Expected data_points with 2 columns [num_experts, dense_param_count]\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of loss_values must match number of data_points\")\n\n    # ensure positive values for log\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n\n    # prepare log\u2010features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    )).T  # shape (N,6)\n\n    # ridge regularization: small multiple of trace of M^T M\n    # this scales with data variance and prevents overfitting\n    MtM = M.T.dot(M)\n    trace = np.trace(MtM)\n    lambda_reg = 1e-6 * trace  # tune factor as needed\n\n    # solve (M^T M + \u03bbI) \u03b8 = M^T ln_y\n    A = MtM + lambda_reg * np.eye(6)\n    b = M.T.dot(ln_y)\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for MoE LLM validation loss\nModel:\n    loss \u2248 exp(\u03b80\n               + \u03b81\u00b7ln(P)\n               + \u03b82\u00b7ln(E)\n               + \u03b83\u00b7ln(P)\u00b7ln(E)\n               + \u03b84\u00b7[ln(P)]\u00b2\n               + \u03b85\u00b7[ln(E)]\u00b2)\nwhere:\n    E = number of experts\n    P = dense parameter count\nThis 6-parameter log-quadratic form captures interactions and curvature in log space.\nFitting is performed via linear least squares on ln(loss) for efficiency and stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: shape (N,2) array [num_experts, dense_parameter_count]\n      params: length-6 array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    # Split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # Avoid non-positive before log\n    E_clipped = np.clip(E, 1e-8, None)\n    P_clipped = np.clip(P, 1e-8, None)\n    # Log-transformed features\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute log-loss prediction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Back-transform\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law:\n      minimize || ln(loss_values) - [\u03b80 + \u03b81\u00b7ln(P) + \u03b82\u00b7ln(E) + \u03b83\u00b7ln(P)\u00b7ln(E)\n                                     + \u03b84\u00b7(ln(P))\u00b2 + \u03b85\u00b7(ln(E))\u00b2 ] ||\u00b2\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    # Ensure positivity for log-target\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Prepare log features\n    E = X[:, 0]; P = X[:, 1]\n    E_clipped = np.clip(E, 1e-8, None)\n    P_clipped = np.clip(P, 1e-8, None)\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    # Build design matrix\n    # Columns: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ])\n    # Solve normal equations via least squares\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nFitting is done via linear least squares on log(loss), which is fast and numerically stable.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_parameter_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # logarithms\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positivity for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # feature logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares on log-loss\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 2 (Score: 0.6308, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nImproved multi-parameter power-law model with efficient bounded fitting.\nModel form:\n    L(N_e, D) = a * N_e^{-p1} + b * D^{-p2} + c\nParameters: [a, p1, b, p2, c] (5 total)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array [a, p1, b, p2, c]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    # split features\n    num_experts = X[:, 0].astype(np.float64)\n    dense_params = X[:, 1].astype(np.float64)\n    # unpack parameters\n    a, p1, b, p2, c = params\n    # compute power-law contributions\n    # use np.maximum to avoid zero**neg issues\n    ne_term = a * (np.maximum(num_experts, 1e-8) ** (-p1))\n    dp_term = b * (np.maximum(dense_params, 1e-8) ** (-p2))\n    return ne_term + dp_term + c\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 5-parameter scaling law to minimize MSE between predicted and actual loss.\n    Returns optimized params [a, p1, b, p2, c].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    y = np.asarray(loss_values).astype(np.float64).ravel()\n    num_experts = X[:, 0]\n    dense_params = X[:, 1]\n\n    # residual function for least-squares\n    def residuals(params):\n        pred = scaling_law_func(X, params)\n        return pred - y\n\n    # initial guesses:\n    y_min, y_max = np.min(y), np.max(y)\n    init_a = max(y_max - y_min, 1.0)\n    init_b = init_a\n    init_c = y_min if y_min > 0 else 0.1\n    init = np.array([init_a, 0.5, init_b, 0.5, init_c])\n\n    # bounds: all parameters >= 0, exponents reasonably capped\n    lower_bounds = [0.0, 0.0, 0.0, 0.0,    0.0]\n    upper_bounds = [np.inf, 5.0, np.inf, 5.0, np.inf]\n\n    result = least_squares(\n        residuals,\n        x0=init,\n        bounds=(lower_bounds, upper_bounds),\n        method='trf',\n        ftol=1e-9,\n        xtol=1e-9,\n        gtol=1e-9,\n        max_nfev=10000\n    )\n\n    return result.x\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (1.256), Excellent nmae (1.080)\n\n\n### Inspiration 3 (Score: 0.5937, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for Mixture\u2010of\u2010Experts LLM finetuning scenarios.\nWe use a 6-parameter log-quadratic interaction model:\n\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are learned parameters.\n\nFitting is performed via ridge-regularized least squares on ln(loss)\nfor numerical stability and better generalization with limited data.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:      array of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"Expected data_points with 2 columns [num_experts, dense_param_count]\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # split and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    # log-transform\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # build design matrix: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    )).T  # shape (N,6)\n\n    # compute log-loss and exponentiate\n    lnL = M.dot(\u03b8)\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model via\n    ridge-regularized least squares on ln(loss).\n    Returns optimized parameters [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"Expected data_points with 2 columns [num_experts, dense_param_count]\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.size != X.shape[0]:\n        raise ValueError(\"Number of loss_values must match number of data_points\")\n\n    # ensure positive values for log\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n\n    # prepare log\u2010features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    )).T  # shape (N,6)\n\n    # ridge regularization: small multiple of trace of M^T M\n    # this scales with data variance and prevents overfitting\n    MtM = M.T.dot(M)\n    trace = np.trace(MtM)\n    lambda_reg = 1e-6 * trace  # tune factor as needed\n\n    # solve (M^T M + \u03bbI) \u03b8 = M^T ln_y\n    A = MtM + lambda_reg * np.eye(6)\n    b = M.T.dot(ln_y)\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative r2 approach, NumPy-based implementation\n\n\n### Inspiration 4 (Score: 0.5812, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for MoE LLM finetuning scenarios\nImproved 6-parameter log\u2013quadratic interaction model in log-space:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere:\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are the 6 learnable parameters.\nFitting is performed via linear least squares on ln(loss), which is\nfast, numerically stable, and captures multiplicative and curvature effects.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n      params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \n    # Split features\n    E = X[:, 0]  # num_experts\n    P = X[:, 1]  # dense_parameter_count\n    \n    # Clip to avoid log(0)\n    eps = 1e-8\n    E_clipped = np.clip(E, eps, None)\n    P_clipped = np.clip(P, eps, None)\n    \n    # Compute logs\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    \n    # Unpack \u03b8\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    \n    # Log\u2013quadratic interaction model\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    \n    # Convert back to actual loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model to the data.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    loss_values: (N,) array of validation loss values\n    Returns:\n      params: ndarray of shape (6,), the fitted [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same length\")\n    \n    # Clip and log-transform target to work in log-space\n    eps = 1e-8\n    y_clipped = np.clip(y, eps, None)\n    ln_y = np.log(y_clipped)\n    \n    # Features for design matrix\n    E = np.clip(X[:, 0], eps, None)\n    P = np.clip(X[:, 1], eps, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \n    # Build design matrix M of shape (N,6):\n    #  [1,\n    #   lnP,\n    #   lnE,\n    #   lnP\u00b7lnE,\n    #   (lnP)^2,\n    #   (lnE)^2]\n    M = np.vstack((\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    )).T  # shape = (N,6)\n    \n    # Solve \u03b8 = argmin ||M\u00b7\u03b8 - ln_y||^2 via least squares\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    \n    return \u03b8_opt\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 5 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for MoE LLM validation loss\nModel:\n    loss \u2248 exp(\u03b80\n               + \u03b81\u00b7ln(P)\n               + \u03b82\u00b7ln(E)\n               + \u03b83\u00b7ln(P)\u00b7ln(E)\n               + \u03b84\u00b7[ln(P)]\u00b2\n               + \u03b85\u00b7[ln(E)]\u00b2)\nwhere:\n    E = number of experts\n    P = dense parameter count\nThis 6-parameter log-quadratic form captures interactions and curvature in log space.\nFitting is performed via linear least squares on ln(loss) for efficiency and stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: shape (N,2) array [num_experts, dense_parameter_count]\n      params: length-6 array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    # Split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # Avoid non-positive before log\n    E_clipped = np.clip(E, 1e-8, None)\n    P_clipped = np.clip(P, 1e-8, None)\n    # Log-transformed features\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute log-loss prediction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # Back-transform\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law:\n      minimize || ln(loss_values) - [\u03b80 + \u03b81\u00b7ln(P) + \u03b82\u00b7ln(E) + \u03b83\u00b7ln(P)\u00b7ln(E)\n                                     + \u03b84\u00b7(ln(P))\u00b2 + \u03b85\u00b7(ln(E))\u00b2 ] ||\u00b2\n    Returns:\n      \u03b8_opt: length-6 array of fitted parameters\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(\"data_points must be of shape (N,2)\")\n    # Ensure positivity for log-target\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Prepare log features\n    E = X[:, 0]; P = X[:, 1]\n    E_clipped = np.clip(E, 1e-8, None)\n    P_clipped = np.clip(P, 1e-8, None)\n    lnE = np.log(E_clipped)\n    lnP = np.log(P_clipped)\n    # Build design matrix\n    # Columns: [1, lnP, lnE, lnP*lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ])\n    # Solve normal equations via least squares\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nRobust scaling law with log-quadratic interaction form:\n    L(E,P) = exp(\u03b80\n                 + \u03b81\u00b7lnP\n                 + \u03b82\u00b7lnE\n                 + \u03b83\u00b7(lnP\u00b7lnE)\n                 + \u03b84\u00b7(lnP)^2\n                 + \u03b85\u00b7(lnE)^2 )\nwhere E = num_experts, P = dense_parameter_count.\nWe fit \u03b80\u2026\u03b85 by performing Huber-weighted ridge regression\non ln(loss), which improves robustness to outliers\nand numerical stability with limited data.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_param_count]\n      params:      6-element array [\u03b80\u2026\u03b85]\n    Returns:\n      (N,) array of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log-loss\n    lnL = (\u03b80\n           + \u03b81 * lnP\n           + \u03b82 * lnE\n           + \u03b83 * (lnP * lnE)\n           + \u03b84 * (lnP ** 2)\n           + \u03b85 * (lnE ** 2))\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by Huber-weighted\n    ridge regression on ln(loss). Returns [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # ensure positive targets for log\n    y = np.clip(y, 1e-8, None)\n    ln_y = np.log(y)\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # 1) initial ordinary least squares on ln_y\n    \u03b8_init, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    residuals = M.dot(\u03b8_init) - ln_y\n\n    # 2) compute robust Huber weights\n    # scale estimate via MAD\n    mad = np.median(np.abs(residuals - np.median(residuals))) * 1.4826\n    c = 1.345 * (mad if mad > 0 else np.std(residuals) + 1e-8)\n    abs_r = np.abs(residuals)\n    weights = np.where(abs_r <= c, 1.0, c / abs_r)\n\n    # 3) weighted least squares with small ridge penalty\n    w_sqrt = np.sqrt(weights)\n    M_w = M * w_sqrt[:, None]\n    y_w = ln_y * w_sqrt\n    # ridge parameter scaled to data\n    alpha = 1e-6 * np.trace(M_w.T.dot(M_w))\n    A = M_w.T.dot(M_w) + alpha * np.eye(M_w.shape[1])\n    b = M_w.T.dot(y_w)\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nStable scaling law: 6-parameter log\u2013quadratic interaction model\n\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP\u00b7lnE)\n      + \u03b84\u00b7(lnP)^2\n      + \u03b85\u00b7(lnE)^2\n    )\n\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\n\nWe fit \u03b80\u2026\u03b85 by solving a ridge\u2010regularized least squares on ln(loss),\nwith \u03bb scaled by the trace of the feature covariance for numerical stability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:      array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # allow flat input\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must be of shape (N,2), got {X.shape}\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n\n    # extract and clip features to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # unpack parameters\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # compute log-loss\n    lnL = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP * lnE)\n      + \u03b84 * (lnP ** 2)\n      + \u03b85 * (lnE ** 2)\n    )\n    # back-transform\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic interaction model by\n    ridge-regularized least squares on ln(loss).\n    Returns:\n      ndarray of shape (6,) with fitted [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    if X.ndim != 2 or X.shape[1] != 2:\n        raise ValueError(f\"data_points must be of shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same length\")\n\n    # log-transform target\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n\n    # build log-features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ])  # shape (N,6)\n\n    # ridge regularization scaled by data trace for stability\n    MtM = M.T.dot(M)\n    lambda_reg = 1e-6 * np.trace(MtM)\n    A = MtM + lambda_reg * np.eye(6)\n    b = M.T.dot(ln_y)\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```"]}}}