{"id": "e31dcd87-abdb-4099-be45-e7e0bb412564", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given:\n      - data_points: array-like of shape (N,2): [num_experts, dense_parameter_count]\n      - params: array-like of length 6: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Model: L = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,2)\n    if X.ndim == 1:\n        X = X.reshape(1, 2)\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # extract and clip features for log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    # build feature matrix [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # compute log\u2010loss and back-transform\n    u = M.dot(theta)\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by ridge-regularized linear\n    least squares on ln(loss).\n    Returns optimized parameters [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, 2)\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same number of rows\")\n\n    # log-transform inputs and target with clipping for numerical stability\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # ridge regularization: \u03b1 = 1e-6 * max(mean(diag(M^T M)), 1)\n    gram = M.T.dot(M)\n    diag_mean = np.mean(np.diag(gram))\n    alpha = 1e-6 * max(diag_mean, 1.0)\n\n    # solve (M^T M + \u03b1 I) \u03b8 = M^T ln_y\n    A = gram + alpha * np.eye(6)\n    b = M.T.dot(ln_y)\n    theta_opt = np.linalg.solve(A, b)\n    return theta_opt\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "fbb91ea2-372e-410b-84c5-d1a1007bb98c", "generation": 2, "timestamp": 1754718552.3841512, "iteration_found": 37, "metrics": {"nmse": 2.065773688239821, "nmae": 1.5133705735893048, "r2": -1.0657736882398212, "combined_score": 0.326181936989008}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.36751514046727124, "nmae": 0.5937087780384879, "r2": 0.6324848595327288, "combined_score": 0.7312533297863937}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3675\n- nmae: 0.5937\n- r2: 0.6325\n- combined_score: 0.7313\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law using a 6-parameter log\u2013quadratic interaction model:\n  L(E, P) = exp(\u03b80\n                + \u03b81\u00b7lnP\n                + \u03b82\u00b7lnE\n                + \u03b83\u00b7(lnP\u00b7lnE)\n                + \u03b84\u00b7(lnP)^2\n                + \u03b85\u00b7(lnE)^2)\nFits by linear least squares on log(loss) for robustness and speed.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_parameter_count]\n    params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) predicted losses\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    # split and clamp to avoid log(0)\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # parameters\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    t0, t1, t2, t3, t4, t5 = theta\n    # log\u2010quadratic form with interaction\n    u = (\n        t0\n        + t1 * lnP\n        + t2 * lnE\n        + t3 * (lnP * lnE)\n        + t4 * (lnP ** 2)\n        + t5 * (lnE ** 2)\n    )\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log\u2013quadratic model by solving\n    linear least squares on ln(loss), returning [\u03b80...\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(-1, 2)\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # clamp and take log of target\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve for \u03b8 in M\u00b7\u03b8 \u2248 ln_y\n    theta_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n### Program 2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere:\n  P = dense parameter count,\n  E = num_experts,\n  \u03b80\u2026\u03b85 are 6 learnable parameters.\nFitting is done via linear least squares on log(loss), ensuring numerical stability\nand capturing both multiplicative interactions and curvature in log-space.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given expert count and dense parameter count.\n    data_points: (N,2) array [num_experts, dense_param_count]\n    params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns: (N,) predicted loss\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split and ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # log-transform\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic form with interaction\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    # back to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic scaling law to the data.\n    Returns: np.ndarray of shape (6,) containing [\u03b80\u2026\u03b85]\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # clip targets to avoid log(0)\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # feature logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # build design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N, 6)\n    # solve for \u03b8 in least-squares sense\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.7099)\n```python\n\"\"\"\nImproved scaling law discovery using a full bivariate log\u2010quadratic polynomial (6 parameters).\nModel form:\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP)^2\n      + \u03b84\u00b7(lnE)^2\n      + \u03b85\u00b7(lnP\u00b7lnE)\n    )\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\n\nWe fit \u03b8 by ridge\u2010regularized least squares on ln(L) for numerical stability\nand better generalization with limited data.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given num_experts E and dense parameter count P.\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    params: array-like of length 6: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns: numpy array of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(data_points).astype(float)\n    # ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters (\u03b80\u2026\u03b85), got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # full bivariate log\u2010quadratic polynomial\n    u = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP ** 2)\n      + \u03b84 * (lnE ** 2)\n      + \u03b85 * (lnP * lnE)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model to observed validation losses.\n    Minimizes ||M \u03b8 \u2013 ln(y)||^2 + \u03b1||\u03b8||^2 (ridge), where\n      M columns = [1, lnP, lnE, (lnP)^2, (lnE)^2, lnP\u00b7lnE].\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    loss_values: array-like of shape (N,): observed validation losses\n\n    Returns: numpy array of shape (6,) with optimized [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(data_points).astype(float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # log-transform response with clipping for stability\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # log-transform inputs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix M: shape (N,6)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP ** 2,\n        lnE ** 2,\n        lnP * lnE\n    ]).T\n\n    # ridge regularization weight (small for numerical stability)\n    # scale \u03b1 by average diagonal magnitude of M^T M\n    gram = M.T.dot(M)\n    diag_mean = np.mean(np.diag(gram))\n    \u03b1 = 1e-6 * max(diag_mean, 1.0)\n\n    A = gram + \u03b1 * np.eye(gram.shape[0])\n    b = M.T.dot(ln_y)\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law using a 6-parameter log-quadratic interaction model:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\nThis form captures multiplicative interactions and curvature in log-space\nand is fitted via linear least squares on log(loss) for numerical stability.\n\"\"\"\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_parameter_count]\n    # params: array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # ensure positivity for logs\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # compute logs\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log-quadratic model with interaction\n    u = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * (lnP ** 2)\n        + \u03b85 * (lnE ** 2)\n    )\n    # map back to original loss scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array [num_experts, dense_parameter_count]\n    # loss_values: (N,) array of observed validation losses\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same number of rows\")\n    # split and clip for logs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # take logs\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # ensure positive targets for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # build design matrix [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N,6)\n    # solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.7099, Type: Alternative)\n```python\n\"\"\"\nImproved scaling law discovery using a full bivariate log\u2010quadratic polynomial (6 parameters).\nModel form:\n    L(E, P) = exp(\n        \u03b80\n      + \u03b81\u00b7lnP\n      + \u03b82\u00b7lnE\n      + \u03b83\u00b7(lnP)^2\n      + \u03b84\u00b7(lnE)^2\n      + \u03b85\u00b7(lnP\u00b7lnE)\n    )\nwhere\n  E = num_experts,\n  P = dense_parameter_count.\n\nWe fit \u03b8 by ridge\u2010regularized least squares on ln(L) for numerical stability\nand better generalization with limited data.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given num_experts E and dense parameter count P.\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    params: array-like of length 6: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Returns: numpy array of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(data_points).astype(float)\n    # ensure positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters (\u03b80\u2026\u03b85), got {\u03b8.size}\")\n\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # full bivariate log\u2010quadratic polynomial\n    u = (\n        \u03b80\n      + \u03b81 * lnP\n      + \u03b82 * lnE\n      + \u03b83 * (lnP ** 2)\n      + \u03b84 * (lnE ** 2)\n      + \u03b85 * (lnP * lnE)\n    )\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model to observed validation losses.\n    Minimizes ||M \u03b8 \u2013 ln(y)||^2 + \u03b1||\u03b8||^2 (ridge), where\n      M columns = [1, lnP, lnE, (lnP)^2, (lnE)^2, lnP\u00b7lnE].\n\n    data_points: array-like of shape (N,2): [num_experts, dense_param_count]\n    loss_values: array-like of shape (N,): observed validation losses\n\n    Returns: numpy array of shape (6,) with optimized [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(data_points).astype(float)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # log-transform response with clipping for stability\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # log-transform inputs\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # design matrix M: shape (N,6)\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP ** 2,\n        lnE ** 2,\n        lnP * lnE\n    ]).T\n\n    # ridge regularization weight (small for numerical stability)\n    # scale \u03b1 by average diagonal magnitude of M^T M\n    gram = M.T.dot(M)\n    diag_mean = np.mean(np.diag(gram))\n    \u03b1 = 1e-6 * max(diag_mean, 1.0)\n\n    A = gram + \u03b1 * np.eye(gram.shape[0])\n    b = M.T.dot(ln_y)\n\n    \u03b8_opt = np.linalg.solve(A, b)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (2.066), Excellent nmae (1.513)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given:\n      - data_points: array-like of shape (N,2): [num_experts, dense_parameter_count]\n      - params: array-like of length 6: [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Model: L = exp(\u03b80\n                  + \u03b81\u00b7lnP\n                  + \u03b82\u00b7lnE\n                  + \u03b83\u00b7(lnP\u00b7lnE)\n                  + \u03b84\u00b7(lnP)^2\n                  + \u03b85\u00b7(lnE)^2)\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,2)\n    if X.ndim == 1:\n        X = X.reshape(1, 2)\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    # extract and clip features for log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack parameters\n    theta = np.asarray(params, dtype=float).ravel()\n    if theta.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {theta.size}\")\n    # build feature matrix [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # compute log\u2010loss and back-transform\n    u = M.dot(theta)\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter log-quadratic model by ridge-regularized linear\n    least squares on ln(loss).\n    Returns optimized parameters [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, 2)\n    if X.shape[1] != 2:\n        raise ValueError(f\"Expected data_points with 2 columns, got shape {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"data_points and loss_values must have the same number of rows\")\n\n    # log-transform inputs and target with clipping for numerical stability\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    # design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n\n    # ridge regularization: \u03b1 = 1e-6 * max(mean(diag(M^T M)), 1)\n    gram = M.T.dot(M)\n    diag_mean = np.mean(np.diag(gram))\n    alpha = 1e-6 * max(diag_mean, 1.0)\n\n    # solve (M^T M + \u03b1 I) \u03b8 = M^T ln_y\n    A = gram + alpha * np.eye(6)\n    b = M.T.dot(ln_y)\n    theta_opt = np.linalg.solve(A, b)\n    return theta_opt\n# EVOLVE-BLOCK-END\n```"]}}}