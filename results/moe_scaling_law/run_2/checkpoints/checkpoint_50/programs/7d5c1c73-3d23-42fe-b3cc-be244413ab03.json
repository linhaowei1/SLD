{"id": "7d5c1c73-3d23-42fe-b3cc-be244413ab03", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given:\n      data_points: array-like of shape (N,2) [num_experts E, dense_param_count P]\n      params:      array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Model in log\u2010space:\n      ln L = \u03b80\n           + \u03b81\u00b7ln(P)\n           + \u03b82\u00b7ln(E)\n           + \u03b83\u00b7[ln(P) * ln(E)]\n           + \u03b84\u00b7(1/P)\n           + \u03b85\u00b7[1/(P\u00b7E)]\n\n    Returns:\n      preds: ndarray of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invP = 1.0 / P\n    invPE = invP / E  # 1/(P\u00b7E)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    lnL = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * invP\n        + \u03b85 * invPE\n    )\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by ordinary least squares on ln(loss):\n      ln(y) \u2248 \u03b80\u00b71 + \u03b81\u00b7ln(P) + \u03b82\u00b7ln(E) + \u03b83\u00b7[ln(P)\u00b7ln(E)]\n                       + \u03b84\u00b7(1/P) + \u03b85\u00b7[1/(P\u00b7E)]\n\n    Returns:\n      \u03b8_opt: ndarray of shape (6,) with the fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must have the same number of rows as data_points\")\n\n    # Avoid log(0) or negative\n    y_safe = np.clip(y, 1e-8, None)\n    lnY = np.log(y_safe)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invP = 1.0 / P\n    invPE = invP / E\n\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, 1/P, 1/(P\u00b7E)]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        invP,\n        invPE\n    ])\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "8dfaa045-1094-4caa-8e2f-f41ef3a5bf02", "generation": 2, "timestamp": 1754718556.8131952, "iteration_found": 38, "metrics": {"nmse": 0.12448705194557526, "nmae": 0.34971131731123994, "r2": 0.8755129480544247, "combined_score": 0.8892943660576713}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.36751514046727124, "nmae": 0.5937087780384879, "r2": 0.6324848595327288, "combined_score": 0.7312533297863937}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between MoE architecture parameters and validation loss.\n\n**IMPORTANT: The scaling law function must use no more than 6 parameters.**\n\nFocus on mathematical accuracy across different MoE configurations, generalization across expert counts and model sizes, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: [num_experts, dense_parameter_count] - 2D input\n- Labels: loss_validation - scalar output\n- Number of experts: ranges from 1 to multiple values\n- Dense parameter count: ranges across different model architectures\n- Validation loss: continuous values representing model performance\n- All data filtered to step 249000 for consistency\n- 80/20 train/test split applied\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # num_experts: Array of expert counts\n    # dense_parameter_count: Array of dense parameter counts\n    # params: Array of up to 6 parameters\n    # Returns: Predicted validation loss values\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,2) array with columns [num_experts, dense_parameter_count]\n    # loss_values: Array of corresponding validation loss values\n    # Returns: Optimized parameters (up to 6 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.3675\n- nmae: 0.5937\n- r2: 0.6325\n- combined_score: 0.7313\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.3675, nmae: 0.5937, r2: 0.6325, combined_score: 0.7313\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.3482, nmae: 0.5695, r2: 0.6518, combined_score: 0.7417\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.3482, nmae: 0.5695, r2: 0.6518, combined_score: 0.7417\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5778)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given:\n      data_points: array-like of shape (N,2) [num_experts E, dense_param_count P]\n      params:      array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Model (in log-space):\n      ln L = \u03b80\n           + \u03b81\u00b7ln P\n           + \u03b82\u00b7ln E\n           + \u03b83\u00b7(1 / P)\n           + \u03b84\u00b7(1 / E)\n           + \u03b85\u00b7(1 / (P \u00b7 E))\n    Returns:\n      preds: ndarray of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # Numerical stability\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # Transforms\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute log-loss and exponentiate\n    lnL = (\u03b80\n           + \u03b81 * lnP\n           + \u03b82 * lnE\n           + \u03b83 * invP\n           + \u03b84 * invE\n           + \u03b85 * invPE)\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by linear least squares on ln(loss):\n      ln y \u2248 \u03b80\u00b71 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n    Returns:\n      \u03b8_opt: ndarray of shape (6,) with the fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure positive targets for log\n    y_safe = np.clip(y, 1e-8, None)\n    lnY = np.log(y_safe)\n    # Features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n    # Design matrix: [1, lnP, lnE, 1/P, 1/E, 1/(P\u00b7E)]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        invP,\n        invE,\n        invPE\n    ])\n    # Solve least squares for \u03b8\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3482), Performs well on nmae (0.5695), Performs well on r2 (0.6518), Performs well on combined_score (0.7417)\n\n\n### Program 2 (Score: 0.5778)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Parametric scaling law:\n      ln L = \u03b80 \n           + \u03b81 * ln(P) \n           + \u03b82 * ln(E) \n           + \u03b83 * (1 / P) \n           + \u03b84 * (1 / E) \n           + \u03b85 * (1 / (P * E))\n    => L = exp( ln L ).\n\n    Inputs:\n      data_points : (N,2) array of [E, P]\n      params       : array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      preds        : (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = X[:, 0]\n    P = X[:, 1]\n\n    # numerical safeguards\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * invP\n         + \u03b84 * invE\n         + \u03b85 * invPE)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by linear least squares on ln(loss):\n      ln y \u2248 \u03b80\u00b71 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns the optimal \u03b8 of shape (6,).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # to keep ln well\u2010defined\n    y = np.clip(y, 1e-8, None)\n    lnY = np.log(y)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    # build design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P*E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        invP,\n        invE,\n        invPE\n    ]).T\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3482), Performs well on nmae (0.5695), Performs well on r2 (0.6518), Performs well on combined_score (0.7417)\n\n\n### Program 3 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling\u2010law model with a log\u2013quadratic interaction form:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere:\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are fitted parameters (6 total).\nThis form captures multiplicative effects, curvature, and interactions in log\u2010space.\nFitting is done via a linear least squares on ln(loss), ensuring numerical stability\nand efficient parameter estimation even on limited data.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:    6-element array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # Log\u2010transform features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute log\u2010quadratic model with interaction\n    lnL = (\u03b80\n           + \u03b81 * lnP\n           + \u03b82 * lnE\n           + \u03b83 * (lnP * lnE)\n           + \u03b84 * (lnP ** 2)\n           + \u03b85 * (lnE ** 2))\n    # Exponentiate to return to loss scale\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic model by ordinary least squares\n    on ln(loss). Returns the optimized [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive targets for log\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n    # Prepare features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N, 6)\n    # Solve for \u03b8 in least\u2010squares sense: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.3675), Performs well on nmae (0.5937), Performs well on r2 (0.6325), Performs well on combined_score (0.7313)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5812)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery using a log\u2013quadratic interaction model.\nModel:\n    L(E, P) = exp(\u03b80\n                  + \u03b81 * ln(P)\n                  + \u03b82 * ln(E)\n                  + \u03b83 * ln(P) * ln(E)\n                  + \u03b84 * (ln(P))^2\n                  + \u03b85 * (ln(E))^2)\nwhere\n    E = num_experts,\n    P = dense_parameter_count,\n    \u03b8 = [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85] (6 parameters).\nFitting is performed by solving a linear least\u2010squares problem on ln(loss),\nwhich is fast, robust, and numerically stable.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given [num_experts, dense_parameter_count].\n    \n    Args:\n        data_points: array of shape (N, 2), columns [num_experts, dense_parameter_count].\n        params: array-like of 6 parameters [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85].\n        \n    Returns:\n        preds: array of shape (N,), predicted validation losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    # Ensure strictly positive inputs before log\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # compute the log\u2010quadratic interaction polynomial\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * (lnP * lnE)\n         + \u03b84 * (lnP ** 2)\n         + \u03b85 * (lnE ** 2))\n    # back to original scale\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic interaction scaling law.\n    \n    Solves for \u03b8 in:\n        ln(loss) \u2248 \u03b80 + \u03b81 ln(P) + \u03b82 ln(E) + \u03b83 ln(P)\u00b7ln(E)\n                   + \u03b84 [ln(P)]^2 + \u03b85 [ln(E)]^2\n    \n    Args:\n        data_points: array of shape (N,2), columns [num_experts, dense_parameter_count].\n        loss_values: array of shape (N,), observed validation losses.\n        \n    Returns:\n        \u03b8_opt: array of 6 optimized parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(\"data_points must have shape (N,2)\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must be a 1D array aligned with data_points\")\n\n    # Clip to avoid log of zero or negative\n    y_clipped = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_clipped)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n\n    # Build design matrix M of shape (N,6)\n    # Columns: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T\n\n    # Solve linear least squares: M @ \u03b8 = ln_y\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5778, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Parametric scaling law:\n      ln L = \u03b80 \n           + \u03b81 * ln(P) \n           + \u03b82 * ln(E) \n           + \u03b83 * (1 / P) \n           + \u03b84 * (1 / E) \n           + \u03b85 * (1 / (P * E))\n    => L = exp( ln L ).\n\n    Inputs:\n      data_points : (N,2) array of [E, P]\n      params       : array-like of length 6 [\u03b80\u2026\u03b85]\n    Returns:\n      preds        : (N,) array of predicted losses.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    E = X[:, 0]\n    P = X[:, 1]\n\n    # numerical safeguards\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    u = (\u03b80\n         + \u03b81 * lnP\n         + \u03b82 * lnE\n         + \u03b83 * invP\n         + \u03b84 * invE\n         + \u03b85 * invPE)\n    return np.exp(u)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by linear least squares on ln(loss):\n      ln y \u2248 \u03b80\u00b71 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(1/P) + \u03b84\u00b7(1/E) + \u03b85\u00b7(1/(P\u00b7E))\n\n    Returns the optimal \u03b8 of shape (6,).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    y = np.asarray(loss_values, dtype=float).ravel()\n\n    # to keep ln well\u2010defined\n    y = np.clip(y, 1e-8, None)\n    lnY = np.log(y)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invE = 1.0 / E\n    invP = 1.0 / P\n    invPE = invP * invE\n\n    # build design matrix [1, lnP, lnE, 1/P, 1/E, 1/(P*E)]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        invP,\n        invE,\n        invPE\n    ]).T\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 2 (Score: 0.5812, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced scaling\u2010law model with a log\u2013quadratic interaction form:\n    L(E, P) = exp(\u03b80 \n                  + \u03b81\u00b7lnP \n                  + \u03b82\u00b7lnE \n                  + \u03b83\u00b7(lnP\u00b7lnE) \n                  + \u03b84\u00b7(lnP)^2 \n                  + \u03b85\u00b7(lnE)^2)\nwhere:\n  E = num_experts,\n  P = dense_parameter_count,\n  \u03b80\u2026\u03b85 are fitted parameters (6 total).\nThis form captures multiplicative effects, curvature, and interactions in log\u2010space.\nFitting is done via a linear least squares on ln(loss), ensuring numerical stability\nand efficient parameter estimation even on limited data.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss given:\n      data_points: (N,2) array [num_experts, dense_parameter_count]\n      params:    6-element array [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n    Returns:\n      (N,) array of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # Split and enforce positivity\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    # Log\u2010transform features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Unpack parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # Compute log\u2010quadratic model with interaction\n    lnL = (\u03b80\n           + \u03b81 * lnP\n           + \u03b82 * lnE\n           + \u03b83 * (lnP * lnE)\n           + \u03b84 * (lnP ** 2)\n           + \u03b85 * (lnE ** 2))\n    # Exponentiate to return to loss scale\n    return np.exp(lnL)\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6\u2010parameter log\u2010quadratic model by ordinary least squares\n    on ln(loss). Returns the optimized [\u03b80\u2026\u03b85].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive targets for log\n    y_safe = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_safe)\n    # Prepare features\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP ** 2,\n        lnE ** 2\n    ]).T  # shape (N, 6)\n    # Solve for \u03b8 in least\u2010squares sense: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law discovery using a log\u2013quadratic interaction model.\nModel: L = exp(\u03b80 + \u03b81\u00b7lnP + \u03b82\u00b7lnE + \u03b83\u00b7(lnP\u00b7lnE) + \u03b84\u00b7(lnP)^2 + \u03b85\u00b7(lnE)^2)\nwhere P = dense parameter count, E = num_experts.\nThis 6-parameter form captures multiplicative interactions and curvature in log-space.\nFitting is done via least squares on log(loss), avoiding expensive iterative minimization.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    # data_points: (N,2) array [num_experts, dense_param_count]\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    # split features\n    E = X[:, 0]\n    P = X[:, 1]\n    # numerical stability: clip to positive\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    # log features\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # unpack up to 6 parameters\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n    # log\u2010quadratic model with interaction\n    u = \u03b80 \\\n        + \u03b81 * lnP \\\n        + \u03b82 * lnE \\\n        + \u03b83 * (lnP * lnE) \\\n        + \u03b84 * (lnP ** 2) \\\n        + \u03b85 * (lnE ** 2)\n    # back to original scale\n    return np.exp(u)\n\ndef fit_scaling_law(data_points, loss_values):\n    # Prepare data\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float).ravel()\n    # Ensure strictly positive target for log\n    y_pos = np.clip(y, 1e-8, None)\n    ln_y = np.log(y_pos)\n    # Features\n    E = X[:, 0]\n    P = X[:, 1]\n    E = np.clip(E, 1e-8, None)\n    P = np.clip(P, 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, (lnP)^2, (lnE)^2]\n    M = np.vstack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        lnP**2,\n        lnE**2\n    ]).T  # shape (N,6)\n    # Solve linear least squares: minimize ||M\u00b7\u03b8 - ln_y||^2\n    \u03b8_opt, *_ = np.linalg.lstsq(M, ln_y, rcond=None)\n    # Return fitted parameters \u03b80\u2026\u03b85\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict validation loss L given:\n      data_points: array-like of shape (N,2) [num_experts E, dense_param_count P]\n      params:      array-like of length 6 [\u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85]\n\n    Model in log\u2010space:\n      ln L = \u03b80\n           + \u03b81\u00b7ln(P)\n           + \u03b82\u00b7ln(E)\n           + \u03b83\u00b7[ln(P) * ln(E)]\n           + \u03b84\u00b7(1/P)\n           + \u03b85\u00b7[1/(P\u00b7E)]\n\n    Returns:\n      preds: ndarray of shape (N,) with predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invP = 1.0 / P\n    invPE = invP / E  # 1/(P\u00b7E)\n\n    \u03b8 = np.asarray(params, dtype=float).ravel()\n    if \u03b8.size != 6:\n        raise ValueError(f\"Expected 6 parameters, got {\u03b8.size}\")\n    \u03b80, \u03b81, \u03b82, \u03b83, \u03b84, \u03b85 = \u03b8\n\n    lnL = (\n        \u03b80\n        + \u03b81 * lnP\n        + \u03b82 * lnE\n        + \u03b83 * (lnP * lnE)\n        + \u03b84 * invP\n        + \u03b85 * invPE\n    )\n    return np.exp(lnL)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 6-parameter model by ordinary least squares on ln(loss):\n      ln(y) \u2248 \u03b80\u00b71 + \u03b81\u00b7ln(P) + \u03b82\u00b7ln(E) + \u03b83\u00b7[ln(P)\u00b7ln(E)]\n                       + \u03b84\u00b7(1/P) + \u03b85\u00b7[1/(P\u00b7E)]\n\n    Returns:\n      \u03b8_opt: ndarray of shape (6,) with the fitted parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 2:\n        raise ValueError(f\"data_points must have shape (N,2), got {X.shape}\")\n    y = np.asarray(loss_values, dtype=float).ravel()\n    if y.shape[0] != X.shape[0]:\n        raise ValueError(\"loss_values must have the same number of rows as data_points\")\n\n    # Avoid log(0) or negative\n    y_safe = np.clip(y, 1e-8, None)\n    lnY = np.log(y_safe)\n\n    E = np.clip(X[:, 0], 1e-8, None)\n    P = np.clip(X[:, 1], 1e-8, None)\n    lnE = np.log(E)\n    lnP = np.log(P)\n    invP = 1.0 / P\n    invPE = invP / E\n\n    # Design matrix: [1, lnP, lnE, lnP\u00b7lnE, 1/P, 1/(P\u00b7E)]\n    M = np.column_stack([\n        np.ones_like(lnP),\n        lnP,\n        lnE,\n        lnP * lnE,\n        invP,\n        invPE\n    ])\n\n    \u03b8_opt, *_ = np.linalg.lstsq(M, lnY, rcond=None)\n    return \u03b8_opt\n# EVOLVE-BLOCK-END\n```"]}}}