{"id": "c2876b15-35a9-480c-b057-8d53214cc20f", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced with a global mixture\u2010entropy feature for cross\u2010domain interactions.\nTotal parameters = 5\u00d75 (linear weights) + 5 (entropy weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      h = \u2212\u2211_i x_i \u00b7 log(x_i + \u03b5)    # mixture\u2010entropy feature (N,1)\n      y_j = \u2211_i W[i,j]\u00b7x_i + c[j]\u00b7h + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W, a (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 c, entropy\u2010feature weights (5,)\n                - last 5 entries   \u2192 b, bias vector (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # (5,5)\n    c = p[25:30].reshape(1, 5)    # (1,5)\n    b = p[30:35].reshape(1, 5)    # (1,5)\n\n    # mixture\u2010entropy feature: h = -sum_i x_i * log(x_i + eps)\n    eps = 1e-12\n    X_clip = np.clip(X, eps, 1.0)               # avoid log(0)\n    h = -np.sum(X_clip * np.log(X_clip), axis=1, keepdims=True)  # (N,1)\n\n    # prediction: linear + entropy\u2010feature + bias\n    preds = X.dot(W) + h.dot(c) + b             # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + entropy\u2010feature scaling law via closed-form ridge\u2010LS.\n\n    Design matrix D = [X | h | 1], with h = mixture entropy feature.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel(), c, b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape ({N},5), got {Y.shape}\")\n\n    # compute mixture\u2010entropy feature h\n    eps = 1e-12\n    X_clip = np.clip(X, eps, 1.0)\n    h = -np.sum(X_clip * np.log(X_clip), axis=1, keepdims=True)  # (N,1)\n\n    # build design matrix: [X | h | ones]\n    D = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # ridge\u2010regularized normal equations\n    lam = 1e-6\n    M = D.shape[1]  # 7\n    A = D.T.dot(D) + lam * np.eye(M)        # (7,7)\n    B = D.T.dot(Y)                          # (7,5)\n\n    Theta = np.linalg.solve(A, B)           # (7,5)\n\n    # unpack into parameters\n    W = Theta[:5, :].reshape(-1)           # 25 entries\n    c = Theta[5:6, :].ravel()              # 5 entries\n    b = Theta[6:7, :].ravel()              # 5 entries\n\n    params = np.concatenate([W, c, b])     # (35,)\n    return params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "d438a05e-c244-4ee9-8fef-437dceed66c1", "generation": 3, "timestamp": 1754716869.5081854, "iteration_found": 41, "metrics": {"nmse": 0.018551240470076728, "nmae": 0.12687717938271606, "r2": 0.9814487595299233, "combined_score": 0.9817866399519428}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.004423948501471063, "nmae": 0.06143018790916058, "r2": 0.9955760514985289, "combined_score": 0.9955955366177088}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0044\n- nmae: 0.0614\n- r2: 0.9956\n- combined_score: 0.9956\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: r2, combined_score. Consider continuing with similar changes.\n- Metrics showing regression: nmse, nmae. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0169, nmae: 0.1317, r2: 0.9831, combined_score: 0.9834\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0044, nmae: 0.0614, r2: 0.9956, combined_score: 0.9956\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5143)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced with a simple nonlinearity: per-domain squared-proportion term.\nTotal parameters = 5\u00d75 (linear weights) + 5 (squared weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 v (5,) squared-term weights\n                - last 5 entries   \u2192 b (5,) bias vector\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)         # (5,5)\n    v = p[25:30].reshape(1, 5)       # (1,5)\n    b = p[30:35].reshape(1, 5)       # (1,5)\n\n    # compute prediction: linear + squared-term + bias\n    preds = X.dot(W) + (X**2) * v + b  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced affine + per-domain squared scaling law via ridge\u2010regularized OLS.\n\n    For each output domain j:\n      y_j \u2248 [X, X[:,j]^2, 1] @ theta_j\n      theta_j = [W[:,j], v_j, b_j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    lam = 1e-6  # small ridge for stability\n\n    # containers for parameters\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # Solve each output dimension separately\n    for j in range(5):\n        yj = Y[:, j]                          # (N,)\n        xj_sq = (X[:, j] ** 2).reshape(N, 1)  # (N,1)\n        # design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] => (N\u00d77)\n        D = np.concatenate([X, xj_sq, np.ones((N, 1), dtype=float)], axis=1)\n        # normal equations with ridge: (7\u00d77)\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(yj)\n        theta_j = np.linalg.solve(A, B)       # (7,)\n\n        # unpack\n        W[:, j] = theta_j[:5]\n        v[j]    = theta_j[5]\n        b[j]    = theta_j[6]\n\n    # flatten into params: [W.ravel(), v, b]\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0044), Performs well on nmae (0.0614), Performs well on r2 (0.9956), Performs well on combined_score (0.9956)\n\n\n### Program 2 (Score: 0.5288)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced affine+nonlinear model:\n  - Linear term: W\u00b7p + b  (25 + 5 = 30 params)\n  - Nonlinear term: \u03b1\u00b7log(p + \u03b5), broadcast to all outputs (5 params)\nTotal parameters = 35 \u2264 35.\n\nWe fit an initial ridge\u2010regularized least squares for (W,b), then refine\nall 35 parameters (W, b, \u03b1) via L-BFGS-B to minimize MSE + small \u03b1\u2010regularizer.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W matrix of shape (5,5)\n                - next 5 entries  \u2192 bias vector b of shape (5,)\n                - last 5 entries  \u2192 nonlinear weights \u03b1 of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # (5 inputs \u2192 5 outputs)\n    b = p[25:30].reshape(1, 5)    # (1 \u00d7 5)\n    alpha = p[30:35].reshape(5,)  # (5,)\n\n    # linear prediction\n    preds = X.dot(W) + b          # (N,5)\n\n    # nonlinear entropy\u2010like feature\n    eps = 1e-8\n    logX = np.log(np.clip(X, eps, None))  # avoid log(0)\n    nonlin = logX.dot(alpha).reshape(N, 1)  # (N,1)\n\n    preds += nonlin               # broadcast to (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine+nonlinear scaling law.\n\n    Steps:\n      1. Fit (W,b) via ridge\u2010regularized least squares.\n      2. Initialize \u03b1=0.\n      3. Refine all parameters with L-BFGS-B to minimize MSE + small \u03b1\u2010reg.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel(), b, \u03b1).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # 1) Ridge LS for W,b\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n    Theta = np.linalg.solve(A, B)                 # (6,5)\n    W0 = Theta[:5, :]                             # (5,5)\n    b0 = Theta[5, :].reshape(5,)                  # (5,)\n\n    # 2) initialize nonlinear weights \u03b1 to zero\n    alpha0 = np.zeros(5,)\n\n    # pack initial parameters\n    init_params = np.concatenate([W0.ravel(), b0, alpha0])\n\n    # 3) refine via L-BFGS-B minimizing MSE + small \u03b1\u2010regularizer\n    def objective(p):\n        P = scaling_law_func(X, p)\n        err = P - Y\n        mse = np.mean(err * err)\n        # regularize \u03b1 lightly to prevent over\u2010emphasis\n        alpha = p[30:35]\n        reg = 1e-4 * np.sum(alpha * alpha)\n        return mse + reg\n\n    try:\n        res = minimize(objective,\n                       init_params,\n                       method='L-BFGS-B',\n                       options={'maxiter': 500, 'disp': False})\n        params_opt = res.x\n    except Exception:\n        # fallback to initial if optimization fails\n        params_opt = init_params\n\n    return params_opt\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0169), Performs well on nmae (0.1317), Performs well on r2 (0.9831), Performs well on combined_score (0.9834)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5275)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear+quadratic mixture\u2010of\u2010experts model:\neach output loss is predicted by an affine combination of domain proportions\nplus a small quadratic correction term based on the sum of squared proportions.\nTotal parameters = 5\u00d75 (linear weights) + 5 (quadratic coefficients) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 linear weight matrix W of shape (5,5)\n                     - next 5 entries  \u2192 quadratic coefficients q of shape (5,)\n                     - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)       # linear weights\n    q = p[25:30].reshape(5,)       # quadratic coefficients\n    b = p[30:35].reshape(5,)       # biases\n\n    # linear term\n    lin_term = X.dot(W)            # (N,5)\n    # quadratic correction: use sum of squares of proportions\n    sumsq = np.sum(X * X, axis=1)  # (N,)\n    quad_term = np.outer(sumsq, q) # (N,5)\n\n    # final prediction\n    preds = lin_term + quad_term + b[None, :]\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear+quadratic mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 linear weights + 5 quadratic + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # build design matrix with linear features, quadratic sum, and bias\n    sumsq = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n    ones  = np.ones((N, 1), dtype=float)          # (N,1)\n    X_aug = np.concatenate([X, sumsq, ones], axis=1)  # (N, 7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    D = X_aug.shape[1]  # 7 features\n    # normal equations: (X_aug^T X_aug + \u03bbI) \u0398 = X_aug^T Y\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)    # (7,7)\n    B = X_aug.T.dot(Y)                          # (7,5)\n\n    # solve for Theta\n    Theta = np.linalg.solve(A, B)               # (7,5)\n\n    # unpack into parameters\n    W = Theta[:5, :].reshape(-1)      # 5\u00d75 = 25 entries\n    q = Theta[5, :].reshape(-1)       # 5 entries\n    b = Theta[6, :].reshape(-1)       # 5 entries\n\n    # flatten and return\n    params = np.concatenate([W, q, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5297)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a simple affine model: y = X W + b.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    \n    p = np.asarray(params).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # (5,5)\n    b = p[25:].reshape(1, 5)   # (1,5)\n    \n    # affine prediction\n    preds = X.dot(W) + b       # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law y = X W + b via ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_points (N,5) and loss_values (N,5), got {X.shape}, {Y.shape}\")\n    \n    # augment inputs with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    \n    # ridge regularization (for numerical stability)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)          # (6,6)\n    B = X_aug.T.dot(Y)                                    # (6,5)\n    \n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                        # (6,5)\n    \n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F:, :].ravel()  # (5,)\n    \n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5275, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a linear term plus a global squared-proportion concentration term.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - next 5 entries  \u2192 alpha vector of shape (5,)\n                - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W     = p[:25].reshape(5, 5)   # linear weights\n    alpha = p[25:30].reshape(1, 5) # concentration weights\n    b     = p[30:35].reshape(1, 5) # biases\n\n    # global concentration feature: sum of squared proportions\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # affine + concentration\n    preds = X.dot(W) + sq_sum.dot(alpha) + b       # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law via ridge\u2010regularized linear regression (closed\u2010form).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 weights + 5 concentration + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points (N,5) and loss_values (N,5)\")\n\n    # build the global concentration feature\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)             # (N,1)\n\n    # design matrix: [X | sq_sum | 1]\n    X_aug = np.concatenate([X, sq_sum, np.ones((N, 1))], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(X_aug.shape[1])         # (7,7)\n    B = X_aug.T.dot(Y)                                            # (7,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                                # (7,5)\n\n    # unpack parameters\n    W     = Theta[:5, :]             # (5,5)\n    alpha = Theta[5:6, :].ravel()    # (5,)\n    b     = Theta[6:7, :].ravel()    # (5,)\n\n    # flatten into single 35-length vector\n    params = np.concatenate([W.ravel(), alpha, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5275, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear+quadratic mixture\u2010of\u2010experts model:\neach output loss is predicted by an affine combination of domain proportions\nplus a small quadratic correction term based on the sum of squared proportions.\nTotal parameters = 5\u00d75 (linear weights) + 5 (quadratic coefficients) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 linear weight matrix W of shape (5,5)\n                     - next 5 entries  \u2192 quadratic coefficients q of shape (5,)\n                     - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)       # linear weights\n    q = p[25:30].reshape(5,)       # quadratic coefficients\n    b = p[30:35].reshape(5,)       # biases\n\n    # linear term\n    lin_term = X.dot(W)            # (N,5)\n    # quadratic correction: use sum of squares of proportions\n    sumsq = np.sum(X * X, axis=1)  # (N,)\n    quad_term = np.outer(sumsq, q) # (N,5)\n\n    # final prediction\n    preds = lin_term + quad_term + b[None, :]\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear+quadratic mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 linear weights + 5 quadratic + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # build design matrix with linear features, quadratic sum, and bias\n    sumsq = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n    ones  = np.ones((N, 1), dtype=float)          # (N,1)\n    X_aug = np.concatenate([X, sumsq, ones], axis=1)  # (N, 7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    D = X_aug.shape[1]  # 7 features\n    # normal equations: (X_aug^T X_aug + \u03bbI) \u0398 = X_aug^T Y\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)    # (7,7)\n    B = X_aug.T.dot(Y)                          # (7,5)\n\n    # solve for Theta\n    Theta = np.linalg.solve(A, B)               # (7,5)\n\n    # unpack into parameters\n    W = Theta[:5, :].reshape(-1)      # 5\u00d75 = 25 entries\n    q = Theta[5, :].reshape(-1)       # 5 entries\n    b = Theta[6, :].reshape(-1)       # 5 entries\n\n    # flatten and return\n    params = np.concatenate([W, q, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5297, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a simple affine model: y = X W + b.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    \n    p = np.asarray(params).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # (5,5)\n    b = p[25:].reshape(1, 5)   # (1,5)\n    \n    # affine prediction\n    preds = X.dot(W) + b       # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law y = X W + b via ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_points (N,5) and loss_values (N,5), got {X.shape}, {Y.shape}\")\n    \n    # augment inputs with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    \n    # ridge regularization (for numerical stability)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)          # (6,6)\n    B = X_aug.T.dot(Y)                                    # (6,5)\n    \n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                        # (6,5)\n    \n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F:, :].ravel()  # (5,)\n    \n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5288, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced affine+nonlinear model:\n  - Linear term: W\u00b7p + b  (25 + 5 = 30 params)\n  - Nonlinear term: \u03b1\u00b7log(p + \u03b5), broadcast to all outputs (5 params)\nTotal parameters = 35 \u2264 35.\n\nWe fit an initial ridge\u2010regularized least squares for (W,b), then refine\nall 35 parameters (W, b, \u03b1) via L-BFGS-B to minimize MSE + small \u03b1\u2010regularizer.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W matrix of shape (5,5)\n                - next 5 entries  \u2192 bias vector b of shape (5,)\n                - last 5 entries  \u2192 nonlinear weights \u03b1 of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # (5 inputs \u2192 5 outputs)\n    b = p[25:30].reshape(1, 5)    # (1 \u00d7 5)\n    alpha = p[30:35].reshape(5,)  # (5,)\n\n    # linear prediction\n    preds = X.dot(W) + b          # (N,5)\n\n    # nonlinear entropy\u2010like feature\n    eps = 1e-8\n    logX = np.log(np.clip(X, eps, None))  # avoid log(0)\n    nonlin = logX.dot(alpha).reshape(N, 1)  # (N,1)\n\n    preds += nonlin               # broadcast to (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine+nonlinear scaling law.\n\n    Steps:\n      1. Fit (W,b) via ridge\u2010regularized least squares.\n      2. Initialize \u03b1=0.\n      3. Refine all parameters with L-BFGS-B to minimize MSE + small \u03b1\u2010reg.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel(), b, \u03b1).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # 1) Ridge LS for W,b\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n    Theta = np.linalg.solve(A, B)                 # (6,5)\n    W0 = Theta[:5, :]                             # (5,5)\n    b0 = Theta[5, :].reshape(5,)                  # (5,)\n\n    # 2) initialize nonlinear weights \u03b1 to zero\n    alpha0 = np.zeros(5,)\n\n    # pack initial parameters\n    init_params = np.concatenate([W0.ravel(), b0, alpha0])\n\n    # 3) refine via L-BFGS-B minimizing MSE + small \u03b1\u2010regularizer\n    def objective(p):\n        P = scaling_law_func(X, p)\n        err = P - Y\n        mse = np.mean(err * err)\n        # regularize \u03b1 lightly to prevent over\u2010emphasis\n        alpha = p[30:35]\n        reg = 1e-4 * np.sum(alpha * alpha)\n        return mse + reg\n\n    try:\n        res = minimize(objective,\n                       init_params,\n                       method='L-BFGS-B',\n                       options={'maxiter': 500, 'disp': False})\n        params_opt = res.x\n    except Exception:\n        # fallback to initial if optimization fails\n        params_opt = init_params\n\n    return params_opt\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced with a simple nonlinearity: per-domain squared-proportion term.\nTotal parameters = 5\u00d75 (linear weights) + 5 (squared weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 v (5,) squared-term weights\n                - last 5 entries   \u2192 b (5,) bias vector\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)         # (5,5)\n    v = p[25:30].reshape(1, 5)       # (1,5)\n    b = p[30:35].reshape(1, 5)       # (1,5)\n\n    # compute prediction: linear + squared-term + bias\n    preds = X.dot(W) + (X**2) * v + b  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced affine + per-domain squared scaling law via ridge\u2010regularized OLS.\n\n    For each output domain j:\n      y_j \u2248 [X, X[:,j]^2, 1] @ theta_j\n      theta_j = [W[:,j], v_j, b_j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    lam = 1e-6  # small ridge for stability\n\n    # containers for parameters\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # Solve each output dimension separately\n    for j in range(5):\n        yj = Y[:, j]                          # (N,)\n        xj_sq = (X[:, j] ** 2).reshape(N, 1)  # (N,1)\n        # design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] => (N\u00d77)\n        D = np.concatenate([X, xj_sq, np.ones((N, 1), dtype=float)], axis=1)\n        # normal equations with ridge: (7\u00d77)\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(yj)\n        theta_j = np.linalg.solve(A, B)       # (7,)\n\n        # unpack\n        W[:, j] = theta_j[:5]\n        v[j]    = theta_j[5]\n        b[j]    = theta_j[6]\n\n    # flatten into params: [W.ravel(), v, b]\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced with a global mixture\u2010entropy feature for cross\u2010domain interactions.\nTotal parameters = 5\u00d75 (linear weights) + 5 (entropy weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      h = \u2212\u2211_i x_i \u00b7 log(x_i + \u03b5)    # mixture\u2010entropy feature (N,1)\n      y_j = \u2211_i W[i,j]\u00b7x_i + c[j]\u00b7h + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W, a (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 c, entropy\u2010feature weights (5,)\n                - last 5 entries   \u2192 b, bias vector (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # (5,5)\n    c = p[25:30].reshape(1, 5)    # (1,5)\n    b = p[30:35].reshape(1, 5)    # (1,5)\n\n    # mixture\u2010entropy feature: h = -sum_i x_i * log(x_i + eps)\n    eps = 1e-12\n    X_clip = np.clip(X, eps, 1.0)               # avoid log(0)\n    h = -np.sum(X_clip * np.log(X_clip), axis=1, keepdims=True)  # (N,1)\n\n    # prediction: linear + entropy\u2010feature + bias\n    preds = X.dot(W) + h.dot(c) + b             # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + entropy\u2010feature scaling law via closed-form ridge\u2010LS.\n\n    Design matrix D = [X | h | 1], with h = mixture entropy feature.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel(), c, b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape ({N},5), got {Y.shape}\")\n\n    # compute mixture\u2010entropy feature h\n    eps = 1e-12\n    X_clip = np.clip(X, eps, 1.0)\n    h = -np.sum(X_clip * np.log(X_clip), axis=1, keepdims=True)  # (N,1)\n\n    # build design matrix: [X | h | ones]\n    D = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # ridge\u2010regularized normal equations\n    lam = 1e-6\n    M = D.shape[1]  # 7\n    A = D.T.dot(D) + lam * np.eye(M)        # (7,7)\n    B = D.T.dot(Y)                          # (7,5)\n\n    Theta = np.linalg.solve(A, B)           # (7,5)\n\n    # unpack into parameters\n    W = Theta[:5, :].reshape(-1)           # 25 entries\n    c = Theta[5:6, :].ravel()              # 5 entries\n    b = Theta[6:7, :].ravel()              # 5 entries\n\n    params = np.concatenate([W, c, b])     # (35,)\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\nExplanation of the improvements:\n- Introduced a global \u201cmixture\u2010entropy\u201d feature h = \u2212\u2211 x_i log(x_i) that captures cross\u2010domain interactions and dataset heterogeneity in a single scalar per mixture.\n- Kept the parameter count at exactly 35: a 5\u00d75 linear weight matrix W, a 5\u2010vector c for the entropy feature, and a 5\u2010vector b for biases.\n- Fitted all parameters in closed\u2010form via a single ridge\u2010regularized least\u2010squares solve over the design matrix [X | h | 1], ensuring numerical stability and efficiency.\n- Avoided any input\u2010dependent aggregates (min/max) beyond the entropy feature and maintained theoretical stability (small epsilon for log)."]}}}