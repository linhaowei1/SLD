{"id": "bc601efa-9d91-405e-a22b-abe69b40c266", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced affine + per-domain squared-proportion model.\nTotal parameters = 5\u00d75 (linear weights) + 5 (per-domain squared weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 W matrix of shape (5,5)\n                     - next 5 entries   \u2192 v vector of shape (5,)\n                     - last 5 entries   \u2192 b vector of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be shape (N,5), got {X.shape}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"params must be length 35, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # linear weights\n    v = p[25:30].reshape(1, 5)    # per-domain squared coefficient\n    b = p[30:35].reshape(1, 5)    # biases\n\n    # compute predictions: linear term + per-domain squared term + bias\n    # (X @ W): (N,5), (X**2)*v: (N,5)\n    return X.dot(W) + (X**2)*v + b\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + per-domain squared-proportion scaling law.\n\n    Solves for each output dimension j independently:\n      y_j \u2248 [X, (x_j)^2, 1] @ theta_j,\n    where theta_j = [W[:,j], v_j, b_j].\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must match data_points shape {X.shape}, got {Y.shape}\")\n\n    N = X.shape[0]\n    lam = 1e-6  # small ridge for stability\n\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    for j in range(5):\n        # squared feature for domain j\n        xj_sq = (X[:, j]**2).reshape(N, 1)\n        # design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] \u2192 (N\u00d77)\n        D = np.hstack([X, xj_sq, np.ones((N, 1), dtype=float)])\n        # normal equations with ridge: (D^T D + lam I) \u03b8 = D^T y\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(Y[:, j])\n        theta = np.linalg.solve(A, B)  # shape (7,)\n\n        # unpack \u03b8 into W[:,j], v[j], b[j]\n        W[:, j] = theta[:5]\n        v[j]    = theta[5]\n        b[j]    = theta[6]\n\n    # flatten parameters: [W.ravel(), v, b]\n    return np.concatenate([W.ravel(), v, b])\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "c2dff2a8-7446-4af4-95a9-34823477d098", "generation": 2, "timestamp": 1754716885.9656692, "iteration_found": 48, "metrics": {"nmse": 0.004423948501471063, "nmae": 0.06143018790916058, "r2": 0.9955760514985289, "combined_score": 0.9955955366177088}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.018360804339811472, "nmae": 0.13690427617636788, "r2": 0.9816391956601885, "combined_score": 0.9819702366179396}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0184\n- nmae: 0.1369\n- r2: 0.9816\n- combined_score: 0.9820\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0044, nmae: 0.0614, r2: 0.9956, combined_score: 0.9956\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0044, nmae: 0.0614, r2: 0.9956, combined_score: 0.9956\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5143)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 v (5,) squared\u2010term weights\n                - last 5 entries   \u2192 b (5,) bias vector\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)         # linear weights, shape (5,5)\n    v = p[25:30].reshape(1, 5)       # per\u2010domain squared weights, shape (1,5)\n    b = p[30:35].reshape(1, 5)       # biases, shape (1,5)\n\n    # compute prediction: affine + per\u2010domain squared term\n    # X.dot(W) produces (N,5), (X**2)*v also (N,5), plus b\n    preds = X.dot(W) + (X**2) * v + b\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced affine + per\u2010domain squared scaling law via ridge\u2010regularized OLS.\n\n    For each output domain j:\n      y_j \u2248 [X, X[:,j]^2, 1] @ theta_j\n      theta_j = [W[:,j], v_j, b_j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected shapes (N,5) for both inputs and outputs; got {X.shape} and {Y.shape}\")\n\n    lam = 1e-6  # small ridge for numerical stability\n\n    # containers for parameters\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # Solve separately for each output dimension j\n    for j in range(5):\n        yj = Y[:, j]                          # target vector, shape (N,)\n        xj_sq = (X[:, j] ** 2).reshape(N, 1)  # squared feature for domain j, shape (N,1)\n        # build design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] => (N\u00d77)\n        D = np.concatenate([X, xj_sq, np.ones((N, 1), dtype=float)], axis=1)\n        # normal equations with ridge: (D^T D + lam I) theta = D^T y\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(yj)\n        theta_j = np.linalg.solve(A, B)       # solves shape (7,)\n\n        # unpack fitted parameters\n        W[:, j] = theta_j[:5]\n        v[j]    = theta_j[5]\n        b[j]    = theta_j[6]\n\n    # flatten into single param vector: [W.ravel(), v, b]\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0044), Performs well on nmae (0.0614), Performs well on r2 (0.9956), Performs well on combined_score (0.9956)\n\n\n### Program 2 (Score: 0.5143)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced affine + per-domain squared\u2010proportion model.\nTotal parameters = 5\u00d75 (linear weights) + 5 (squared\u2010term weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W matrix of shape (5,5)\n                - next 5 entries   \u2192 v vector of shape (5,)\n                - last 5 entries   \u2192 b vector of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each domain.\n    \"\"\"\n    # ensure numpy arrays and correct shapes\n    X = np.asarray(data_points, dtype=float)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 features, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # linear weights\n    v = p[25:30].reshape(1, 5)    # squared\u2010term weights\n    b = p[30:35].reshape(1, 5)    # biases\n    # compute prediction\n    # linear part + per\u2010domain squared correction + bias\n    preds = X.dot(W) + (X**2) * v + b\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + per\u2010domain squared scaling law via ridge\u2010regularized least squares.\n\n    For each output domain j we solve:\n      y_j \u2248 [X, (x_j)^2, 1] @ theta_j\n      theta_j = [W[:,j], v_j, b_j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # small ridge term for numerical stability\n    lam = 1e-6\n\n    # containers for parameters\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # solve each output dimension independently\n    for j in range(5):\n        # design matrix: [X (N\u00d75), X[:,j]**2 (N\u00d71), 1s (N\u00d71)] => (N\u00d77)\n        xj_sq = (X[:, j] ** 2).reshape(N, 1)\n        D = np.hstack((X, xj_sq, np.ones((N, 1), dtype=float)))  # (N,7)\n        # normal equations with ridge\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(Y[:, j])\n        theta = np.linalg.solve(A, B)   # (7,)\n        # unpack parameters for domain j\n        W[:, j] = theta[:5]\n        v[j]    = theta[5]\n        b[j]    = theta[6]\n\n    # concatenate into single parameter vector\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0044), Performs well on nmae (0.0614), Performs well on r2 (0.9956), Performs well on combined_score (0.9956)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30, interpreted as a (6\u00d75) matrix:\n                - first 5 rows: weight matrix (5 weights per output)\n                - last 1 row:  bias vector (1 bias per output)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    # reshape params into theta of shape (6,5)\n    theta = np.asarray(params, dtype=float).ravel()\n    assert theta.size == 30, f\"Expected 30 parameters, got {theta.size}\"\n    theta = theta.reshape(6, 5)  # (5 weights + 1 bias) for each of 5 outputs\n\n    # augment inputs with a bias feature of 1s\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # compute predictions\n    preds = X_aug.dot(theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (6\u00d75 matrix flattened).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # solve for theta in A @ theta = B\n    theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # return flattened parameters\n    return theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    \n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 30, f\"params must be length 30, got {p.size}\"\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # linear weights\n    b = p[25:].reshape(1, 5)    # broadcastable bias\n    \n    # affine prediction\n    return X.dot(W) + b         # shape (N,5)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture\u2010of\u2010experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    assert Y.ndim == 2 and Y.shape == X.shape, \\\n        f\"loss_values must have shape {X.shape}, got {Y.shape}\"\n    \n    N = X.shape[0]\n    # augment inputs with constant bias term\n    X_aug = np.hstack([X, np.ones((N, 1), dtype=float)])  # shape (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(6)               # shape (6,6)\n    B = X_aug.T.dot(Y)                                     # shape (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # shape (6,5)\n\n    # unpack into W and b\n    W = Theta[:5, :]                                       # shape (5,5)\n    b = Theta[5, :]                                        # shape (5,)\n\n    # flatten parameters\n    return np.concatenate([W.ravel(), b])\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5143, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W (5\u00d75) linear weight matrix\n                - next 5 entries   \u2192 v (5,) squared\u2010term weights\n                - last 5 entries   \u2192 b (5,) bias vector\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)         # linear weights, shape (5,5)\n    v = p[25:30].reshape(1, 5)       # per\u2010domain squared weights, shape (1,5)\n    b = p[30:35].reshape(1, 5)       # biases, shape (1,5)\n\n    # compute prediction: affine + per\u2010domain squared term\n    # X.dot(W) produces (N,5), (X**2)*v also (N,5), plus b\n    preds = X.dot(W) + (X**2) * v + b\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced affine + per\u2010domain squared scaling law via ridge\u2010regularized OLS.\n\n    For each output domain j:\n      y_j \u2248 [X, X[:,j]^2, 1] @ theta_j\n      theta_j = [W[:,j], v_j, b_j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected shapes (N,5) for both inputs and outputs; got {X.shape} and {Y.shape}\")\n\n    lam = 1e-6  # small ridge for numerical stability\n\n    # containers for parameters\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    # Solve separately for each output dimension j\n    for j in range(5):\n        yj = Y[:, j]                          # target vector, shape (N,)\n        xj_sq = (X[:, j] ** 2).reshape(N, 1)  # squared feature for domain j, shape (N,1)\n        # build design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] => (N\u00d77)\n        D = np.concatenate([X, xj_sq, np.ones((N, 1), dtype=float)], axis=1)\n        # normal equations with ridge: (D^T D + lam I) theta = D^T y\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(yj)\n        theta_j = np.linalg.solve(A, B)       # solves shape (7,)\n\n        # unpack fitted parameters\n        W[:, j] = theta_j[:5]\n        v[j]    = theta_j[5]\n        b[j]    = theta_j[6]\n\n    # flatten into single param vector: [W.ravel(), v, b]\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 49999.7500, Type: High-Performer)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear mixture\u2010of\u2010experts with a squared\u2010proportion concentration feature:\n    y_j = sum_i W[i,j] * p_i  +  alpha[j] * (sum_i p_i^2)  +  b[j]\nTotal parameters = 5\u00d75 (W) + 5 (alpha) + 5 (bias) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a linear term plus a global squared\u2010proportion concentration term.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - next 5 entries  \u2192 alpha vector of shape (5,)\n                - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points), dtype=float)  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 domain proportions, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W     = p[:25].reshape(5, 5)    # linear weights\n    alpha = p[25:30].reshape(1, 5)  # squared\u2010proportion weights\n    b     = p[30:35].reshape(1, 5)  # biases\n\n    # compute the global concentration feature per sample\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # affine + concentration term\n    preds = X.dot(W) + sq_sum * alpha + b          # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law:\n        y = X W + (sum(X^2)) \u03b1 + 1\u00b7b\n    via ridge\u2010regularized linear regression (closed\u2010form).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 weights + 5 alpha + 5 bias).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points), dtype=float)  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values), dtype=float)  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 domain proportions, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values with shape (N,5), got {Y.shape}\"\n\n    # build concentration feature and design matrix\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)           # (N,1)\n    X_aug = np.concatenate([X, sq_sum, np.ones((N, 1))], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 2)            # (7,7)\n    B = X_aug.T.dot(Y)                                       # (7,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                           # (7,5)\n\n    # unpack into parameters\n    # Theta rows 0\u20134: linear weights for p1..p5 \u2192 W (5\u00d75)\n    # Theta row 5:  squared\u2010proportion weights \u2192 alpha (5,)\n    # Theta row 6:  bias terms \u2192 b (5,)\n    W     = Theta[:5, :]                                     # (5,5)\n    alpha = Theta[5, :].reshape(5)                           # (5,)\n    b     = Theta[6, :].reshape(5)                           # (5,)\n\n    # flatten into single parameter vector\n    params = np.concatenate([W.ravel(), alpha, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (100000.000), Excellent nmae (100000.000)\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    \n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 30, f\"params must be length 30, got {p.size}\"\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # linear weights\n    b = p[25:].reshape(1, 5)    # broadcastable bias\n    \n    # affine prediction\n    return X.dot(W) + b         # shape (N,5)\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture\u2010of\u2010experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    assert Y.ndim == 2 and Y.shape == X.shape, \\\n        f\"loss_values must have shape {X.shape}, got {Y.shape}\"\n    \n    N = X.shape[0]\n    # augment inputs with constant bias term\n    X_aug = np.hstack([X, np.ones((N, 1), dtype=float)])  # shape (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(6)               # shape (6,6)\n    B = X_aug.T.dot(Y)                                     # shape (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # shape (6,5)\n\n    # unpack into W and b\n    W = Theta[:5, :]                                       # shape (5,5)\n    b = Theta[5, :]                                        # shape (5,)\n\n    # flatten parameters\n    return np.concatenate([W.ravel(), b])\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5272, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing an entropy\u2010augmented affine model:\neach output loss is a weighted sum of the five domain proportions,\nplus a weight on the mixture entropy, plus a bias.\nTotal parameters = 5\u00d75 (W) + 5 (h for entropy) + 5 (bias) = 35 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - next 5 entries  \u2192 entropy weights h of shape (5,)\n                - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # (5,5)\n    h = p[25:30].reshape(1, 5) # entropy weight per output\n    b = p[30:35].reshape(1, 5) # bias per output\n\n    # compute mixture entropy H = -sum p_i * log(p_i)\n    eps = 1e-12\n    X_safe = np.clip(X, eps, 1.0)\n    H = -np.sum(X_safe * np.log(X_safe), axis=1, keepdims=True)  # (N,1)\n\n    # affine prediction with entropy term\n    preds = X.dot(W) + H.dot(h) + b  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the entropy\u2010augmented affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 h + 5 b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # compute mixture entropy\n    eps = 1e-12\n    X_safe = np.clip(X, eps, 1.0)\n    H = -np.sum(X_safe * np.log(X_safe), axis=1, keepdims=True)  # (N,1)\n\n    # build design matrix [X | H | 1]\n    # X_ext: (N,6), X_ext = [X columns, entropy]\n    X_ext = np.concatenate([X, H], axis=1)      # (N,6)\n    # X_aug: (N,7) add bias feature = 1\n    X_aug = np.concatenate([X_ext, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 2)  # (7,7)\n    B = X_aug.T.dot(Y)                            # (7,5)\n\n    # solve normal equations A @ Theta = B\n    Theta = np.linalg.solve(A, B)  # (7,5)\n\n    # unpack into W, h, b\n    W = Theta[:F, :]       # (5,5)\n    h = Theta[F, :].reshape(5,)  # (5,)\n    b = Theta[F+1, :].reshape(5,)  # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), h, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30, interpreted as a (6\u00d75) matrix:\n                - first 5 rows: weight matrix (5 weights per output)\n                - last 1 row:  bias vector (1 bias per output)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    # reshape params into theta of shape (6,5)\n    theta = np.asarray(params, dtype=float).ravel()\n    assert theta.size == 30, f\"Expected 30 parameters, got {theta.size}\"\n    theta = theta.reshape(6, 5)  # (5 weights + 1 bias) for each of 5 outputs\n\n    # augment inputs with a bias feature of 1s\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # compute predictions\n    preds = X_aug.dot(theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (6\u00d75 matrix flattened).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # solve for theta in A @ theta = B\n    theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # return flattened parameters\n    return theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced affine + per-domain squared-proportion model.\nTotal parameters = 5\u00d75 (linear weights) + 5 (per-domain squared weights) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model:\n      y_j = sum_i W[i,j] * x_i + v[j] * (x_j)^2 + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 W matrix of shape (5,5)\n                     - next 5 entries   \u2192 v vector of shape (5,)\n                     - last 5 entries   \u2192 b vector of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be shape (N,5), got {X.shape}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"params must be length 35, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # linear weights\n    v = p[25:30].reshape(1, 5)    # per-domain squared coefficient\n    b = p[30:35].reshape(1, 5)    # biases\n\n    # compute predictions: linear term + per-domain squared term + bias\n    # (X @ W): (N,5), (X**2)*v: (N,5)\n    return X.dot(W) + (X**2)*v + b\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + per-domain squared-proportion scaling law.\n\n    Solves for each output dimension j independently:\n      y_j \u2248 [X, (x_j)^2, 1] @ theta_j,\n    where theta_j = [W[:,j], v_j, b_j].\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 v + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must match data_points shape {X.shape}, got {Y.shape}\")\n\n    N = X.shape[0]\n    lam = 1e-6  # small ridge for stability\n\n    W = np.zeros((5, 5), dtype=float)\n    v = np.zeros(5, dtype=float)\n    b = np.zeros(5, dtype=float)\n\n    for j in range(5):\n        # squared feature for domain j\n        xj_sq = (X[:, j]**2).reshape(N, 1)\n        # design matrix: [X (N\u00d75), xj_sq (N\u00d71), ones (N\u00d71)] \u2192 (N\u00d77)\n        D = np.hstack([X, xj_sq, np.ones((N, 1), dtype=float)])\n        # normal equations with ridge: (D^T D + lam I) \u03b8 = D^T y\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(Y[:, j])\n        theta = np.linalg.solve(A, B)  # shape (7,)\n\n        # unpack \u03b8 into W[:,j], v[j], b[j]\n        W[:, j] = theta[:5]\n        v[j]    = theta[5]\n        b[j]    = theta[6]\n\n    # flatten parameters: [W.ravel(), v, b]\n    return np.concatenate([W.ravel(), v, b])\n\n# EVOLVE-BLOCK-END\n```\n\nExplanation of Improvements:\n- Introduced a per-domain squared\u2010proportion term `v[j] * (x_j)^2` to capture nonlinear scaling effects.\n- Kept parameter count at 35 (\u226435) for efficiency.\n- Used ridge\u2010regularized closed\u2010form solves for numerical stability.\n- Cleanly unpacked and repacked parameters with explicit shape checks for maintainability."]}}}