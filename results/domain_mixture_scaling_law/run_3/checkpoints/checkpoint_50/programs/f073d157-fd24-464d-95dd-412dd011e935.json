{"id": "f073d157-fd24-464d-95dd-412dd011e935", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a hybrid linear + log\u2010feature mixture\u2010of\u2010experts model:\n  preds_j = X @ W_lin[:,j]  +  w_log[j] * log(X[:,j] + \u03b5)  +  b[j]\nTotal parameters = 5\u00d75 (W_lin) + 5 (w_log) + 5 (b) = 35 \u2264 35.\nFitting is done in closed form with ridge regularization for stability.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a combination of linear and per-domain log features.\n\n    preds_{n,j} = sum_i X[n,i] * W_lin[i,j]\n                + w_log[j] * log(X[n,j] + eps)\n                + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain mixture proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 W_lin of shape (5,5)\n                     - next 5 entries   \u2192 w_log of shape (5,)\n                     - last 5 entries   \u2192 b      of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack\n    W_lin = p[:25].reshape(5, 5)     # linear weights\n    w_log = p[25:30].reshape(5,)     # log-feature weights\n    b     = p[30:35].reshape(1, 5)   # biases\n\n    # linear part\n    out_lin = X.dot(W_lin)           # shape (N,5)\n\n    # log part (per-domain)\n    eps = 1e-8\n    X_log = np.log(X + eps)          # shape (N,5)\n    out_log = X_log * w_log          # broadcasts (N,5)\n\n    preds = out_lin + out_log + b    # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the hybrid linear+log scaling law by solving 5 separate\n    ridge\u2010regularized least squares problems (one per output domain).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W_lin + 5 w_log + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must have shape {X.shape}, got {Y.shape}\")\n\n    N = X.shape[0]\n    eps = 1e-8\n    X_log = np.log(X + eps)           # (N,5)\n\n    # We'll fit each output j separately:\n    W_lin = np.zeros((5, 5), dtype=float)\n    w_log = np.zeros(5, dtype=float)\n    b_vec = np.zeros(5, dtype=float)\n\n    lam = 1e-6  # ridge regularization strength\n    # Prepare identity for ridge\n    # For each j, design matrix has 7 cols: [X[:,0..4], X_log[:,j], 1]\n    I7 = np.eye(7, dtype=float)\n\n    for j in range(5):\n        # Build design matrix for target j\n        # features: X (5 cols), X_log[:,j] (1 col), ones (1 col) \u2192 total 7\n        Xj = np.concatenate([\n            X,                          # (N,5)\n            X_log[:, j:j+1],            # (N,1)\n            np.ones((N, 1), dtype=float)# (N,1)\n        ], axis=1)  # shape (N,7)\n\n        yj = Y[:, j]  # shape (N,)\n\n        # Solve (Xj^T Xj + lam I) \u03b8 = Xj^T yj\n        A = Xj.T.dot(Xj) + lam * I7    # (7,7)\n        B = Xj.T.dot(yj)               # (7,)\n        theta_j = np.linalg.solve(A, B)  # (7,)\n\n        # Unpack\n        W_lin[:, j] = theta_j[0:5]\n        w_log[j]    = theta_j[5]\n        b_vec[j]    = theta_j[6]\n\n    # Flatten into parameter vector\n    params = np.concatenate([W_lin.ravel(), w_log, b_vec])\n    return params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "87bfc6fb-1d2b-4fc8-a6f0-10d5b02ce992", "generation": 3, "timestamp": 1754716898.7103732, "iteration_found": 47, "metrics": {"nmse": 0.000962920550825221, "nmae": 0.029535850443277008, "r2": 0.9990370794491747, "combined_score": 0.9990380057731856}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.01836112494290206, "nmae": 0.13690565066259447, "r2": 0.9816388750570979, "combined_score": 0.9819699274715229}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0184\n- nmae: 0.1369\n- r2: 0.9816\n- combined_score: 0.9820\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0111, nmae: 0.1067, r2: 0.9889, combined_score: 0.9890\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5239)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient log\u2010linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the logarithm of the five\ndomain proportions. Total parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a log\u2010linear mapping:\n      preds = log(X + \u03b5) @ W + b\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    # numerical stability for log(0)\n    eps = 1e-8\n    X_log = np.log(X + eps)            # (N,5)\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # weight matrix (5\u21925)\n    b = p[25:].reshape(1, 5)   # bias vector\n\n    # affine prediction on log\u2010inputs\n    preds = X_log.dot(W) + b   # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the log\u2010linear mixture\u2010of\u2010experts scaling law via least squares.\n\n    We solve for W and b in\n      log(X + \u03b5)\u00b7W + 1\u00b7b = Y\n    in closed form using NumPy's least-squares solver.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must have shape {X.shape}, got {Y.shape}\")\n\n    # log\u2010transform with small epsilon to avoid log(0)\n    eps = 1e-8\n    X_log = np.log(X + eps)           # (N,5)\n    N = X_log.shape[0]\n\n    # augment with bias column\n    ones = np.ones((N, 1), dtype=float)\n    X_aug = np.hstack([X_log, ones])  # (N,6)\n\n    # solve multi\u2010output least squares: X_aug @ Theta = Y\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)  # Theta: (6,5)\n\n    # unpack into W and b\n    W = Theta[:5, :]                # (5,5)\n    b = Theta[5:, :].reshape(5,)    # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0111), Performs well on nmae (0.1067), Performs well on r2 (0.9889), Performs well on combined_score (0.9890)\n\n\n### Program 2 (Score: 0.5297)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses from domain mixture proportions via\n    a simple affine mapping: loss = X\u00b7W + b.\n\n    Args:\n        data_points: array-like of shape (N, 5), each row is a domain\n                     mixture proportion vector.\n        params:      flat array of length 30: first 25 entries are\n                     the weight matrix W (5\u00d75, row-major), last 5 are\n                     the bias vector b.\n\n    Returns:\n        preds: numpy array of shape (N, 5) of predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # weight matrix (5\u21925)\n    b = p[25:].reshape(1, 5)   # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b       # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Solves for [W; b] in closed form:\n      minimize ||X\u00b7W + 1\u00b7b - Y||^2 + \u03bb||[W; b]||^2\n\n    Args:\n        data_points: array-like of shape (N, 5)\n        loss_values: array-like of shape (N, 5)\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases)\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected losses of shape (N,5), got {Y.shape}\")\n\n    # augment X with a constant column for bias\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization strength\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)   # (6,6)\n    B = X_aug.T.dot(Y)                             # (6,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                  # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]                               # (5,5)\n    b = Theta[F:, :].reshape(1, 5)                 # (1,5)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)     # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)              # (6,6)\n    B = X_aug.T.dot(Y)                                        # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                            # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5239, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient log\u2010linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the logarithm of the five\ndomain proportions. Total parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a log\u2010linear mapping:\n      preds = log(X + \u03b5) @ W + b\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    # numerical stability for log(0)\n    eps = 1e-8\n    X_log = np.log(X + eps)            # (N,5)\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # weight matrix (5\u21925)\n    b = p[25:].reshape(1, 5)   # bias vector\n\n    # affine prediction on log\u2010inputs\n    preds = X_log.dot(W) + b   # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the log\u2010linear mixture\u2010of\u2010experts scaling law via least squares.\n\n    We solve for W and b in\n      log(X + \u03b5)\u00b7W + 1\u00b7b = Y\n    in closed form using NumPy's least-squares solver.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must have shape {X.shape}, got {Y.shape}\")\n\n    # log\u2010transform with small epsilon to avoid log(0)\n    eps = 1e-8\n    X_log = np.log(X + eps)           # (N,5)\n    N = X_log.shape[0]\n\n    # augment with bias column\n    ones = np.ones((N, 1), dtype=float)\n    X_aug = np.hstack([X_log, ones])  # (N,6)\n\n    # solve multi\u2010output least squares: X_aug @ Theta = Y\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)  # Theta: (6,5)\n\n    # unpack into W and b\n    W = Theta[:5, :]                # (5,5)\n    b = Theta[5:, :].reshape(5,)    # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5542, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\nThis version emphasizes clarity and maintainability by leveraging\nNumPy's least\u2010squares solver.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      1D array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    \n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"params must be length 30, got {p.size}\")\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # linear weights\n    b = p[25:].reshape(1, 5)   # broadcastable bias\n    \n    # affine combination\n    preds = X.dot(W) + b       # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture\u2010of\u2010experts scaling law via least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: 1D array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must have shape {X.shape}, got {Y.shape}\")\n    \n    # Augment inputs with a constant bias column\n    ones = np.ones((X.shape[0], 1), dtype=float)\n    X_aug = np.hstack([X, ones])    # shape (N,6)\n    \n    # Solve the multi\u2010output least squares problem:\n    # Theta has shape (6,5) where first 5 rows are W.T and last row is b\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)\n    \n    # Extract W and b\n    # Theta: (6,5) so W = Theta[:5,:].T if we solved X_aug @ Theta = Y\n    # but numpy returns Theta shape (6,5) s.t. X_aug @ Theta = Y exactly,\n    # so rows correspond to augmented features.\n    W = Theta[:5, :].T            # (5,5)\n    b = Theta[5, :].reshape(5,)   # (5,)\n    \n    # Flatten into params vector\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, NumPy-based implementation, Comprehensive implementation\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)     # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)              # (6,6)\n    B = X_aug.T.dot(Y)                                        # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                            # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\nThis version simplifies the fitting procedure by leveraging NumPy's\nleast\u2010squares solver for clarity and maintainability.\n\"\"\"\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      1D array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    \n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 30, f\"params must be length 30, got {p.size}\"\n    \n    # unpack parameters\n    W = p[:25].reshape(5, 5)   # linear weights\n    b = p[25:].reshape(1, 5)   # broadcastable bias\n    \n    # affine combination\n    preds = X.dot(W) + b       # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture\u2010of\u2010experts scaling law via least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: 1D array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    assert X.ndim == 2 and X.shape[1] == 5, \\\n        f\"data_points must have shape (N,5), got {X.shape}\"\n    assert Y.ndim == 2 and Y.shape[0] == X.shape[0] and Y.shape[1] == 5, \\\n        f\"loss_values must have shape (N,5), got {Y.shape}\"\n    \n    # Augment input with a bias column of ones\n    ones = np.ones((X.shape[0], 1), dtype=float)\n    X_aug = np.hstack([X, ones])    # shape (N,6)\n    \n    # Solve the multi\u2010output least squares problem\n    # Theta has shape (6,5): [W; b]\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)\n    \n    # Extract W and b\n    W = Theta[:5, :]                # (5,5)\n    b = Theta[5, :].reshape(5,)     # (5,)\n    \n    # Flatten parameters into a single vector\n    return np.concatenate([W.ravel(), b])\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a hybrid linear + log\u2010feature mixture\u2010of\u2010experts model:\n  preds_j = X @ W_lin[:,j]  +  w_log[j] * log(X[:,j] + \u03b5)  +  b[j]\nTotal parameters = 5\u00d75 (W_lin) + 5 (w_log) + 5 (b) = 35 \u2264 35.\nFitting is done in closed form with ridge regularization for stability.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a combination of linear and per-domain log features.\n\n    preds_{n,j} = sum_i X[n,i] * W_lin[i,j]\n                + w_log[j] * log(X[n,j] + eps)\n                + b[j]\n\n    Args:\n        data_points: array of shape (N,5) with domain mixture proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 W_lin of shape (5,5)\n                     - next 5 entries   \u2192 w_log of shape (5,)\n                     - last 5 entries   \u2192 b      of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack\n    W_lin = p[:25].reshape(5, 5)     # linear weights\n    w_log = p[25:30].reshape(5,)     # log-feature weights\n    b     = p[30:35].reshape(1, 5)   # biases\n\n    # linear part\n    out_lin = X.dot(W_lin)           # shape (N,5)\n\n    # log part (per-domain)\n    eps = 1e-8\n    X_log = np.log(X + eps)          # shape (N,5)\n    out_log = X_log * w_log          # broadcasts (N,5)\n\n    preds = out_lin + out_log + b    # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the hybrid linear+log scaling law by solving 5 separate\n    ridge\u2010regularized least squares problems (one per output domain).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W_lin + 5 w_log + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must have shape {X.shape}, got {Y.shape}\")\n\n    N = X.shape[0]\n    eps = 1e-8\n    X_log = np.log(X + eps)           # (N,5)\n\n    # We'll fit each output j separately:\n    W_lin = np.zeros((5, 5), dtype=float)\n    w_log = np.zeros(5, dtype=float)\n    b_vec = np.zeros(5, dtype=float)\n\n    lam = 1e-6  # ridge regularization strength\n    # Prepare identity for ridge\n    # For each j, design matrix has 7 cols: [X[:,0..4], X_log[:,j], 1]\n    I7 = np.eye(7, dtype=float)\n\n    for j in range(5):\n        # Build design matrix for target j\n        # features: X (5 cols), X_log[:,j] (1 col), ones (1 col) \u2192 total 7\n        Xj = np.concatenate([\n            X,                          # (N,5)\n            X_log[:, j:j+1],            # (N,1)\n            np.ones((N, 1), dtype=float)# (N,1)\n        ], axis=1)  # shape (N,7)\n\n        yj = Y[:, j]  # shape (N,)\n\n        # Solve (Xj^T Xj + lam I) \u03b8 = Xj^T yj\n        A = Xj.T.dot(Xj) + lam * I7    # (7,7)\n        B = Xj.T.dot(yj)               # (7,)\n        theta_j = np.linalg.solve(A, B)  # (7,)\n\n        # Unpack\n        W_lin[:, j] = theta_j[0:5]\n        w_log[j]    = theta_j[5]\n        b_vec[j]    = theta_j[6]\n\n    # Flatten into parameter vector\n    params = np.concatenate([W_lin.ravel(), w_log, b_vec])\n    return params\n\n# EVOLVE-BLOCK-END\n```"]}}}