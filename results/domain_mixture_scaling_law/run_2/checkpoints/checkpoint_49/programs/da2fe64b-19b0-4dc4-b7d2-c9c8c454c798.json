{"id": "da2fe64b-19b0-4dc4-b7d2-c9c8c454c798", "code": "\"\"\"\nScaling law discovery for multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear exponent\u2010feature model:\nEach input proportion is raised to a learned exponent, then\naffinely combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 log\u2010exponent vector u (for exponents p_i = exp(u_i))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) log\u2010exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # compute positive exponents\n    exponents = np.exp(u)              # (5,)\n\n    # raise each feature to its exponent\n    # X_p[n,i] = X[n,i] ** exponents[i]\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination to get predictions\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=np.float64))  # (N,5)\n    if X.shape[1] != 5 or Y.shape != X.shape:\n        raise ValueError(f\"Expected data_points and loss_values of shape (N,5), got {X.shape} and {Y.shape}\")\n\n    # Initialization:\n    # log\u2010exponents u_i = 0 \u2192 exponents p_i = 1\n    # weights W = 0\n    # biases b = mean of each output\n    init_u = np.zeros(5, dtype=np.float64)\n    init_W = np.zeros(25, dtype=np.float64)\n    init_b = np.mean(Y, axis=0).astype(np.float64)\n    init_params = np.concatenate([init_u, init_W, init_b])  # length 35\n\n    # bound log\u2010exponents to keep exponents in [exp(-3), exp(3)]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        return np.mean((Y_pred - Y)**2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        return init_params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "5fdcf0e4-8e90-481f-8674-5bca16538e93", "generation": 4, "timestamp": 1754716543.9643574, "iteration_found": 48, "metrics": {"nmse": 0.0009540273396918883, "nmae": 0.023986230143142474, "r2": 0.9990459726603081, "combined_score": 0.9990468819609752}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.05753640772545619, "nmae": 0.19398804562880473, "r2": 0.9424635922745438, "combined_score": 0.945593922530568}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0575\n- nmae: 0.1940\n- r2: 0.9425\n- combined_score: 0.9456\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0210, nmae: 0.1304, r2: 0.9790, combined_score: 0.9794\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0210, nmae: 0.1304, r2: 0.9790, combined_score: 0.9794\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0010, nmae: 0.0240, r2: 0.9990, combined_score: 0.9990\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5058)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear feature\u2010exponent model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 exponent\u2010log vector u (for positive exponents p=exp(u))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) logarithms of exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix W[j,i]\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # positive exponents\n    exponents = np.exp(u)              # p_i \u2265 0, (5,)\n\n    # nonlinear transform of inputs\n    # x_{n,i}^{p_i}\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # Initialization:\n    # - log\u2010exponents u_i = 0 \u2192 exponents p_i = 1 (identity)\n    # - weights W = 0\n    # - biases b = mean of each output\n    mean_Y = np.mean(Y, axis=0)                  # (5,)\n    init_u = np.zeros(5)                         # (5,)\n    init_W = np.zeros(25)                        # flattened (5\u00d75)\n    init_b = mean_Y.copy()                       # (5,)\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # Bound the log\u2010exponents to keep p_i in a reasonable range\n    # here u_i \u2208 [\u22123, 3] \u21d2 p_i \u2208 [exp(\u22123), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        # mean squared error\n        return np.mean((Y_pred - Y) ** 2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial params if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0010), Performs well on nmae (0.0240), Performs well on r2 (0.9990), Performs well on combined_score (0.9990)\n\n\n### Program 2 (Score: 0.5275)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nIntroducing a concise quadratic\u2010mixture feature to capture non\u2010linear\neffects of domain concentration, while remaining within 35 parameters:\n  - 5 original linear weights per output\n  - 1 shared \"purity\" feature per sample (sum of squared proportions) per output\n  - 1 bias per output\nTotal parameters = (5 + 1 + 1) \u00d7 5 = 35\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35, interpreted as a (7\u00d75) matrix:\n                - rows 0\u20134: linear weights for each of the 5 input proportions\n                - row 5:   weight for the \"purity\" feature h = sum(proportions^2)\n                - row 6:   bias term\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of the 5 domains.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)           # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input shape (N,5), got (N,{F})\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n    Theta = p.reshape(7, 5)                            # (7,5)\n\n    # purity feature h = sum of squares of proportions per sample\n    h = np.sum(X * X, axis=1, keepdims=True)          # (N,1)\n\n    # build augmented feature matrix [X | h | 1]\n    X_aug = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # affine prediction in augmented feature space\n    preds = X_aug.dot(Theta)                           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the quadratic\u2010mixture scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (7\u00d75 matrix flattened).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)           # (N,5)\n    Y = np.asarray(loss_values, dtype=float)           # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input shape (N,5), got (N,{F})\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # compute purity feature\n    h = np.sum(X * X, axis=1, keepdims=True)          # (N,1)\n\n    # build augmented feature matrix [X | h | 1]\n    X_aug = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    K = X_aug.shape[1]                                 # 7\n    A = X_aug.T.dot(X_aug) + lam * np.eye(K)           # (7,7)\n    B = X_aug.T.dot(Y)                                 # (7,5)\n\n    # solve normal equations: (7,7) @ (7,5) = (7,5)\n    Theta = np.linalg.solve(A, B)                      # (7,5)\n\n    # flatten parameters to length 35\n    return Theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0210), Performs well on nmae (0.1304), Performs well on r2 (0.9790), Performs well on combined_score (0.9794)\n\n\n### Program 3 (Score: 0.5275)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine\u2010plus\u2010quadratic model:\neach output loss is an affine function of the five domain proportions\nplus a single shared quadratic feature (sum of squares of proportions).\nTotal parameters = (5 linear + 1 quadratic + 1 bias) \u00d7 5 outputs = 35.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array-like of shape (N,5)\n            Each row contains proportions for the 5 domains (sum to 1).\n        params: array-like of length 35\n            Flattened regression coefficients of shape (7,5):\n               - first 5 rows: linear weights for each input feature\n               - 6th row:    weights for the quadratic feature (sum of squares)\n               - 7th row:    bias terms\n\n    Returns:\n        preds: ndarray of shape (N,5)\n            Predicted losses for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    p = np.ravel(params).astype(float)\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # Compute the shared quadratic feature: sum of squares of proportions\n    sq_feat = np.sum(X * X, axis=1, keepdims=True)  # shape (N,1)\n\n    # Build augmented design matrix: [X | sq_feat | 1]\n    X_aug = np.concatenate([X, sq_feat, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # Reshape parameters into (7,5) and compute predictions\n    Theta = p.reshape(7, 5)  # (7,5)\n    preds = X_aug.dot(Theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine\u2010plus\u2010quadratic scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array-like of shape (N,5)\n            Mixtures of domain proportions.\n        loss_values: array-like of shape (N,5)\n            Observed multi-domain losses for each mixture.\n\n    Returns:\n        params: ndarray of length 35\n            Learned flatten parameters of the (7\u00d75) coefficient matrix.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape ({N},5), got {Y.shape}\")\n\n    # Compute the shared quadratic feature\n    sq_feat = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # Build augmented design matrix: [X | sq_feat | 1]\n    X_aug = np.concatenate([X, sq_feat, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # Ridge\u2010regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(7)      # (7,7)\n    B = X_aug.T.dot(Y)                            # (7,5)\n\n    # Solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                 # (7,5)\n\n    # Return flattened parameters\n    return Theta.ravel()\n```\nKey features: Performs well on nmse (0.0210), Performs well on nmae (0.1304), Performs well on r2 (0.9790), Performs well on combined_score (0.9794)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5307)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a shared-mixture power law per output.\n\n    Args:\n        data_points: array of shape (N,5) of domain proportions.\n        params:      flat array of length 20:\n                     - [0:5]:   unnormalized logits u for mixture weights w = softmax(u)\n                     - [5:10]:  biases a_j for each domain loss\n                     - [10:15]: log-scales r_j so that b_j = exp(r_j) >= 0\n                     - [15:20]: log-exponents v_j so that p_j = exp(v_j) >= 0\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    prm = np.asarray(params).ravel()\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture weights w = softmax(u)\n    u = prm[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                 # (5,)\n\n    # 2) Output\u2010specific parameters\n    a = prm[5:10]                             # biases (5,)\n    r = prm[10:15]                            # log\u2010scales (5,)\n    v = prm[15:20]                            # log\u2010exponents (5,)\n    b = np.exp(r)                             # scales >= 0 (5,)\n    p = np.exp(v)                             # exponents >= 0 (5,)\n\n    # 3) Mixture score for each sample\n    s = X.dot(w)                              # (N,)\n\n    # 4) Predict each domain loss: y_j = a_j + b_j * s^p_j\n    # Broadcasting to (N,5)\n    Y = a[None, :] + b[None, :] * (s[:, None] ** p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture power\u2010law scaling function via L-BFGS optimization.\n\n    Args:\n        data_points:  array of shape (N,5) of domain proportions.\n        loss_values:  array of shape (N,5) of observed domain losses.\n\n    Returns:\n        params: flat array of length 20 (optimized).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected inputs of shape (N,5) and losses of shape (N,5)\")\n\n    # Initialize parameters\n    #  u = 0       => uniform mixture\n    #  a = mean(Y) => bias approx\n    #  r = log(std(Y)) => scale approx\n    #  v = 0       => exponent \u2248 1\n    mean_y = np.mean(Y, axis=0)\n    std_y  = np.std(Y, axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])\n\n    # Regularization strength for scale/exponent terms\n    lam_reg = 1e-2\n\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        mse = np.mean((pred - Y) ** 2)\n        # L2 penalty on r and v for numerical stability\n        r = params[10:15]\n        v = params[15:20]\n        reg = lam_reg * (np.sum(r**2) + np.sum(v**2)) / params.size\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective,\n                      init_params,\n                      method='L-BFGS-B',\n                      options={'maxiter': 1000, 'ftol': 1e-9})\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5314)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef _softmax(logits):\n    \"\"\"Stable softmax over 1D array.\"\"\"\n    z = logits - np.max(logits)\n    exp_z = np.exp(z)\n    return exp_z / np.sum(exp_z)\n\ndef _softplus(x):\n    \"\"\"Softplus for positive outputs: log(1 + exp(x)) to ensure positivity.\"\"\"\n    return np.log1p(np.exp(-np.abs(x))) + np.maximum(x, 0)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n    \n    Model:\n        Let w = softmax(u) \u2208 \u0394\u2074 (u \u2208 \u211d\u2075),\n            a \u2208 \u211d\u2075 (bias),\n            b = exp(r) \u2208 \u211d\u2075\u208a (scale),\n            p = softplus(v) + \u03b5 \u2208 \u211d\u2075\u208a (exponents).\n        For each sample X[n,:] and each domain j:\n            s[n] = X[n,:] \u00b7 w\n            y_pred[n,j] = a[j] + b[j] * (s[n] + \u03b5)^{p[j]}\n    \n    Args:\n        data_points: array-like, shape (N,5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (20,)\n            Flat parameter vector [u(5), a(5), r(5), v(5)].\n    \n    Returns:\n        Y_pred: ndarray, shape (N,5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    \n    p = np.ravel(params).astype(float)\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n    \n    # unpack\n    u = p[0:5]    # mixture logits\n    a = p[5:10]   # biases\n    r = p[10:15]  # log-scales\n    v = p[15:20]  # log-exponents\n    \n    # transforms\n    w = _softmax(u)                     # mixture weights \u2208 simplex\n    b = np.exp(r)                       # scale \u2265 0\n    eps = 1e-6                          # numerical smoothing\n    p_exp = _softplus(v) + eps         # positive exponents\n    \n    # mixture score\n    s = X.dot(w)                        # (N,)\n    s = np.maximum(s, eps)              # guard against zero\n    \n    # compute predictions\n    # shape (N,1) broadcast with (1,5)\n    Y = a[np.newaxis, :] + b[np.newaxis, :] * np.power(s[:, np.newaxis], p_exp[np.newaxis, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 20 parameters of the scaling law by minimizing MSE.\n    \n    Args:\n        data_points: array-like, shape (N,5)\n        loss_values: array-like, shape (N,5)\n    \n    Returns:\n        params_opt: ndarray, shape (20,)\n            Optimized [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points (N,5) and loss_values (N,5)\")\n    \n    # initialize parameters\n    # u = 0 (uniform mixture), a = mean loss per domain, r = 0 (b=1), v = 0 (p\u22480.693 via softplus)\n    init = np.zeros(20, dtype=float)\n    init[5:10] = np.mean(Y, axis=0)\n    \n    # bounds: u,a free; r\u2208[-5,5]; v\u2208[-2,2]\n    bounds = []\n    for i in range(20):\n        if 10 <= i < 15:\n            bounds.append((-5.0, 5.0))\n        elif 15 <= i < 20:\n            bounds.append((-2.0, 2.0))\n        else:\n            bounds.append((None, None))\n    \n    # objective: mean squared error\n    def objective(params):\n        Y_pred = scaling_law_func(X, params)\n        return np.mean((Y_pred - Y) ** 2)\n    \n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    \n    if not result.success:\n        # fallback to initialization if optimization fails\n        return init\n    return result.x\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5058, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear feature\u2010exponent model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 exponent\u2010log vector u (for positive exponents p=exp(u))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) logarithms of exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix W[j,i]\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # positive exponents\n    exponents = np.exp(u)              # p_i \u2265 0, (5,)\n\n    # nonlinear transform of inputs\n    # x_{n,i}^{p_i}\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # Initialization:\n    # - log\u2010exponents u_i = 0 \u2192 exponents p_i = 1 (identity)\n    # - weights W = 0\n    # - biases b = mean of each output\n    mean_Y = np.mean(Y, axis=0)                  # (5,)\n    init_u = np.zeros(5)                         # (5,)\n    init_W = np.zeros(25)                        # flattened (5\u00d75)\n    init_b = mean_Y.copy()                       # (5,)\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # Bound the log\u2010exponents to keep p_i in a reasonable range\n    # here u_i \u2208 [\u22123, 3] \u21d2 p_i \u2208 [exp(\u22123), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        # mean squared error\n        return np.mean((Y_pred - Y) ** 2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial params if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5416, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law: mixture-based power law with shared domain mixture weights.\n\nWe model each output loss as:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p_j}\n\nParameters (20 total):\n    u (5):    unnormalized logits for domain-mixture weights w = softmax(u)\n    a (5):    output-specific biases\n    r (5):    log-scales so that b = exp(r) >= 0\n    v (5):    log-exponents so that p = exp(v) >= 0\n\nThis parameterization uses 20 parameters (\u2264 35), enforces positivity\nfor mixture weights, scales, and exponents, and shares the same\nmixture across all outputs for efficiency and cross-domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points))  # shape (N, 5)\n    prm = np.asarray(params).reshape(-1)\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture logits -> softmax weights\n    u = prm[0:5]                          # (5,)\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)             # (5,)\n\n    # 2) Output-specific parameters\n    a = prm[5:10]                         # bias terms, (5,)\n    r = prm[10:15]                        # log-scale terms\n    v = prm[15:20]                        # log-exponent terms\n\n    b = np.exp(r)                         # scale >= 0, (5,)\n    p = np.exp(v)                         # exponent >= 0, (5,)\n\n    # 3) Compute the mixture score for each sample\n    #    s_n = sum_i w_i * x_{n,i}\n    s = X.dot(w)                          # (N,)\n\n    # 4) Predict each output\n    #    y_{n,j} = a_j + b_j * s_n^{p_j}\n    # Broadcasting to (N, 5)\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    y = np.asarray(loss_values)\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    N, F = X.shape\n    if F != 5 or y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 domain proportions and 5 loss outputs\")\n\n    # Parameter vector length = 20\n    # Initialize:\n    #   u = 0           => uniform mixture weights\n    #   a = mean(y)     => bias approx\n    #   r = 0           => scale b = 1\n    #   v = 0           => exponent p = 1\n    mean_y = np.mean(y2d, axis=0)               # (5,)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.zeros(5)\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])  # (20,)\n\n    # Objective: mean squared error\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        return np.mean((pred - y2d) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective, init_params, method='L-BFGS-B')\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5307, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a shared-mixture power law per output.\n\n    Args:\n        data_points: array of shape (N,5) of domain proportions.\n        params:      flat array of length 20:\n                     - [0:5]:   unnormalized logits u for mixture weights w = softmax(u)\n                     - [5:10]:  biases a_j for each domain loss\n                     - [10:15]: log-scales r_j so that b_j = exp(r_j) >= 0\n                     - [15:20]: log-exponents v_j so that p_j = exp(v_j) >= 0\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    prm = np.asarray(params).ravel()\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture weights w = softmax(u)\n    u = prm[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                 # (5,)\n\n    # 2) Output\u2010specific parameters\n    a = prm[5:10]                             # biases (5,)\n    r = prm[10:15]                            # log\u2010scales (5,)\n    v = prm[15:20]                            # log\u2010exponents (5,)\n    b = np.exp(r)                             # scales >= 0 (5,)\n    p = np.exp(v)                             # exponents >= 0 (5,)\n\n    # 3) Mixture score for each sample\n    s = X.dot(w)                              # (N,)\n\n    # 4) Predict each domain loss: y_j = a_j + b_j * s^p_j\n    # Broadcasting to (N,5)\n    Y = a[None, :] + b[None, :] * (s[:, None] ** p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture power\u2010law scaling function via L-BFGS optimization.\n\n    Args:\n        data_points:  array of shape (N,5) of domain proportions.\n        loss_values:  array of shape (N,5) of observed domain losses.\n\n    Returns:\n        params: flat array of length 20 (optimized).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected inputs of shape (N,5) and losses of shape (N,5)\")\n\n    # Initialize parameters\n    #  u = 0       => uniform mixture\n    #  a = mean(Y) => bias approx\n    #  r = log(std(Y)) => scale approx\n    #  v = 0       => exponent \u2248 1\n    mean_y = np.mean(Y, axis=0)\n    std_y  = np.std(Y, axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])\n\n    # Regularization strength for scale/exponent terms\n    lam_reg = 1e-2\n\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        mse = np.mean((pred - Y) ** 2)\n        # L2 penalty on r and v for numerical stability\n        r = params[10:15]\n        v = params[15:20]\n        reg = lam_reg * (np.sum(r**2) + np.sum(v**2)) / params.size\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective,\n                      init_params,\n                      method='L-BFGS-B',\n                      options={'maxiter': 1000, 'ftol': 1e-9})\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5275, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine\u2010plus\u2010quadratic model:\neach output loss is an affine function of the five domain proportions\nplus a single shared quadratic feature (sum of squares of proportions).\nTotal parameters = (5 linear + 1 quadratic + 1 bias) \u00d7 5 outputs = 35.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array-like of shape (N,5)\n            Each row contains proportions for the 5 domains (sum to 1).\n        params: array-like of length 35\n            Flattened regression coefficients of shape (7,5):\n               - first 5 rows: linear weights for each input feature\n               - 6th row:    weights for the quadratic feature (sum of squares)\n               - 7th row:    bias terms\n\n    Returns:\n        preds: ndarray of shape (N,5)\n            Predicted losses for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    p = np.ravel(params).astype(float)\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # Compute the shared quadratic feature: sum of squares of proportions\n    sq_feat = np.sum(X * X, axis=1, keepdims=True)  # shape (N,1)\n\n    # Build augmented design matrix: [X | sq_feat | 1]\n    X_aug = np.concatenate([X, sq_feat, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # Reshape parameters into (7,5) and compute predictions\n    Theta = p.reshape(7, 5)  # (7,5)\n    preds = X_aug.dot(Theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine\u2010plus\u2010quadratic scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array-like of shape (N,5)\n            Mixtures of domain proportions.\n        loss_values: array-like of shape (N,5)\n            Observed multi-domain losses for each mixture.\n\n    Returns:\n        params: ndarray of length 35\n            Learned flatten parameters of the (7\u00d75) coefficient matrix.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape ({N},5), got {Y.shape}\")\n\n    # Compute the shared quadratic feature\n    sq_feat = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # Build augmented design matrix: [X | sq_feat | 1]\n    X_aug = np.concatenate([X, sq_feat, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # Ridge\u2010regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(7)      # (7,7)\n    B = X_aug.T.dot(Y)                            # (7,5)\n\n    # Solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                 # (7,5)\n\n    # Return flattened parameters\n    return Theta.ravel()\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5275, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nIntroducing a concise quadratic\u2010mixture feature to capture non\u2010linear\neffects of domain concentration, while remaining within 35 parameters:\n  - 5 original linear weights per output\n  - 1 shared \"purity\" feature per sample (sum of squared proportions) per output\n  - 1 bias per output\nTotal parameters = (5 + 1 + 1) \u00d7 5 = 35\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35, interpreted as a (7\u00d75) matrix:\n                - rows 0\u20134: linear weights for each of the 5 input proportions\n                - row 5:   weight for the \"purity\" feature h = sum(proportions^2)\n                - row 6:   bias term\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of the 5 domains.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)           # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input shape (N,5), got (N,{F})\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n    Theta = p.reshape(7, 5)                            # (7,5)\n\n    # purity feature h = sum of squares of proportions per sample\n    h = np.sum(X * X, axis=1, keepdims=True)          # (N,1)\n\n    # build augmented feature matrix [X | h | 1]\n    X_aug = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # affine prediction in augmented feature space\n    preds = X_aug.dot(Theta)                           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the quadratic\u2010mixture scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (7\u00d75 matrix flattened).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)           # (N,5)\n    Y = np.asarray(loss_values, dtype=float)           # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input shape (N,5), got (N,{F})\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # compute purity feature\n    h = np.sum(X * X, axis=1, keepdims=True)          # (N,1)\n\n    # build augmented feature matrix [X | h | 1]\n    X_aug = np.concatenate([X, h, np.ones((N, 1), dtype=float)], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    K = X_aug.shape[1]                                 # 7\n    A = X_aug.T.dot(X_aug) + lam * np.eye(K)           # (7,7)\n    B = X_aug.T.dot(Y)                                 # (7,5)\n\n    # solve normal equations: (7,7) @ (7,5) = (7,5)\n    Theta = np.linalg.solve(A, B)                      # (7,5)\n\n    # flatten parameters to length 35\n    return Theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nNonlinear two\u2010feature scaling law for multi\u2010domain loss prediction.\n\nWe model each domain\u2010loss y_j as a low\u2010degree polynomial in a single\nmixture score s. The mixture score s is a softmax\u2010weighted sum of the\n5 domain proportions. Specifically:\n\n    w = softmax(u)         # mix weights over 5 domains\n    s = X @ w              # scalar score per sample\n    y_j = \u03b8_{0,j} * s + \u03b8_{1,j} * s^2 + \u03b8_{2,j} * 1\n\nTotal parameters:\n    u : 5 logits \u2192 w = softmax(u)\n    \u0398 : 3 \u00d7 5 polynomial coefficients\n    --------------------------------\n    5 + 15 = 20 parameters (\u2264 35)\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 20:\n                - first 5 entries \u2192 u logits (for softmax mixing)\n                - next 15 entries \u2192 \u0398 matrix of shape (3,5):\n                   row 0: coefficient for s\n                   row 1: coefficient for s^2\n                   row 2: constant bias\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 20:\n        raise ValueError(f\"params must have length 20, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                          # logits for mixing\n    Theta = p[5:].reshape(3, 5)        # polynomial coeffs\n\n    # stable softmax \u2192 mixture weights\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)          # shape (5,)\n\n    # mixture score\n    s = X.dot(w)                       # shape (N,)\n\n    # build feature matrix [s, s^2, 1]\n    s2 = s * s\n    F = np.stack([s, s2, np.ones_like(s)], axis=1)  # (N,3)\n\n    # predict: F @ \u0398  \u2192 shape (N,5)\n    preds = F.dot(Theta)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the above scaling law by optimizing u logits. For any u,\n    we solve a small ridge\u2010regularized linear least squares in \u0398.\n\n    Args:\n        data_points: array of shape (N,5) domain proportions.\n        loss_values: array of shape (N,5) observed multi\u2010domain losses.\n\n    Returns:\n        params: flat array of length 20 (5 u\u2010logits + 15 \u0398 entries).\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    Y = np.asarray(loss_values, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must be (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape[0] != X.shape[0] or Y.shape[1] != 5:\n        raise ValueError(f\"loss_values must be (N,5), got {Y.shape}\")\n\n    N = X.shape[0]\n    lam = 1e-6   # small ridge for \u0398\u2010solve\n\n    def solve_Theta(u_logits):\n        # compute mixture weights\n        u_max = np.max(u_logits)\n        exp_u = np.exp(u_logits - u_max)\n        w = exp_u / np.sum(exp_u)          # (5,)\n        # mixture score\n        s = X.dot(w)                       # (N,)\n        s2 = s * s\n        # feature matrix [s, s^2, 1] shape (N,3)\n        F = np.stack([s, s2, np.ones_like(s)], axis=1)\n        # solve (F^T F + lam I) \u0398 = F^T Y\n        A = F.T.dot(F) + lam * np.eye(3)\n        B = F.T.dot(Y)\n        Theta = np.linalg.solve(A, B)      # shape (3,5)\n        return Theta\n\n    def objective(u_logits):\n        # for given u, compute best \u0398, then MSE\n        Theta = solve_Theta(u_logits)\n        # predict and compute MSE\n        u_max = np.max(u_logits)\n        w = np.exp(u_logits - u_max)\n        w = w / np.sum(w)\n        s = X.dot(w)\n        s2 = s * s\n        F = np.stack([s, s2, np.ones_like(s)], axis=1)\n        Y_pred = F.dot(Theta)\n        return np.mean((Y_pred - Y) ** 2)\n\n    # initialize u\u2010logits uniformly\n    init_u = np.zeros(5, dtype=np.float64)\n\n    # optimize only u\u2010logits via L-BFGS-B\n    res = minimize(\n        objective,\n        init_u,\n        method='L-BFGS-B',\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n\n    u_opt = res.x if res.success else init_u\n    Theta_opt = solve_Theta(u_opt)\n\n    # pack parameters: u (5) then \u0398 (3\u00d75)\n    params = np.concatenate([u_opt, Theta_opt.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["\"\"\"\nScaling law discovery for multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear exponent\u2010feature model:\nEach input proportion is raised to a learned exponent, then\naffinely combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 log\u2010exponent vector u (for exponents p_i = exp(u_i))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) log\u2010exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # compute positive exponents\n    exponents = np.exp(u)              # (5,)\n\n    # raise each feature to its exponent\n    # X_p[n,i] = X[n,i] ** exponents[i]\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination to get predictions\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=np.float64))  # (N,5)\n    if X.shape[1] != 5 or Y.shape != X.shape:\n        raise ValueError(f\"Expected data_points and loss_values of shape (N,5), got {X.shape} and {Y.shape}\")\n\n    # Initialization:\n    # log\u2010exponents u_i = 0 \u2192 exponents p_i = 1\n    # weights W = 0\n    # biases b = mean of each output\n    init_u = np.zeros(5, dtype=np.float64)\n    init_W = np.zeros(25, dtype=np.float64)\n    init_b = np.mean(Y, axis=0).astype(np.float64)\n    init_params = np.concatenate([init_u, init_W, init_b])  # length 35\n\n    # bound log\u2010exponents to keep exponents in [exp(-3), exp(3)]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        return np.mean((Y_pred - Y)**2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        return init_params\n\n# EVOLVE-BLOCK-END"]}}}