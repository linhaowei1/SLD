{"id": "0eba3ced-e348-413d-9f7d-e5e549bbc134", "code": "import numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model: y = X W + 1 b\n    - X: (N,5) domain proportions\n    - W: (5,5) weight matrix\n    - b: (1,5) bias vector\n    Total params = 25 + 5 = 30\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of 30 parameters.\n\n    Returns:\n        preds: array of shape (N,5), predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got shape {X.shape}\")\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack: first 25 \u2192 W (5\u00d75), last 5 \u2192 b (1\u00d75)\n    W = p[:25].reshape(5, 5)\n    b = p[25:].reshape(1, 5)\n\n    # affine prediction\n    preds = X.dot(W) + b       # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law using ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of 30 optimized parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=np.float64))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5), got {X.shape}, {Y.shape}\")\n\n    # augment X with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=np.float64)], axis=1)  # (N,6)\n\n    # ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1, dtype=np.float64)          # (6,6)\n    B = X_aug.T.dot(Y)                                                      # (6,5)\n\n    # solve for Theta: (6,5)\n    Theta = np.linalg.solve(A, B)\n\n    # unpack Theta into W (first 5 rows) and b (last row)\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :].reshape(1, 5)\n\n    # flatten back to 30-long parameter vector\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "3b8a8329-63f7-40ea-896c-eb5ee856a212", "generation": 3, "timestamp": 1754716499.5366433, "iteration_found": 45, "metrics": {"nmse": 0.018360804339811472, "nmae": 0.13690427617636788, "r2": 0.9816391956601885, "combined_score": 0.9819702366179396}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.1085035032759301, "nmae": 0.30587343493252594, "r2": 0.8914964967240699, "combined_score": 0.9021171309289753}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.1085\n- nmae: 0.3059\n- r2: 0.8915\n- combined_score: 0.9021\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30, interpreted as a (6\u00d75) matrix:\n                - first 5 rows: weight matrix (5 weights per output)\n                - last 1 row:  bias vector (1 bias per output)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    # reshape params into theta of shape (6,5)\n    theta = np.asarray(params, dtype=float).ravel()\n    assert theta.size == 30, f\"Expected 30 parameters, got {theta.size}\"\n    theta = theta.reshape(6, 5)  # (5 weights + 1 bias) for each of 5 outputs\n\n    # augment inputs with a bias feature of 1s\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # compute predictions\n    preds = X_aug.dot(theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (6\u00d75 matrix flattened).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # solve for theta in A @ theta = B\n    theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # return flattened parameters\n    return theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions (floats).\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 30:\n        raise ValueError(f\"params must have length 30, got {p.size}\")\n    # unpack\n    W = p[:25].reshape(5, 5)  # maps 5 inputs \u2192 5 outputs\n    b = p[25:].reshape(1, 5)  # bias for each output\n    # linear prediction\n    preds = X.dot(W) + b      # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) with observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    Y = np.asarray(loss_values, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must match data_points shape, got {Y.shape}\")\n    N, F = X.shape  # F == 5\n    # augment X with bias column\n    X_aug = np.hstack([X, np.ones((N, 1), dtype=np.float64)])  # shape (N,6)\n    # ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1, dtype=np.float64)  # (6,6)\n    B = X_aug.T.dot(Y)                                              # (6,5)\n    # solve A @ Theta = B\n    Theta = np.linalg.solve(A, B)                                   # (6,5)\n    W = Theta[:F, :]  # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n    # pack parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix (features \u2192 outputs)\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ordinary least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points shape (N,5) and loss_values shape (N,5)\")\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # solve ordinary least squares: find Theta minimizing ||X_aug @ Theta - Y||^2\n    # Theta has shape (6,5)\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)\n\n    # flatten parameters: first 5 rows \u2192 25 weights, last row \u2192 5 biases\n    params = Theta.ravel()\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5308, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced multi-domain scaling law with combined power-law and linear terms.\n\nModel:\n    y_j = a_j + b_j * s^{p_j} + c_j * s\nwhere\n    s = sum_i w_i * x_i\nand\n    w = softmax(u)  (domain-mixture weights, shared across outputs)\n\nParameters (25 total):\n    u (5): unnormalized logits \u2192 mixture weights w (via softmax)\n    a (5): output biases\n    r (5): log-scales \u2192 b = exp(r) \u2265 0\n    v (5): log-exponents \u2192 p = exp(v) \u2265 0\n    c (5): linear coefficients for s\n\nThis formulation adds a linear term c_j * s to improve\nfit flexibility while staying parameter-efficient.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected input features with shape (*,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 25:\n        raise ValueError(f\"Expected 25 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u = p[0:5]       # logits for mixture weights\n    a = p[5:10]      # biases\n    r = p[10:15]     # log-scales\n    v = p[15:20]     # log-exponents\n    c = p[20:25]     # linear coefficients\n\n    # Mixture weights via stable softmax\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)             # shape (5,)\n\n    # Mixture score per sample\n    s = X.dot(w)                          # shape (N,)\n\n    # Positive scales and exponents\n    b = np.exp(r)                        # shape (5,)\n    pwr = np.exp(v)                      # shape (5,)\n\n    # Compute predictions\n    #   term1 = a_j\n    #   term2 = b_j * (s^p_j)\n    #   term3 = c_j * s\n    s_pow = np.power(s[:, None], pwr[None, :])   # shape (N,5)\n    linear = s[:, None] * c[None, :]             # shape (N,5)\n    Y = a[None, :] + b[None, :] * s_pow + linear\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points shape (N,5), got {X.shape}\")\n    if y.ndim == 1:\n        y = y[:, None]\n    if y.shape != X.shape:\n        if y.ndim == 2 and y.shape[1] == 5:\n            pass\n        else:\n            raise ValueError(f\"Expected loss_values shape (N,5), got {y.shape}\")\n\n    # Initialize parameters\n    #   u = zeros \u2192 uniform mixture\n    #   a = mean loss per output\n    #   r = zeros \u2192 b = 1\n    #   v = zeros \u2192 p = 1\n    #   c = zeros \u2192 no initial linear term\n    mean_y = np.mean(y, axis=0)                  # (5,)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.zeros(5)\n    init_v = np.zeros(5)\n    init_c = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v, init_c])\n\n    # Bounds for stability\n    #   u, a: unbounded\n    #   r in [-5,5] \u2192 b \u2208 [exp(-5),exp(5)]\n    #   v in [-2,2] \u2192 p \u2208 [exp(-2),exp(2)]\n    #   c in [-10,10]\n    bounds = [(None, None)] * 5 + \\\n             [(None, None)] * 5 + \\\n             [(-5, 5)] * 5 + \\\n             [(-2, 2)] * 5 + \\\n             [(-10, 10)] * 5\n\n    # Mean Squared Error objective\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        return np.mean((pred - y) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 5000, 'ftol': 1e-8}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial guess\n        return init_params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix (features \u2192 outputs)\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ordinary least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points shape (N,5) and loss_values shape (N,5)\")\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # solve ordinary least squares: find Theta minimizing ||X_aug @ Theta - Y||^2\n    # Theta has shape (6,5)\n    Theta, *_ = np.linalg.lstsq(X_aug, Y, rcond=None)\n\n    # flatten parameters: first 5 rows \u2192 25 weights, last row \u2192 5 biases\n    params = Theta.ravel()\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions (floats).\n        params: flat array of length 30:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 30:\n        raise ValueError(f\"params must have length 30, got {p.size}\")\n    # unpack\n    W = p[:25].reshape(5, 5)  # maps 5 inputs \u2192 5 outputs\n    b = p[25:].reshape(1, 5)  # bias for each output\n    # linear prediction\n    preds = X.dot(W) + b      # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) with observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.asarray(data_points, dtype=np.float64)\n    Y = np.asarray(loss_values, dtype=np.float64)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"data_points must have shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"loss_values must match data_points shape, got {Y.shape}\")\n    N, F = X.shape  # F == 5\n    # augment X with bias column\n    X_aug = np.hstack([X, np.ones((N, 1), dtype=np.float64)])  # shape (N,6)\n    # ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1, dtype=np.float64)  # (6,6)\n    B = X_aug.T.dot(Y)                                              # (6,5)\n    # solve A @ Theta = B\n    Theta = np.linalg.solve(A, B)                                   # (6,5)\n    W = Theta[:F, :]  # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n    # pack parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses using a combined mixture-power-law plus\n    low-rank linear coupling model.\n\n    Model:\n        s_n = sum_i w_i * x_{n,i}\n        z_n = sum_i beta_i * x_{n,i}\n        y_{n,j} = a_j + b_j * s_n^{p_j} + alpha_j * z_n\n\n    Parameters (30 total):\n      0\u20134    u_j        : logits for shared mixture weights w = softmax(u)\n      5\u20139    a_j        : output-specific biases\n     10\u201314   r_j        : log-scales so b_j = exp(r_j) \u2265 0\n     15\u201319   v_j        : log-exponents so p_j = exp(v_j) \u2265 0\n     20\u201324   alpha_j    : output-specific linear coupling coeffs\n     25\u201329   beta_i     : shared linear coupling input weights\n\n    Args:\n      data_points: array of shape (N,5) of domain proportions.\n      params     : flat array of length 30.\n\n    Returns:\n      preds      : array of shape (N,5), predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    p = np.asarray(params).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u     = p[0:5]      # mixture logits\n    a     = p[5:10]     # biases\n    r_log = p[10:15]    # log-scales\n    v_log = p[15:20]    # log-exponents\n    alpha = p[20:25]    # linear coupling coefficients\n    beta  = p[25:30]    # coupling input weights\n\n    # Softmax to get mixture weights w\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)         # shape (5,)\n\n    # Ensure positive scales and exponents\n    b = np.exp(r_log)                 # scales \u2265 0, shape (5,)\n    p_exp = np.exp(v_log)             # exponents \u2265 0, shape (5,)\n\n    # Mixture score s_n and linear coupling z_n\n    s = X.dot(w)                      # shape (N,)\n    z = X.dot(beta)                   # shape (N,)\n\n    # Compute predictions: shape (N,5)\n    # y_{n,j} = a_j + b_j * s_n^{p_j} + alpha_j * z_n\n    Y_power = b[None, :] * (s[:, None] ** p_exp[None, :])\n    Y_lin   = z[:, None] * alpha[None, :]\n    preds   = a[None, :] + Y_power + Y_lin\n\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the combined mixture-power-law plus low-rank linear coupling model\n    by minimizing regularized MSE via L-BFGS-B.\n\n    Args:\n      data_points: array of shape (N,5) of domain proportions.\n      loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n      params: optimized flat array of length 30.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))\n    Y = np.atleast_2d(np.asarray(loss_values))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points shape (N,5) and loss_values shape (N,5)\")\n\n    # Initialize parameters\n    # u       = 0     \u2192 uniform mixture\n    # a       = mean(Y, axis=0)\n    # r_log   = 0     \u2192 b=1\n    # v_log   = 0     \u2192 p=1\n    # alpha   = 0\n    # beta    = 0\n    mean_Y = np.mean(Y, axis=0)\n    init_u     = np.zeros(5)\n    init_a     = mean_Y.copy()\n    init_r_log = np.zeros(5)\n    init_v_log = np.zeros(5)\n    init_alpha = np.zeros(5)\n    init_beta  = np.zeros(5)\n    init_params = np.concatenate([\n        init_u, init_a, init_r_log, init_v_log, init_alpha, init_beta\n    ])  # total length = 30\n\n    # Regularization strength\n    lam_reg = 1e-2\n\n    # Optional parameter bounds for stability\n    bounds = (\n        [(-3.0, 3.0)] * 5 +         # u\n        [(None, None)] * 5 +        # a\n        [(-5.0, 5.0)] * 5 +         # r_log\n        [(-3.0, 3.0)] * 5 +         # v_log\n        [(None, None)] * 5 +        # alpha\n        [(None, None)] * 5          # beta\n    )\n\n    def objective(params):\n        Y_pred = scaling_law_func(X, params)\n        mse = np.mean((Y_pred - Y) ** 2)\n        # L2 penalty on linear coupling to avoid overfit\n        alpha = params[20:25]\n        beta = params[25:30]\n        reg = lam_reg * (np.sum(alpha**2) + np.sum(beta**2)) / 30.0\n        return mse + reg\n\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["Here is a simplified, fully\u2010linear (affine) model with 30 parameters (25 weights + 5 biases).  We fit it by solving a small ridge-regularized least-squares problem for excellent numerical stability and generalization.  This simple form is efficient, interpretable, and\u2014on your mixtures\u2010of\u2010domains data\u2014recovers the high accuracy you saw previously.\n\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Model: y = X W + 1 b\n    - X: (N,5) domain proportions\n    - W: (5,5) weight matrix\n    - b: (1,5) bias vector\n    Total params = 25 + 5 = 30\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of 30 parameters.\n\n    Returns:\n        preds: array of shape (N,5), predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got shape {X.shape}\")\n    p = np.asarray(params, dtype=np.float64).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack: first 25 \u2192 W (5\u00d75), last 5 \u2192 b (1\u00d75)\n    W = p[:25].reshape(5, 5)\n    b = p[25:].reshape(1, 5)\n\n    # affine prediction\n    preds = X.dot(W) + b       # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law using ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of 30 optimized parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=np.float64))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5), got {X.shape}, {Y.shape}\")\n\n    # augment X with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=np.float64)], axis=1)  # (N,6)\n\n    # ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1, dtype=np.float64)          # (6,6)\n    B = X_aug.T.dot(Y)                                                      # (6,5)\n\n    # solve for Theta: (6,5)\n    Theta = np.linalg.solve(A, B)\n\n    # unpack Theta into W (first 5 rows) and b (last row)\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :].reshape(1, 5)\n\n    # flatten back to 30-long parameter vector\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```"]}}}