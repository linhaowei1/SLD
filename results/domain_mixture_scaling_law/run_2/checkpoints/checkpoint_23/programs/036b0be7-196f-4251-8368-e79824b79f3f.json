{"id": "036b0be7-196f-4251-8368-e79824b79f3f", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture-based power law with shared exponent.\n\nModel:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p}\n\nwhere\n    w = softmax(u) \u2208 \u0394^4   (5 logits \u2192 5 mixture weights)\n    b_j = exp(r_j) \u2265 0     (5 scale parameters)\n    p = exp(v) \u2265 0         (single shared exponent)\n    a_j \u2208 \u211d                (5 bias terms)\n\nTotal parameters = 5 (u) + 5 (a) + 5 (r) + 1 (v) = 16 \u2264 35\n\nThis compact form reduces over\u2010parameterization, improves\nnumerical stability via bounding r and v during optimization,\nand maintains strong cross\u2010domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _softmax(logits):\n    \"\"\"Compute stable softmax over 1D array.\"\"\"\n    shifted = logits - np.max(logits)\n    exps = np.exp(shifted)\n    return exps / np.sum(exps)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses for given domain proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (16,)\n            [u(5), a(5), r(5), v(1)]\n\n    Returns:\n        Y_pred: ndarray, shape (N, 5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    prm = np.ravel(params).astype(float)\n    if prm.size != 16:\n        raise ValueError(f\"Expected 16 parameters, got {prm.size}\")\n\n    # Unpack parameters\n    u = prm[0:5]       # logits for mixture weights\n    a = prm[5:10]      # biases for each output\n    r = prm[10:15]     # log\u2010scales\n    v = prm[15]        # log\u2010exponent (shared)\n\n    # Transform to valid domains\n    w = _softmax(u)          # mixture weights \u2208 \u0394^4\n    b = np.exp(r)            # scales \u2265 0\n    p = np.exp(v)            # exponent \u2265 0\n\n    # Mixture score per sample\n    s = X.dot(w)             # (N,)\n\n    # Predict: Y[n, j] = a_j + b_j * s[n]^p\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p)\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 16 parameters of the scaling law by minimizing MSE.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n        loss_values: array-like, shape (N, 5)\n\n    Returns:\n        params_opt: ndarray, shape (16,)\n            Optimized parameters [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(\"Expected input with 5 domain proportions\")\n    y2d = y if y.ndim == 2 else y[:, None]\n    if y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 loss outputs\")\n\n    # Initialization:\n    #   u = 0     \u2192 uniform mixture\n    #   a = mean  \u2192 bias approx\n    #   r = 0     \u2192 scale b = 1\n    #   v = 0     \u2192 exponent p = 1\n    init = np.zeros(16, dtype=float)\n    init[5:10] = np.mean(y2d, axis=0)\n\n    # Bounds for robustness:\n    #   u[0:5], a[5:10]: unconstrained\n    #   r[10:15] \u2208 [-5, 5]   \u2192 b \u2208 [e\u207b\u2075, e\u2075]\n    #   v[15]    \u2208 [-2, 2]   \u2192 p \u2208 [e\u207b\u00b2, e\u00b2]\n    bounds = [(None, None)] * 16\n    for i in range(10, 15):\n        bounds[i] = (-5.0, 5.0)\n    bounds[15] = (-2.0, 2.0)\n\n    def objective(prm):\n        pred = scaling_law_func(X, prm)\n        return np.mean((pred - y2d) ** 2)\n\n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    return result.x if result.success else init\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "94478eca-3444-471e-8801-7f3e3626b8ab", "generation": 2, "timestamp": 1754716231.7045279, "iteration_found": 9, "metrics": {"nmse": 0.03641933229667162, "nmae": 0.1500079071206273, "r2": 0.9635806677033284, "combined_score": 0.964860427471989}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.07810695144910622, "nmae": 0.23880202179478766, "r2": 0.9218930485508938, "combined_score": 0.9275517597357841}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0781\n- nmae: 0.2388\n- r2: 0.9219\n- combined_score: 0.9276\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 1.2056, nmae: 0.8637, r2: -0.2056, combined_score: 0.4534\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0781, nmae: 0.2388, r2: 0.9219, combined_score: 0.9276\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5416)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law: mixture-based power law with shared domain mixture weights.\n\nWe model each output loss as:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p_j}\n\nParameters (20 total):\n    u (5):    unnormalized logits for domain-mixture weights w = softmax(u)\n    a (5):    output-specific biases\n    r (5):    log-scales so that b = exp(r) >= 0\n    v (5):    log-exponents so that p = exp(v) >= 0\n\nThis parameterization uses 20 parameters (\u2264 35), enforces positivity\nfor mixture weights, scales, and exponents, and shares the same\nmixture across all outputs for efficiency and cross-domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points))  # shape (N, 5)\n    prm = np.asarray(params).reshape(-1)\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture logits -> softmax weights\n    u = prm[0:5]                          # (5,)\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)             # (5,)\n\n    # 2) Output-specific parameters\n    a = prm[5:10]                         # bias terms, (5,)\n    r = prm[10:15]                        # log-scale terms\n    v = prm[15:20]                        # log-exponent terms\n\n    b = np.exp(r)                         # scale >= 0, (5,)\n    p = np.exp(v)                         # exponent >= 0, (5,)\n\n    # 3) Compute the mixture score for each sample\n    #    s_n = sum_i w_i * x_{n,i}\n    s = X.dot(w)                          # (N,)\n\n    # 4) Predict each output\n    #    y_{n,j} = a_j + b_j * s_n^{p_j}\n    # Broadcasting to (N, 5)\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    y = np.asarray(loss_values)\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    N, F = X.shape\n    if F != 5 or y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 domain proportions and 5 loss outputs\")\n\n    # Parameter vector length = 20\n    # Initialize:\n    #   u = 0           => uniform mixture weights\n    #   a = mean(y)     => bias approx\n    #   r = 0           => scale b = 1\n    #   v = 0           => exponent p = 1\n    mean_y = np.mean(y2d, axis=0)               # (5,)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.zeros(5)\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])  # (20,)\n\n    # Objective: mean squared error\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        return np.mean((pred - y2d) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective, init_params, method='L-BFGS-B')\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0781), Performs well on nmae (0.2388), Performs well on r2 (0.9219), Performs well on combined_score (0.9276)\n\n\n### Program 2 (Score: 0.5793)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nInitial program with a simple power law form that can be evolved\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    N, F = X.shape\n    params = np.asarray(params)\n\n    if params.ndim == 1:\n        params = params[None, :]                         # (1, P)\n    T, P = params.shape\n\n    coeffs    = params[:, :F]                            # (T, F)\n    exponents = params[:, F:2*F]                         # (T, F)\n    bias      = params[:, -1]                            # (T,)\n\n    pred = (coeffs[None, :, :] * (X[:, None, :] ** exponents[None, :, :])).sum(axis=2) + bias[None, :]\n\n    return pred[:, 0] if pred.shape[1] == 1 else pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    y = np.asarray(loss_values)\n    N, F = X.shape\n    P = 2 * F + 1\n\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    T = y2d.shape[1]\n\n    init = np.ones((T, P))\n\n    def objective(flat_params):\n        params = flat_params.reshape(T, P)\n        pred = scaling_law_func(X, params)               # (N, T)\n        mse = np.mean((pred - y2d) ** 2)\n        return mse\n\n    result = minimize(objective, init.ravel(), method='BFGS')\n    params_opt = result.x.reshape(T, P) if result.success else init\n\n    return params_opt[0] if T == 1 else params_opt\n# EVOLVE-BLOCK-END\n\n```\nKey features: Performs well on nmse (1.2056), Performs well on nmae (0.8637), Performs well on r2 (-0.2056), Performs well on combined_score (0.4534)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5793, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nScaling law discovery for LLM finetuning scenarios\nInitial program with a simple power law form that can be evolved\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    N, F = X.shape\n    params = np.asarray(params)\n\n    if params.ndim == 1:\n        params = params[None, :]                         # (1, P)\n    T, P = params.shape\n\n    coeffs    = params[:, :F]                            # (T, F)\n    exponents = params[:, F:2*F]                         # (T, F)\n    bias      = params[:, -1]                            # (T,)\n\n    pred = (coeffs[None, :, :] * (X[:, None, :] ** exponents[None, :, :])).sum(axis=2) + bias[None, :]\n\n    return pred[:, 0] if pred.shape[1] == 1 else pred\n\n\ndef fit_scaling_law(data_points, loss_values):\n\n    X = np.atleast_2d(np.asarray(data_points))           # (N, F)\n    y = np.asarray(loss_values)\n    N, F = X.shape\n    P = 2 * F + 1\n\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    T = y2d.shape[1]\n\n    init = np.ones((T, P))\n\n    def objective(flat_params):\n        params = flat_params.reshape(T, P)\n        pred = scaling_law_func(X, params)               # (N, T)\n        mse = np.mean((pred - y2d) ** 2)\n        return mse\n\n    result = minimize(objective, init.ravel(), method='BFGS')\n    params_opt = result.x.reshape(T, P) if result.success else init\n\n    return params_opt[0] if T == 1 else params_opt\n# EVOLVE-BLOCK-END\n\n```\nUnique approach: Excellent nmse (1.206), Alternative r2 approach, NumPy-based implementation\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law: mixture-based power law with shared domain mixture weights.\n\nWe model each output loss as:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p_j}\n\nParameters (20 total):\n    u (5):    unnormalized logits for domain-mixture weights w = softmax(u)\n    a (5):    output-specific biases\n    r (5):    log-scales so that b = exp(r) >= 0\n    v (5):    log-exponents so that p = exp(v) >= 0\n\nThis parameterization uses 20 parameters (\u2264 35), enforces positivity\nfor mixture weights, scales, and exponents, and shares the same\nmixture across all outputs for efficiency and cross-domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points))  # shape (N, 5)\n    prm = np.asarray(params).reshape(-1)\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture logits -> softmax weights\n    u = prm[0:5]                          # (5,)\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)             # (5,)\n\n    # 2) Output-specific parameters\n    a = prm[5:10]                         # bias terms, (5,)\n    r = prm[10:15]                        # log-scale terms\n    v = prm[15:20]                        # log-exponent terms\n\n    b = np.exp(r)                         # scale >= 0, (5,)\n    p = np.exp(v)                         # exponent >= 0, (5,)\n\n    # 3) Compute the mixture score for each sample\n    #    s_n = sum_i w_i * x_{n,i}\n    s = X.dot(w)                          # (N,)\n\n    # 4) Predict each output\n    #    y_{n,j} = a_j + b_j * s_n^{p_j}\n    # Broadcasting to (N, 5)\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    y = np.asarray(loss_values)\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    N, F = X.shape\n    if F != 5 or y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 domain proportions and 5 loss outputs\")\n\n    # Parameter vector length = 20\n    # Initialize:\n    #   u = 0           => uniform mixture weights\n    #   a = mean(y)     => bias approx\n    #   r = 0           => scale b = 1\n    #   v = 0           => exponent p = 1\n    mean_y = np.mean(y2d, axis=0)               # (5,)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.zeros(5)\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])  # (20,)\n\n    # Objective: mean squared error\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        return np.mean((pred - y2d) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective, init_params, method='L-BFGS-B')\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture-based power law with shared exponent.\n\nModel:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p}\n\nwhere\n    w = softmax(u) \u2208 \u0394^4   (5 logits \u2192 5 mixture weights)\n    b_j = exp(r_j) \u2265 0     (5 scale parameters)\n    p = exp(v) \u2265 0         (single shared exponent)\n    a_j \u2208 \u211d                (5 bias terms)\n\nTotal parameters = 5 (u) + 5 (a) + 5 (r) + 1 (v) = 16 \u2264 35\n\nThis compact form reduces over\u2010parameterization, improves\nnumerical stability via bounding r and v during optimization,\nand maintains strong cross\u2010domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _softmax(logits):\n    \"\"\"Compute stable softmax over 1D array.\"\"\"\n    shifted = logits - np.max(logits)\n    exps = np.exp(shifted)\n    return exps / np.sum(exps)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses for given domain proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (16,)\n            [u(5), a(5), r(5), v(1)]\n\n    Returns:\n        Y_pred: ndarray, shape (N, 5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    prm = np.ravel(params).astype(float)\n    if prm.size != 16:\n        raise ValueError(f\"Expected 16 parameters, got {prm.size}\")\n\n    # Unpack parameters\n    u = prm[0:5]       # logits for mixture weights\n    a = prm[5:10]      # biases for each output\n    r = prm[10:15]     # log\u2010scales\n    v = prm[15]        # log\u2010exponent (shared)\n\n    # Transform to valid domains\n    w = _softmax(u)          # mixture weights \u2208 \u0394^4\n    b = np.exp(r)            # scales \u2265 0\n    p = np.exp(v)            # exponent \u2265 0\n\n    # Mixture score per sample\n    s = X.dot(w)             # (N,)\n\n    # Predict: Y[n, j] = a_j + b_j * s[n]^p\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p)\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 16 parameters of the scaling law by minimizing MSE.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n        loss_values: array-like, shape (N, 5)\n\n    Returns:\n        params_opt: ndarray, shape (16,)\n            Optimized parameters [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(\"Expected input with 5 domain proportions\")\n    y2d = y if y.ndim == 2 else y[:, None]\n    if y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 loss outputs\")\n\n    # Initialization:\n    #   u = 0     \u2192 uniform mixture\n    #   a = mean  \u2192 bias approx\n    #   r = 0     \u2192 scale b = 1\n    #   v = 0     \u2192 exponent p = 1\n    init = np.zeros(16, dtype=float)\n    init[5:10] = np.mean(y2d, axis=0)\n\n    # Bounds for robustness:\n    #   u[0:5], a[5:10]: unconstrained\n    #   r[10:15] \u2208 [-5, 5]   \u2192 b \u2208 [e\u207b\u2075, e\u2075]\n    #   v[15]    \u2208 [-2, 2]   \u2192 p \u2208 [e\u207b\u00b2, e\u00b2]\n    bounds = [(None, None)] * 16\n    for i in range(10, 15):\n        bounds[i] = (-5.0, 5.0)\n    bounds[15] = (-2.0, 2.0)\n\n    def objective(prm):\n        pred = scaling_law_func(X, prm)\n        return np.mean((pred - y2d) ** 2)\n\n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    return result.x if result.success else init\n# EVOLVE-BLOCK-END\n```"]}}}