{"id": "ac0000e3-944c-429c-9ecc-c2c904efe250", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient shared\u2010mixture polynomial model:\n  each output domain loss is modeled as a quadratic polynomial of a\n  shared mixture score derived from the 5 domain proportions.\nTotal parameters = 5 logits (u) + 3\u00d75 polynomial coeffs (\u0398) = 20 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 20:\n                     - first  5 entries \u2192 logits u for mixture weights\n                     - next 15 entries \u2192 polynomial coefficients \u0398 of shape (3,5)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                    # (5,) logits\n    Theta = p[5:].reshape(3, 5)   # (3,5) polynomial coefficients\n\n    # stable softmax \u2192 mixture weights w\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)     # (5,)\n\n    # compute shared mixture score\n    s = X.dot(w)                  # (N,)\n\n    # build polynomial features [1, s, s^2]\n    N = X.shape[0]\n    phi = np.vstack([\n        np.ones(N, dtype=float),\n        s,\n        s**2\n    ]).T                          # (N,3)\n\n    # predict losses: (N,3) @ (3,5) \u2192 (N,5)\n    preds = phi.dot(Theta)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture polynomial scaling law via L-BFGS-B optimization.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 20 (5 logits + 15 \u0398 coefficients).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    N, F = X.shape\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values of shape ({N},5), got {Y.shape}\")\n\n    # initialize logits to uniform mixture\n    init_u = np.zeros(5, dtype=float)\n\n    # compute initial mixture score and polynomial features\n    w0 = np.ones(5, dtype=float) / 5\n    s0 = X.dot(w0)\n    phi0 = np.vstack([np.ones(N), s0, s0**2]).T  # (N,3)\n\n    # ridge\u2010regularized least squares to initialize \u0398\n    lam = 1e-6\n    A = phi0.T.dot(phi0) + lam * np.eye(3)\n    B = phi0.T.dot(Y)                             # (3,5)\n    Theta0 = np.linalg.solve(A, B)                # (3,5)\n\n    # pack initial parameters\n    init_params = np.concatenate([init_u, Theta0.ravel()])  # length 20\n\n    # regularization weight on u to avoid extreme mixtures\n    lam_reg = 1e-3\n\n    # objective: MSE + small L2 penalty on logits\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        mse = np.mean((pred - Y) ** 2)\n        u = p[0:5]\n        reg = lam_reg * np.sum(u ** 2) / 5\n        return mse + reg\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n\n    return result.x if result.success else init_params\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "9928d126-5495-4cda-8df0-436170513010", "generation": 3, "timestamp": 1754716536.3712234, "iteration_found": 47, "metrics": {"nmse": 0.04567564936024402, "nmae": 0.1772007942693849, "r2": 0.954324350639756, "combined_score": 0.9563194864600808}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.020984518891261763, "nmae": 0.13039018342445088, "r2": 0.9790154811087383, "combined_score": 0.9794467805309625}, "island": 4}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0210\n- nmae: 0.1304\n- r2: 0.9790\n- combined_score: 0.9794\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0210, nmae: 0.1304, r2: 0.9790, combined_score: 0.9794\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30, interpreted as a (6\u00d75) matrix:\n                - first 5 rows: weight matrix (5 weights per output)\n                - last 1 row:  bias vector (1 bias per output)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    # reshape params into theta of shape (6,5)\n    theta = np.asarray(params, dtype=float).ravel()\n    assert theta.size == 30, f\"Expected 30 parameters, got {theta.size}\"\n    theta = theta.reshape(6, 5)  # (5 weights + 1 bias) for each of 5 outputs\n\n    # augment inputs with a bias feature of 1s\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # compute predictions\n    preds = X_aug.dot(theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (6\u00d75 matrix flattened).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # solve for theta in A @ theta = B\n    theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # return flattened parameters\n    return theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5275)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient affine+quadratic model:\neach output loss is a weighted sum of the five domain proportions,\nplus a domain\u2010specific weight on the total squared proportion,\nplus a bias. Total parameters = 5\u00d75 (weights) + 5 (quadratic coeffs) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 linear weight matrix W of shape (5,5)\n                     - next 5 entries    \u2192 quadratic coefficients c of shape (5,)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # linear weights\n    c = p[25:30].reshape(1, 5)    # quadratic coeffs\n    b = p[30:35].reshape(1, 5)    # biases\n\n    # compute sum of squares of proportions for each sample\n    sum_sq = np.sum(X * X, axis=1, keepdims=True)  # shape (N,1)\n\n    # linear term\n    lin = X.dot(W)                                # shape (N,5)\n    # quadratic correction and bias\n    preds = lin + sum_sq.dot(c) + b               # broadcasting to (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine+quadratic scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 linear + 5 quadratic + 5 bias).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n    N = X.shape[0]\n\n    # feature augmentation:\n    #  - original 5 proportions\n    #  - sum of squares of proportions (one feature)\n    #  - constant bias term (one feature)\n    sum_sq = np.sum(X * X, axis=1, keepdims=True)      # (N,1)\n    bias_feat = np.ones((N, 1), dtype=float)           # (N,1)\n    X_aug = np.hstack([X, sum_sq, bias_feat])          # (N,7)\n\n    # ridge\u2010regularized normal equations\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(X_aug.shape[1])  # (7,7)\n    B = X_aug.T.dot(Y)                                     # (7,5)\n\n    Theta = np.linalg.solve(A, B)                          # (7,5)\n\n    # unpack Theta into parameters\n    W = Theta[:5, :]        # (5,5) linear weights\n    c = Theta[5, :].ravel() # (5,) quadratic coeffs\n    b = Theta[6, :].ravel() # (5,) biases\n\n    # flatten into a single parameter vector\n    params = np.concatenate([W.ravel(), c, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0210), Performs well on nmae (0.1304), Performs well on r2 (0.9790), Performs well on combined_score (0.9794)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5287)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture-based power law with shared exponent.\n\nModel:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p}\n\nwhere\n    w = softmax(u) \u2208 \u0394^4   (5 logits \u2192 5 mixture weights)\n    b_j = exp(r_j) \u2265 0     (5 scale parameters)\n    p = exp(v) \u2265 0         (single shared exponent)\n    a_j \u2208 \u211d                (5 bias terms)\n\nTotal parameters = 5 (u) + 5 (a) + 5 (r) + 1 (v) = 16 \u2264 35\n\nThis compact form reduces over\u2010parameterization, improves\nnumerical stability via bounding r and v during optimization,\nand maintains strong cross\u2010domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _softmax(logits):\n    \"\"\"Compute stable softmax over 1D array.\"\"\"\n    shifted = logits - np.max(logits)\n    exps = np.exp(shifted)\n    return exps / np.sum(exps)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses for given domain proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (16,)\n            [u(5), a(5), r(5), v(1)]\n\n    Returns:\n        Y_pred: ndarray, shape (N, 5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    prm = np.ravel(params).astype(float)\n    if prm.size != 16:\n        raise ValueError(f\"Expected 16 parameters, got {prm.size}\")\n\n    # Unpack parameters\n    u = prm[0:5]       # logits for mixture weights\n    a = prm[5:10]      # biases for each output\n    r = prm[10:15]     # log\u2010scales\n    v = prm[15]        # log\u2010exponent (shared)\n\n    # Transform to valid domains\n    w = _softmax(u)          # mixture weights \u2208 \u0394^4\n    b = np.exp(r)            # scales \u2265 0\n    p = np.exp(v)            # exponent \u2265 0\n\n    # Mixture score per sample\n    s = X.dot(w)             # (N,)\n\n    # Predict: Y[n, j] = a_j + b_j * s[n]^p\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p)\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 16 parameters of the scaling law by minimizing MSE.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n        loss_values: array-like, shape (N, 5)\n\n    Returns:\n        params_opt: ndarray, shape (16,)\n            Optimized parameters [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(\"Expected input with 5 domain proportions\")\n    y2d = y if y.ndim == 2 else y[:, None]\n    if y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 loss outputs\")\n\n    # Initialization:\n    #   u = 0     \u2192 uniform mixture\n    #   a = mean  \u2192 bias approx\n    #   r = 0     \u2192 scale b = 1\n    #   v = 0     \u2192 exponent p = 1\n    init = np.zeros(16, dtype=float)\n    init[5:10] = np.mean(y2d, axis=0)\n\n    # Bounds for robustness:\n    #   u[0:5], a[5:10]: unconstrained\n    #   r[10:15] \u2208 [-5, 5]   \u2192 b \u2208 [e\u207b\u2075, e\u2075]\n    #   v[15]    \u2208 [-2, 2]   \u2192 p \u2208 [e\u207b\u00b2, e\u00b2]\n    bounds = [(None, None)] * 16\n    for i in range(10, 15):\n        bounds[i] = (-5.0, 5.0)\n    bounds[15] = (-2.0, 2.0)\n\n    def objective(prm):\n        pred = scaling_law_func(X, prm)\n        return np.mean((pred - y2d) ** 2)\n\n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    return result.x if result.success else init\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5307)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a shared\u2010mixture power\u2010law per output to capture nonlinear\nbehavior with only 20 parameters:\n  \u2022 5 logits (u) \u2192 mixture weights via softmax\n  \u2022 5 biases (a)\n  \u2022 5 log\u2010scales (r) \u2192 scale = exp(r)\n  \u2022 5 log\u2010exponents (v) \u2192 exponent = exp(v)\nThis model is more expressive than a purely linear mixture, yet\nremains parameter\u2010efficient and numerically stable.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of 20 parameters:\n                [0:5]   \u2192 logits u for mixture weights\n                [5:10]  \u2192 biases a_j\n                [10:15] \u2192 log\u2010scales r_j (scale b_j = exp(r_j))\n                [15:20] \u2192 log\u2010exponents v_j (exponent p_j = exp(v_j))\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    \n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # 1) Compute mixture weights w = softmax(u)\n    u = p[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                # shape (5,)\n\n    # 2) Extract output\u2010specific parameters\n    a = p[5:10]                              # biases (5,)\n    r = p[10:15]                             # log\u2010scales (5,)\n    v = p[15:20]                             # log\u2010exponents (5,)\n    b = np.exp(r)                            # scales \u2265 0 (5,)\n    p_exp = np.exp(v)                        # exponents \u2265 0 (5,)\n\n    # 3) Mixture score for each example\n    s = X.dot(w)                             # shape (N,)\n\n    # 4) Predict each domain loss: y_j = a_j + b_j * s^p_j\n    # Broadcast to shape (N,5)\n    Y = a[np.newaxis, :] + b[np.newaxis, :] * (s[:, np.newaxis] ** p_exp[np.newaxis, :])\n    return Y\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture power\u2010law scaling function via L-BFGS-B optimization.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of 20 optimized parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected shapes: data_points (N,5), loss_values (N,5)\")\n\n    # Initialize:\n    #  u = 0       \u2192 uniform mixture\n    #  a = mean(Y) \u2192 bias approx\n    #  r = log(std(Y)) \u2192 scale approx\n    #  v = 0       \u2192 exponent \u2248 1\n    mean_y = np.mean(Y, axis=0)\n    std_y  = np.std(Y, axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])\n\n    # Regularization to keep r and v well\u2010behaved\n    lam_reg = 1e-2\n\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        mse = np.mean((pred - Y) ** 2)\n        # L2 penalty on log\u2010scales and log\u2010exponents\n        r = params[10:15]\n        v = params[15:20]\n        reg = lam_reg * (np.sum(r**2) + np.sum(v**2)) / params.size\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    if result.success:\n        return result.x\n    else:\n        # Fallback: return initialization\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5459, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient nonlinear mixture model:\n 1. Project 5-domain proportions onto a single mixture score s via a learned softmax.\n 2. For each output domain j: y_j = a_j + b_j\u00b7s + c_j\u00b7s\u00b2\nTotal parameters = 5 (u logits) + 5 (a biases) + 5 (b linear) + 5 (c quadratic) = 20 \u2264 35.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 20:\n                     - u (0:5)  : logits for mixture weights (5,)\n                     - a (5:10) : intercepts per output (5,)\n                     - b (10:15): linear coeffs per output (5,)\n                     - c (15:20): quadratic coeffs per output (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]       # logits for mixture weights\n    a = p[5:10]      # intercepts\n    b = p[10:15]     # linear terms\n    c = p[15:20]     # quadratic terms\n\n    # stable softmax \u2192 mixture weights w\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)            # shape (5,)\n\n    # mixture score per sample\n    s = X.dot(w)                         # shape (N,)\n\n    # compute predictions: y_j = a_j + b_j * s + c_j * s^2\n    s_col = s[:, None]                   # (N,1)\n    preds = a[None, :] + b[None, :] * s_col + c[None, :] * (s_col**2)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear mixture scaling law via L-BFGS-B.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 20.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape ({N},5), got {Y.shape}\")\n\n    # initialize parameters\n    init_u = np.zeros(5)              # uniform mixture\n    init_a = np.mean(Y, axis=0)       # start at mean loss\n    init_b = np.zeros(5)              # no linear tilt\n    init_c = np.zeros(5)              # no quadratic tilt\n    init_params = np.concatenate([init_u, init_a, init_b, init_c])\n\n    # bounds: keep quadratic terms modest to avoid wild curvature\n    bounds = [(None, None)] * 10 + [(-5, 5)] * 5 + [(-1, 1)] * 5\n\n    # mean squared error objective\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        return np.mean((pred - Y) ** 2)\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 5000, 'ftol': 1e-8}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to the initial affine guess\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient affine model:\neach output loss is a weighted sum of the five domain proportions plus a bias.\nTotal parameters = 5 outputs \u00d7 (5 weights + 1 bias) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 30, interpreted as a (6\u00d75) matrix:\n                - first 5 rows: weight matrix (5 weights per output)\n                - last 1 row:  bias vector (1 bias per output)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    # reshape params into theta of shape (6,5)\n    theta = np.asarray(params, dtype=float).ravel()\n    assert theta.size == 30, f\"Expected 30 parameters, got {theta.size}\"\n    theta = theta.reshape(6, 5)  # (5 weights + 1 bias) for each of 5 outputs\n\n    # augment inputs with a bias feature of 1s\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # compute predictions\n    preds = X_aug.dot(theta)  # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (6\u00d75 matrix flattened).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape ({N},5), got {Y.shape}\"\n\n    # augment inputs with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # solve for theta in A @ theta = B\n    theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # return flattened parameters\n    return theta.ravel()\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5350, Type: Experimental)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses using a shared mixture score and a quadratic\n    polynomial per output domain.\n\n    Model:\n        w = softmax(u)                      -- shared mixture weights over domains\n        s = X @ w                           -- mixture score per sample\n        y_j = theta0_j + theta1_j * s + theta2_j * s^2\n\n    Parameters (20 total):\n        u (5)       : unnormalized logits \u2192 mixture weights w (via softmax)\n        Theta (15)  : 3\u00d75 matrix of polynomial coefficients\n                      Theta[0, j] = intercept for domain j\n                      Theta[1, j] = linear coefficient for domain j\n                      Theta[2, j] = quadratic coefficient for domain j\n\n    Args:\n        data_points: array of shape (N,5) of domain mixture proportions.\n        params     : flat array of length 20 = 5 (u) + 15 (Theta).\n\n    Returns:\n        preds      : array of shape (N,5), the predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # unpack parameters\n    u      = p[:5]             # (5,)\n    Theta  = p[5:].reshape(3, 5)  # (3,5)\n\n    # compute softmax mixture weights (stable)\n    u_max  = np.max(u)\n    exp_u  = np.exp(u - u_max)\n    w      = exp_u / np.sum(exp_u)   # (5,)\n\n    # mixture score per sample\n    s      = X.dot(w)                # (N,)\n\n    # build polynomial features [1, s, s^2]\n    phi    = np.vstack([np.ones(N), s, s**2]).T  # (N,3)\n\n    # predict\n    preds  = phi.dot(Theta)          # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the quadratic\u2010mixture scaling law by optimizing both the shared\n    mixture logits u and the per\u2010output polynomial coefficients Theta.\n\n    Uses L-BFGS-B to minimize mean squared error.\n\n    Args:\n        data_points : array of shape (N,5) of domain mixture proportions.\n        loss_values : array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params      : optimized flat array of length 20.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape {(N,5)}, got {Y.shape}\")\n\n    # Initialize u so that w emphasizes the first domain slightly\n    init_u = np.zeros(5)\n    init_u[0] = 1.0\n    # Compute initial mixture score and features\n    exp_u0 = np.exp(init_u - np.max(init_u))\n    w0     = exp_u0 / np.sum(exp_u0)\n    s0     = X.dot(w0)\n    phi0   = np.vstack([np.ones(N), s0, s0**2]).T  # (N,3)\n\n    # Solve for initial Theta by ridge\u2010regularized least squares\n    lam    = 1e-6\n    A      = phi0.T.dot(phi0) + lam * np.eye(3)\n    B      = phi0.T.dot(Y)                         # (3,5)\n    Theta0 = np.linalg.solve(A, B)                 # (3,5)\n\n    # pack initial parameters\n    init_params = np.concatenate([init_u, Theta0.ravel()])  # length 20\n\n    # objective: mean squared error\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        return np.mean((pred - Y)**2)\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 2000, 'ftol': 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial guess if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5307, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a shared\u2010mixture power\u2010law per output to capture nonlinear\nbehavior with only 20 parameters:\n  \u2022 5 logits (u) \u2192 mixture weights via softmax\n  \u2022 5 biases (a)\n  \u2022 5 log\u2010scales (r) \u2192 scale = exp(r)\n  \u2022 5 log\u2010exponents (v) \u2192 exponent = exp(v)\nThis model is more expressive than a purely linear mixture, yet\nremains parameter\u2010efficient and numerically stable.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of 20 parameters:\n                [0:5]   \u2192 logits u for mixture weights\n                [5:10]  \u2192 biases a_j\n                [10:15] \u2192 log\u2010scales r_j (scale b_j = exp(r_j))\n                [15:20] \u2192 log\u2010exponents v_j (exponent p_j = exp(v_j))\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    \n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # 1) Compute mixture weights w = softmax(u)\n    u = p[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                # shape (5,)\n\n    # 2) Extract output\u2010specific parameters\n    a = p[5:10]                              # biases (5,)\n    r = p[10:15]                             # log\u2010scales (5,)\n    v = p[15:20]                             # log\u2010exponents (5,)\n    b = np.exp(r)                            # scales \u2265 0 (5,)\n    p_exp = np.exp(v)                        # exponents \u2265 0 (5,)\n\n    # 3) Mixture score for each example\n    s = X.dot(w)                             # shape (N,)\n\n    # 4) Predict each domain loss: y_j = a_j + b_j * s^p_j\n    # Broadcast to shape (N,5)\n    Y = a[np.newaxis, :] + b[np.newaxis, :] * (s[:, np.newaxis] ** p_exp[np.newaxis, :])\n    return Y\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture power\u2010law scaling function via L-BFGS-B optimization.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of 20 optimized parameters.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected shapes: data_points (N,5), loss_values (N,5)\")\n\n    # Initialize:\n    #  u = 0       \u2192 uniform mixture\n    #  a = mean(Y) \u2192 bias approx\n    #  r = log(std(Y)) \u2192 scale approx\n    #  v = 0       \u2192 exponent \u2248 1\n    mean_y = np.mean(Y, axis=0)\n    std_y  = np.std(Y, axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])\n\n    # Regularization to keep r and v well\u2010behaved\n    lam_reg = 1e-2\n\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        mse = np.mean((pred - Y) ** 2)\n        # L2 penalty on log\u2010scales and log\u2010exponents\n        r = params[10:15]\n        v = params[15:20]\n        reg = lam_reg * (np.sum(r**2) + np.sum(v**2)) / params.size\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n    if result.success:\n        return result.x\n    else:\n        # Fallback: return initialization\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient affine+quadratic model:\neach output loss is a weighted sum of the five domain proportions,\nplus a domain\u2010specific weight on the total squared proportion,\nplus a bias. Total parameters = 5\u00d75 (weights) + 5 (quadratic coeffs) + 5 (biases) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 linear weight matrix W of shape (5,5)\n                     - next 5 entries    \u2192 quadratic coefficients c of shape (5,)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)      # linear weights\n    c = p[25:30].reshape(1, 5)    # quadratic coeffs\n    b = p[30:35].reshape(1, 5)    # biases\n\n    # compute sum of squares of proportions for each sample\n    sum_sq = np.sum(X * X, axis=1, keepdims=True)  # shape (N,1)\n\n    # linear term\n    lin = X.dot(W)                                # shape (N,5)\n    # quadratic correction and bias\n    preds = lin + sum_sq.dot(c) + b               # broadcasting to (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine+quadratic scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 linear + 5 quadratic + 5 bias).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n    N = X.shape[0]\n\n    # feature augmentation:\n    #  - original 5 proportions\n    #  - sum of squares of proportions (one feature)\n    #  - constant bias term (one feature)\n    sum_sq = np.sum(X * X, axis=1, keepdims=True)      # (N,1)\n    bias_feat = np.ones((N, 1), dtype=float)           # (N,1)\n    X_aug = np.hstack([X, sum_sq, bias_feat])          # (N,7)\n\n    # ridge\u2010regularized normal equations\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(X_aug.shape[1])  # (7,7)\n    B = X_aug.T.dot(Y)                                     # (7,5)\n\n    Theta = np.linalg.solve(A, B)                          # (7,5)\n\n    # unpack Theta into parameters\n    W = Theta[:5, :]        # (5,5) linear weights\n    c = Theta[5, :].ravel() # (5,) quadratic coeffs\n    b = Theta[6, :].ravel() # (5,) biases\n\n    # flatten into a single parameter vector\n    params = np.concatenate([W.ravel(), c, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient shared\u2010mixture polynomial model:\n  each output domain loss is modeled as a quadratic polynomial of a\n  shared mixture score derived from the 5 domain proportions.\nTotal parameters = 5 logits (u) + 3\u00d75 polynomial coeffs (\u0398) = 20 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 20:\n                     - first  5 entries \u2192 logits u for mixture weights\n                     - next 15 entries \u2192 polynomial coefficients \u0398 of shape (3,5)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                    # (5,) logits\n    Theta = p[5:].reshape(3, 5)   # (3,5) polynomial coefficients\n\n    # stable softmax \u2192 mixture weights w\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)     # (5,)\n\n    # compute shared mixture score\n    s = X.dot(w)                  # (N,)\n\n    # build polynomial features [1, s, s^2]\n    N = X.shape[0]\n    phi = np.vstack([\n        np.ones(N, dtype=float),\n        s,\n        s**2\n    ]).T                          # (N,3)\n\n    # predict losses: (N,3) @ (3,5) \u2192 (N,5)\n    preds = phi.dot(Theta)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture polynomial scaling law via L-BFGS-B optimization.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 20 (5 logits + 15 \u0398 coefficients).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    N, F = X.shape\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values of shape ({N},5), got {Y.shape}\")\n\n    # initialize logits to uniform mixture\n    init_u = np.zeros(5, dtype=float)\n\n    # compute initial mixture score and polynomial features\n    w0 = np.ones(5, dtype=float) / 5\n    s0 = X.dot(w0)\n    phi0 = np.vstack([np.ones(N), s0, s0**2]).T  # (N,3)\n\n    # ridge\u2010regularized least squares to initialize \u0398\n    lam = 1e-6\n    A = phi0.T.dot(phi0) + lam * np.eye(3)\n    B = phi0.T.dot(Y)                             # (3,5)\n    Theta0 = np.linalg.solve(A, B)                # (3,5)\n\n    # pack initial parameters\n    init_params = np.concatenate([init_u, Theta0.ravel()])  # length 20\n\n    # regularization weight on u to avoid extreme mixtures\n    lam_reg = 1e-3\n\n    # objective: MSE + small L2 penalty on logits\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        mse = np.mean((pred - Y) ** 2)\n        u = p[0:5]\n        reg = lam_reg * np.sum(u ** 2) / 5\n        return mse + reg\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n\n    return result.x if result.success else init_params\n# EVOLVE-BLOCK-END\n```"]}}}