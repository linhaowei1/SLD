{"id": "7b3b054c-5820-4619-bb55-a1babb51b4c5", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient power\u2010law + linear model:\n  each input proportion is raised to a learned exponent,\n  then linearly combined into each output loss.\n\nModel form:\n  y_j = \u2211_i W[j,i] * (x_i)^{p_i} + b_j\n\nTotal parameters = 5 log\u2010exponents (u_i) + 25 weights (W) + 5 biases (b) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                       - params[0:5]   \u2192 log\u2010exponents u_i (so p_i = exp(u_i))\n                       - params[5:30]  \u2192 weight matrix W of shape (5,5), row\u2010major\n                       - params[30:35] \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {X.shape[1]}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u = p[0:5]                            # (5,) log\u2010exponents\n    W = p[5:30].reshape(5, 5)             # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)            # (1,5) bias vector\n\n    # Exponents (strictly positive)\n    exponents = np.exp(u)                 # (5,)\n\n    # Raise each feature to its learned exponent\n    # proportions in [0,1], so 0^p = 0 is fine.\n    Xp = np.power(X, exponents)           # (N,5)\n\n    # Affine combination\n    preds = Xp.dot(W.T) + b               # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the power\u2010law + linear weights model by minimizing a composite loss:\n      objective = MSE + \u03bb_mae * MAE + \u03bb_w * ||W||\u00b2 + \u03bb_u * ||u||\u00b2\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5); got {X.shape}, {Y.shape}\")\n\n    # --- Initialization ---\n    # Start with p_i \u2248 1 (u_i = 0) and W,b from a small\u2010ridge linear fit Y ~ X\n    lam_ridge = 1e-6\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)   # (N,6)\n    A = X_aug.T.dot(X_aug) + lam_ridge * np.eye(F + 1)      # (6,6)\n    B = X_aug.T.dot(Y)                                      # (6,5)\n    Theta = np.linalg.solve(A, B)                          # (6,5)\n    W0 = Theta[:F, :].T                                     # (5,5)\n    b0 = Theta[F, :]                                        # (5,)\n\n    init_u = np.zeros(5)                                    # log\u2010exponents = 0 \u21d2 p_i = 1\n    init_params = np.concatenate([init_u, W0.ravel(), b0])  # (35,)\n\n    # Bounds: keep u in [-3,3] \u21d2 exponents in [exp(-3), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # Regularization strengths\n    lam_w   = 1e-4   # on weights W\n    lam_u   = 1e-2   # on log\u2010exponents u\n    lam_mae = 0.1    # weight for MAE term\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        diff = Y_pred - Y\n        mse = np.mean(diff**2)\n        mae = np.mean(np.abs(diff))\n        # extract sub\u2010vectors for regularization\n        u_vec = p_flat[0:5]\n        W_vec = p_flat[5:30]\n        reg = lam_w * np.mean(W_vec**2) + lam_u * np.mean(u_vec**2)\n        return mse + lam_mae * mae + reg\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization on failure\n        return init_params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "42b6b453-7e14-44a8-831f-f831282e1a85", "generation": 3, "timestamp": 1754716123.460811, "iteration_found": 46, "metrics": {"nmse": 0.018360804339811472, "nmae": 0.13690427617636788, "r2": 0.9816391956601885, "combined_score": 0.9819702366179396}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.17989728558797988, "nmae": 0.450522508633481, "r2": 0.8201027144120201, "combined_score": 0.8475314014318361}, "island": 3}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.1799\n- nmae: 0.4505\n- r2: 0.8201\n- combined_score: 0.8475\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0106, nmae: 0.0961, r2: 0.9894, combined_score: 0.9896\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5214)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a compact non\u2010linear model:\n    y_j = a_j + sign(s_j) * |s_j|^p\nwhere s_j = \u2211_k W[j,k] * x_k and p is a shared positive exponent.\nTotal parameters = 5\u00d75 (W) + 5 (a) + 1 (log_p) = 31 \u2264 35.\n\nThis model learns a bias per domain and a single exponent to capture\nnonlinear interactions among domain\u2010mixture proportions.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 31:\n            - first 25 entries \u2192 weight matrix W of shape (5,5)\n            - next 5 entries   \u2192 bias vector a of shape (5,)\n            - last 1 entry     \u2192 log_p (scalar exponent)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {X.shape[1]}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 31:\n        raise ValueError(f\"Expected 31 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix (5\u00d75)\n    a = p[25:30].reshape(1, 5)   # bias vector (1\u00d75)\n    log_p = p[30]               # log\u2010exponent\n\n    # enforce positive exponent\n    exponent = np.exp(log_p)\n\n    # linear scores per domain\n    S = X.dot(W.T)              # shape (N,5)\n\n    # signed power transform\n    S_sign = np.sign(S)\n    S_abs = np.abs(S) + 1e-12   # stability term\n    Y = a + S_sign * (S_abs ** exponent)\n    return Y\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the non\u2010linear scaling law parameters via L\u2010BFGS\u2010B.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 31 (optimized).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected shapes (N,5) for data_points and loss_values\")\n\n    # initialize W and a by ridge regression (linear fit)\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n    lam0 = 1e-6\n    A = X_aug.T.dot(X_aug) + lam0 * np.eye(F + 1)\n    B = X_aug.T.dot(Y)\n    Theta = np.linalg.solve(A, B)        # (6,5)\n    W_init = Theta[:F, :].T.ravel()      # 25 entries\n    a_init = Theta[F, :].ravel()         # 5 entries\n\n    # start with exponent = 1 (log_p = 0)\n    init_params = np.concatenate([W_init, a_init, [0.0]])\n\n    # L2 regularization on W to keep weights bounded\n    lam_reg = 1e-4\n\n    def objective(params):\n        Y_pred = scaling_law_func(X, params)\n        mse = np.mean((Y_pred - Y) ** 2)\n        # regularize only the linear weights\n        reg = lam_reg * np.sum(params[:25] ** 2)\n        return mse + reg\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n\n    if not result.success:\n        # fallback to the linear init if optimization fails\n        return init_params\n    return result.x\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0106), Performs well on nmae (0.0961), Performs well on r2 (0.9894), Performs well on combined_score (0.9896)\n\n\n### Program 2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient power\u2010law + linear model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 log\u2010exponents + 25 linear weights + 5 biases = 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - [0:5]:   log-exponents u (so p = exp(u))\n                - [5:30]:  weight matrix W of shape (5,5), row-major\n                - [30:35]: bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected 5 input features, got {X.shape[1]}\")\n    p_flat = np.asarray(params, dtype=float).ravel()\n    if p_flat.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p_flat.size}\")\n\n    # Unpack parameters\n    u = p_flat[0:5]                          # (5,) log\u2010exponents\n    W = p_flat[5:30].reshape(5, 5)           # (5,5) weight matrix\n    b = p_flat[30:35].reshape(1, 5)          # (1,5) bias vector\n\n    # Exponents (strictly positive)\n    exponents = np.exp(u)                    # (5,)\n\n    # Raise each feature to its learned exponent\n    # proportions are in [0,1], exponents > 0, so 0^p = 0 is fine.\n    X_p = np.power(X, exponents)             # (N,5)\n\n    # Affine combination\n    preds = X_p.dot(W.T) + b                 # (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the power\u2010law + linear weights model by minimizing a composite loss:\n      MSE + 0.1*MAE + L2\u2010regularization on u and W.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5); got {X.shape}, {Y.shape}\")\n\n    # --- Initialization ---\n    # Start with p_i \u2248 1 (u_i = 0) and W,b from a small\u2010ridge linear fit Y ~ X\n    lam_ridge = 1e-6\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    A = X_aug.T.dot(X_aug) + lam_ridge * np.eye(F + 1)     # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n    W0 = Theta[:F, :].T                                    # (5,5)\n    b0 = Theta[F, :]                                       # (5,)\n\n    init_u = np.zeros(5)                                   # log\u2010exponents = 0 \u21d2 p_i = 1\n    init_params = np.concatenate([init_u, W0.ravel(), b0]) # (35,)\n\n    # Bounds: keep u in [-2,2] \u21d2 exponents in [exp(-2), exp(2)] \u2248 [0.14, 7.39]\n    bounds = [(-2.0, 2.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # Regularization strengths\n    lam_w   = 1e-4   # on W\n    lam_u   = 1e-2   # on u\n    lam_mae = 0.1    # weight for MAE term\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        diff = Y_pred - Y\n        mse = np.mean(diff**2)\n        mae = np.mean(np.abs(diff))\n        # L2 penalties\n        u_vec = p_flat[0:5]\n        W_vec = p_flat[5:30]\n        reg = lam_w * np.mean(W_vec**2) + lam_u * np.mean(u_vec**2)\n        return mse + lam_mae * mae + reg\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)     # linear weights\n    b = p[25:].reshape(1, 5)     # biases\n\n    # affine prediction\n    preds = X.dot(W) + b         # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape (N,5), got {Y.shape}\")\n\n    # augment inputs with a constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization (small \u03bb for numerical stability)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)   # (6,6)\n    B = X_aug.T.dot(Y)                             # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                  # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]   # (5,5)\n    b = Theta[F:, :].reshape(5)  # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5275)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear + quadratic mixture\u2010uniformity model:\ny_j = sum_k W[j,k] * x_k + v_j * (sum_k x_k^2) + b_j\nTotal parameters = 5\u00d75 (W) + 5 (v) + 5 (b) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - next 5 entries   \u2192 quadratic\u2010mixture slopes v of shape (5,)\n                     - last 5 entries   \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)     # linear weights\n    v = p[25:30].reshape(1, 5)   # mixture\u2010uniformity slopes\n    b = p[30:35].reshape(1, 5)   # biases\n\n    # mixture\u2010uniformity feature: sum of squares of proportions\n    S = (X ** 2).sum(axis=1, keepdims=True)  # (N,1)\n\n    # prediction: linear part + quadratic\u2010mixture part + bias\n    preds = X.dot(W) + S.dot(v) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel() + v + b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # build augmented feature matrix: [X | S | 1]\n    S = (X ** 2).sum(axis=1, keepdims=True)      # (N,1)\n    X_aug = np.concatenate([X, S, np.ones((N, 1))], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    D = F + 2  # 5 linear + 1 quadratic + 1 bias\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)      # (7,7)\n    B = X_aug.T.dot(Y)                            # (7,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                 # (7,5)\n\n    # unpack into W, v, b\n    W = Theta[:F, :]      # (5,5)\n    v = Theta[F, :]       # (5,)\n    b = Theta[F + 1, :]   # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5214, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a compact non\u2010linear model:\n    y_j = a_j + sign(s_j) * |s_j|^p\nwhere s_j = \u2211_k W[j,k] * x_k and p is a shared positive exponent.\nTotal parameters = 5\u00d75 (W) + 5 (a) + 1 (log_p) = 31 \u2264 35.\n\nThis model learns a bias per domain and a single exponent to capture\nnonlinear interactions among domain\u2010mixture proportions.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 31:\n            - first 25 entries \u2192 weight matrix W of shape (5,5)\n            - next 5 entries   \u2192 bias vector a of shape (5,)\n            - last 1 entry     \u2192 log_p (scalar exponent)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {X.shape[1]}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 31:\n        raise ValueError(f\"Expected 31 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix (5\u00d75)\n    a = p[25:30].reshape(1, 5)   # bias vector (1\u00d75)\n    log_p = p[30]               # log\u2010exponent\n\n    # enforce positive exponent\n    exponent = np.exp(log_p)\n\n    # linear scores per domain\n    S = X.dot(W.T)              # shape (N,5)\n\n    # signed power transform\n    S_sign = np.sign(S)\n    S_abs = np.abs(S) + 1e-12   # stability term\n    Y = a + S_sign * (S_abs ** exponent)\n    return Y\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the non\u2010linear scaling law parameters via L\u2010BFGS\u2010B.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 31 (optimized).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected shapes (N,5) for data_points and loss_values\")\n\n    # initialize W and a by ridge regression (linear fit)\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n    lam0 = 1e-6\n    A = X_aug.T.dot(X_aug) + lam0 * np.eye(F + 1)\n    B = X_aug.T.dot(Y)\n    Theta = np.linalg.solve(A, B)        # (6,5)\n    W_init = Theta[:F, :].T.ravel()      # 25 entries\n    a_init = Theta[F, :].ravel()         # 5 entries\n\n    # start with exponent = 1 (log_p = 0)\n    init_params = np.concatenate([W_init, a_init, [0.0]])\n\n    # L2 regularization on W to keep weights bounded\n    lam_reg = 1e-4\n\n    def objective(params):\n        Y_pred = scaling_law_func(X, params)\n        mse = np.mean((Y_pred - Y) ** 2)\n        # regularize only the linear weights\n        reg = lam_reg * np.sum(params[:25] ** 2)\n        return mse + reg\n\n    # optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method='L-BFGS-B',\n        options={'maxiter': 500, 'ftol': 1e-9}\n    )\n\n    if not result.success:\n        # fallback to the linear init if optimization fails\n        return init_params\n    return result.x\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)     # linear weights\n    b = p[25:].reshape(1, 5)     # biases\n\n    # affine prediction\n    preds = X.dot(W) + b         # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))  # (N,5)\n\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape (N,5), got {Y.shape}\")\n\n    # augment inputs with a constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization (small \u03bb for numerical stability)\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)   # (6,6)\n    B = X_aug.T.dot(Y)                             # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                  # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]   # (5,5)\n    b = Theta[F:, :].reshape(5)  # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient power\u2010law + linear model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 log\u2010exponents + 25 linear weights + 5 biases = 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - [0:5]:   log-exponents u (so p = exp(u))\n                - [5:30]:  weight matrix W of shape (5,5), row-major\n                - [30:35]: bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected 5 input features, got {X.shape[1]}\")\n    p_flat = np.asarray(params, dtype=float).ravel()\n    if p_flat.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p_flat.size}\")\n\n    # Unpack parameters\n    u = p_flat[0:5]                          # (5,) log\u2010exponents\n    W = p_flat[5:30].reshape(5, 5)           # (5,5) weight matrix\n    b = p_flat[30:35].reshape(1, 5)          # (1,5) bias vector\n\n    # Exponents (strictly positive)\n    exponents = np.exp(u)                    # (5,)\n\n    # Raise each feature to its learned exponent\n    # proportions are in [0,1], exponents > 0, so 0^p = 0 is fine.\n    X_p = np.power(X, exponents)             # (N,5)\n\n    # Affine combination\n    preds = X_p.dot(W.T) + b                 # (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the power\u2010law + linear weights model by minimizing a composite loss:\n      MSE + 0.1*MAE + L2\u2010regularization on u and W.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5); got {X.shape}, {Y.shape}\")\n\n    # --- Initialization ---\n    # Start with p_i \u2248 1 (u_i = 0) and W,b from a small\u2010ridge linear fit Y ~ X\n    lam_ridge = 1e-6\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    A = X_aug.T.dot(X_aug) + lam_ridge * np.eye(F + 1)     # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n    W0 = Theta[:F, :].T                                    # (5,5)\n    b0 = Theta[F, :]                                       # (5,)\n\n    init_u = np.zeros(5)                                   # log\u2010exponents = 0 \u21d2 p_i = 1\n    init_params = np.concatenate([init_u, W0.ravel(), b0]) # (35,)\n\n    # Bounds: keep u in [-2,2] \u21d2 exponents in [exp(-2), exp(2)] \u2248 [0.14, 7.39]\n    bounds = [(-2.0, 2.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # Regularization strengths\n    lam_w   = 1e-4   # on W\n    lam_u   = 1e-2   # on u\n    lam_mae = 0.1    # weight for MAE term\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        diff = Y_pred - Y\n        mse = np.mean(diff**2)\n        mae = np.mean(np.abs(diff))\n        # L2 penalties\n        u_vec = p_flat[0:5]\n        W_vec = p_flat[5:30]\n        reg = lam_w * np.mean(W_vec**2) + lam_u * np.mean(u_vec**2)\n        return mse + lam_mae * mae + reg\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5275, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear + quadratic mixture\u2010uniformity model:\ny_j = sum_k W[j,k] * x_k + v_j * (sum_k x_k^2) + b_j\nTotal parameters = 5\u00d75 (W) + 5 (v) + 5 (b) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - next 5 entries   \u2192 quadratic\u2010mixture slopes v of shape (5,)\n                     - last 5 entries   \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)     # linear weights\n    v = p[25:30].reshape(1, 5)   # mixture\u2010uniformity slopes\n    b = p[30:35].reshape(1, 5)   # biases\n\n    # mixture\u2010uniformity feature: sum of squares of proportions\n    S = (X ** 2).sum(axis=1, keepdims=True)  # (N,1)\n\n    # prediction: linear part + quadratic\u2010mixture part + bias\n    preds = X.dot(W) + S.dot(v) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed domain losses.\n\n    Returns:\n        params: flat array of length 35 (W.ravel() + v + b).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape (N,5), got {Y.shape}\"\n\n    # build augmented feature matrix: [X | S | 1]\n    S = (X ** 2).sum(axis=1, keepdims=True)      # (N,1)\n    X_aug = np.concatenate([X, S, np.ones((N, 1))], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    D = F + 2  # 5 linear + 1 quadratic + 1 bias\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)      # (7,7)\n    B = X_aug.T.dot(Y)                            # (7,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                 # (7,5)\n\n    # unpack into W, v, b\n    W = Theta[:F, :]      # (5,5)\n    v = Theta[F, :]       # (5,)\n    b = Theta[F + 1, :]   # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), v, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient hybrid linear + power\u2010law model:\n  y_j = a_j + l_j * s + b_j * s^{p_j}, \nwhere s = \u03a3_i w_i x_i is a shared mixture score.\nTotal parameters = 5 (mixture logits) \n                   + 5 (biases a) \n                   + 5 (linear coeffs l) \n                   + 5 (log-scales r \u2192 b = exp(r)) \n                   + 5 (log-exponents v \u2192 p = exp(v)) \n                 = 25 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 25:\n                     - params[0:5]   \u2192 mixture logits u for w = softmax(u)\n                     - params[5:10]  \u2192 biases a_j for each output j\n                     - params[10:15] \u2192 linear coeffs l_j for each output j\n                     - params[15:20] \u2192 log\u2010scales r_j so that b_j = exp(r_j)\n                     - params[20:25] \u2192 log\u2010exponents v_j so that p_j = exp(v_j)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params).ravel()\n    if p.size != 25:\n        raise ValueError(f\"Expected 25 parameters, got {p.size}\")\n\n    # 1) Softmax mixture weights\n    u = p[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                    # (5,)\n\n    # 2) Output\u2010specific parameters\n    a = p[5:10]                                  # biases (5,)\n    l = p[10:15]                                 # linear coeffs (5,)\n    r = p[15:20]                                 # log\u2010scales (5,)\n    v = p[20:25]                                 # log\u2010exponents (5,)\n\n    b = np.exp(r)                                # nonlinear scale \u2265 0\n    p_exp = np.exp(v)                            # exponent \u2265 0\n\n    # 3) Compute mixture score s for each sample\n    s = X.dot(w)                                 # (N,)\n\n    # 4) Predict each output: y_j = a_j + l_j * s + b_j * s^{p_j}\n    # Broadcasting shapes to (N,5)\n    lin_term = l[None, :] * s[:, None]           # (N,5)\n    pow_term = b[None, :] * np.power(s[:, None], p_exp[None, :])  # (N,5)\n    preds = a[None, :] + lin_term + pow_term     # (N,5)\n\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the hybrid scaling law via L-BFGS-B minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 25.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected data_points shape (N,5) and loss_values shape (N,5)\")\n\n    # Initialize parameters\n    # mixture logits u = 0 \u2192 uniform w\n    init_u = np.zeros(5)\n    # biases ~ mean of each output\n    init_a = np.mean(Y, axis=0)\n    # linear coeffs = 0\n    init_l = np.zeros(5)\n    # log\u2010scales r = 0 \u2192 b = 1\n    init_r = np.zeros(5)\n    # log\u2010exponents v = 0 \u2192 p = 1\n    init_v = np.zeros(5)\n\n    init_params = np.concatenate([init_u, init_a, init_l, init_r, init_v])  # (25,)\n\n    # objective: mean squared error\n    def objective(p_flat):\n        preds = scaling_law_func(X, p_flat)\n        return np.mean((preds - Y) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective, init_params, method='L-BFGS-B')\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization on failure\n        return init_params\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient power\u2010law + linear model:\n  each input proportion is raised to a learned exponent,\n  then linearly combined into each output loss.\n\nModel form:\n  y_j = \u2211_i W[j,i] * (x_i)^{p_i} + b_j\n\nTotal parameters = 5 log\u2010exponents (u_i) + 25 weights (W) + 5 biases (b) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                       - params[0:5]   \u2192 log\u2010exponents u_i (so p_i = exp(u_i))\n                       - params[5:30]  \u2192 weight matrix W of shape (5,5), row\u2010major\n                       - params[30:35] \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points with 5 columns, got {X.shape[1]}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u = p[0:5]                            # (5,) log\u2010exponents\n    W = p[5:30].reshape(5, 5)             # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)            # (1,5) bias vector\n\n    # Exponents (strictly positive)\n    exponents = np.exp(u)                 # (5,)\n\n    # Raise each feature to its learned exponent\n    # proportions in [0,1], so 0^p = 0 is fine.\n    Xp = np.power(X, exponents)           # (N,5)\n\n    # Affine combination\n    preds = Xp.dot(W.T) + b               # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the power\u2010law + linear weights model by minimizing a composite loss:\n      objective = MSE + \u03bb_mae * MAE + \u03bb_w * ||W||\u00b2 + \u03bb_u * ||u||\u00b2\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 log\u2010exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected X shape (N,5) and Y shape (N,5); got {X.shape}, {Y.shape}\")\n\n    # --- Initialization ---\n    # Start with p_i \u2248 1 (u_i = 0) and W,b from a small\u2010ridge linear fit Y ~ X\n    lam_ridge = 1e-6\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)   # (N,6)\n    A = X_aug.T.dot(X_aug) + lam_ridge * np.eye(F + 1)      # (6,6)\n    B = X_aug.T.dot(Y)                                      # (6,5)\n    Theta = np.linalg.solve(A, B)                          # (6,5)\n    W0 = Theta[:F, :].T                                     # (5,5)\n    b0 = Theta[F, :]                                        # (5,)\n\n    init_u = np.zeros(5)                                    # log\u2010exponents = 0 \u21d2 p_i = 1\n    init_params = np.concatenate([init_u, W0.ravel(), b0])  # (35,)\n\n    # Bounds: keep u in [-3,3] \u21d2 exponents in [exp(-3), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # Regularization strengths\n    lam_w   = 1e-4   # on weights W\n    lam_u   = 1e-2   # on log\u2010exponents u\n    lam_mae = 0.1    # weight for MAE term\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        diff = Y_pred - Y\n        mse = np.mean(diff**2)\n        mae = np.mean(np.abs(diff))\n        # extract sub\u2010vectors for regularization\n        u_vec = p_flat[0:5]\n        W_vec = p_flat[5:30]\n        reg = lam_w * np.mean(W_vec**2) + lam_u * np.mean(u_vec**2)\n        return mse + lam_mae * mae + reg\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 1000, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization on failure\n        return init_params\n\n# EVOLVE-BLOCK-END\n```"]}}}