{"id": "4cb643d4-4085-4a9a-ae7b-4ff421a7868c", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a small 2-layer neural network (27 parameters):\n  Layer 1: 5 inputs \u2192 2 hidden units with tanh activation\n  Layer 2: 2 hidden units \u2192 5 outputs (linear)\nThis non\u2010linear mapper can capture simple interactions while remaining\nparameter\u2010efficient (\u2264 35 parameters) and easy to fit.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        params:      1D array of length 27:\n                       - W1: first 10 entries \u2192 (5 \u00d7 2) weight matrix for hidden layer\n                       - b1: next 2 entries  \u2192 (2,) bias for hidden layer\n                       - W2: next 10 entries \u2192 (2 \u00d7 5) weight matrix for output layer\n                       - b2: last 5 entries  \u2192 (5,) bias for output layer\n\n    Returns:\n        preds: ndarray of shape (N,5), the predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,5)\n    if X.ndim == 1:\n        X = X[np.newaxis, :]\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 27:\n        raise ValueError(f\"Expected 27 parameters, got {p.size}\")\n\n    # unpack parameters\n    idx = 0\n    W1 = p[idx:idx + 10].reshape(5, 2); idx += 10\n    b1 = p[idx:idx + 2].reshape(1, 2);     idx += 2\n    W2 = p[idx:idx + 10].reshape(2, 5);    idx += 10\n    b2 = p[idx:idx + 5].reshape(1, 5)\n\n    # forward pass\n    H = np.tanh(X.dot(W1) + b1)       # shape (N,2)\n    preds = H.dot(W2) + b2            # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2-layer scaling law by minimizing MSE via L-BFGS-B.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        loss_values: array\u2010like of shape (N,5) of observed losses.\n\n    Returns:\n        params_opt: ndarray of length 27, the optimized parameters.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n\n    # initialize parameters:\n    #  - W1 small random or zeros\n    #  - b1 zeros\n    #  - W2 zeros\n    #  - b2 set to mean observed losses for stability\n    init_params = np.zeros(27, dtype=float)\n    init_params[-5:] = Y.mean(axis=0)\n\n    # objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - Y\n        return np.mean(diff * diff)\n\n    # optimize with L-BFGS-B using numerical gradients\n    params_opt, _, _ = fmin_l_bfgs_b(_mse,\n                                     x0=init_params,\n                                     approx_grad=True,\n                                     maxiter=500,\n                                     disp=False)\n    return params_opt\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "887be37c-54e6-4c9e-af22-9a070c7e35d9", "generation": 2, "timestamp": 1754715994.761525, "iteration_found": 29, "metrics": {"nmse": 0.06224119934972646, "nmae": 0.24234028497312976, "r2": 0.9377588006502735, "combined_score": 0.9414057754605745}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.018360804339811472, "nmae": 0.13690427617636788, "r2": 0.9816391956601885, "combined_score": 0.9819702366179396}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0184\n- nmae: 0.1369\n- r2: 0.9816\n- combined_score: 0.9820\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0386, nmae: 0.1608, r2: 0.9614, combined_score: 0.9628\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 2 (Score: 0.5297)\n```python\n\"\"\"\nScaling\u2010law discovery for LLM multi\u2010domain loss prediction\nUsing a parameter\u2010efficient linear mixture\u2010of\u2010experts model:\n    y = X W + b\nwhere X \u2208 \u211d^(N\u00d75) are domain proportions and\n      W \u2208 \u211d^(5\u00d75), b \u2208 \u211d^5\nTotal learnable parameters = 25 + 5 = 30 \u2264 35\n\nWe fit (W, b) by ridge\u2010regularized least squares for numerical stability.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi\u2010domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row contains the 5 domain proportions (summing to 1).\n        params: 1D array, length 30\n            First 25 entries are W (5\u00d75, row\u2010major);\n            last 5 entries are bias vector b.\n\n    Returns:\n        preds: ndarray, shape (N, 5)\n            Predicted losses for each of the 5 domains.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected params of length 30, got {p.size}\")\n\n    # unpack W and b\n    W = p[:25].reshape(5, 5)    # W_{i\u2192j}: contribution of domain i to loss j\n    b = p[25:].reshape(1, 5)    # bias for each output domain\n\n    # linear prediction\n    preds = X.dot(W) + b        # shape (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear scaling\u2010law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array\u2010like, shape (N,5)\n            Domain mixture proportions.\n        loss_values: array\u2010like, shape (N,5)\n            Observed multi\u2010domain losses.\n\n    Returns:\n        params: 1D ndarray, length 30\n            Flattened [W (25), b (5)].\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n\n    N, F = X.shape  # F == 5\n    # augment X with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # ridge regularization parameter\n    lam = 1e-6\n    # normal equations with ridge: (X\u1d40X + \u03bbI) \u0398 = X\u1d40Y\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1, dtype=float)  # (6,6)\n    B = X_aug.T.dot(Y)                                        # (6,5)\n\n    # solve for \u0398 = [W; b]\u1d40  shape (6,5)\n    Theta = np.linalg.solve(A, B)  # (6,5)\n    W = Theta[:F, :]               # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5309)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture\u2010based power\u2010law scaling function with shared domain weights.\n\nModel:\n    y_{n,j} = a_j + b_j * (\u2211_{i=1}^5 w_i * x_{n,i})^{p_j}\n\nParameters (20 total):\n  u (5):   logits for domain mixture weights \u2192 w = softmax(u)\n  a (5):   bias terms per output domain\n  r (5):   log\u2010scales, so b = exp(r) \u2265 0\n  v (5):   log\u2010exponents, so p = exp(v) \u2265 0\n\nThis uses a single mixture across all outputs for efficiency\nand enforces positivity of scales and exponents via exp transforms.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\nfrom scipy.special import softmax\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain-mixture proportions.\n    Inputs:\n      data_points: array of shape (N,5)\n      params:       1D array of length 20\n    Output:\n      Y: array of shape (N,5) predictions\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected input with 5 features, got shape {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u = p[0:5]        # mixture logits\n    a = p[5:10]       # biases\n    r = p[10:15]      # log-scales\n    v = p[15:20]      # log-exponents\n\n    # Build positive weights, scales, exponents\n    w = softmax(u)          # shape (5,)\n    b = np.exp(r)           # shape (5,)\n    expo = np.exp(v)        # shape (5,)\n\n    # Mixture score per sample\n    s = X.dot(w)            # shape (N,)\n\n    # Compute output losses\n    # Broadcasting s**expo across outputs\n    Y = a + b * (s[:, None] ** expo[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the scaling law parameters to minimize MSE.\n    Inputs:\n      data_points: array (N,5)\n      loss_values: array (N,5)\n    Returns:\n      params_opt: array length 20\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(\"data_points must be shape (N,5)\")\n    if y.ndim == 1:\n        y = y[:, None]\n    if y.ndim != 2 or y.shape[1] != 5:\n        raise ValueError(\"loss_values must be shape (N,5)\")\n\n    # Initialize parameters:\n    #   u = 0 (uniform mixture), a = mean(y), r = 0 (b=1), v = 0 (expo=1)\n    init_params = np.zeros(20, dtype=float)\n    init_params[5:10] = y.mean(axis=0)\n\n    # Objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - y\n        return np.mean(diff * diff)\n\n    # Optimize with L-BFGS-B (gradients approximated numerically)\n    params_opt, _, _ = fmin_l_bfgs_b(_mse, init_params, approx_grad=True)\n    return params_opt\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0386), Performs well on nmae (0.1608), Performs well on r2 (0.9614), Performs well on combined_score (0.9628)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5309, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture\u2010based power\u2010law scaling function with shared domain weights.\n\nModel:\n    y_{n,j} = a_j + b_j * (\u2211_{i=1}^5 w_i * x_{n,i})^{p_j}\n\nParameters (20 total):\n  u (5):   logits for domain mixture weights \u2192 w = softmax(u)\n  a (5):   bias terms per output domain\n  r (5):   log\u2010scales, so b = exp(r) \u2265 0\n  v (5):   log\u2010exponents, so p = exp(v) \u2265 0\n\nThis uses a single mixture across all outputs for efficiency\nand enforces positivity of scales and exponents via exp transforms.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\nfrom scipy.special import softmax\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain-mixture proportions.\n    Inputs:\n      data_points: array of shape (N,5)\n      params:       1D array of length 20\n    Output:\n      Y: array of shape (N,5) predictions\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected input with 5 features, got shape {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {p.size}\")\n\n    # Unpack parameters\n    u = p[0:5]        # mixture logits\n    a = p[5:10]       # biases\n    r = p[10:15]      # log-scales\n    v = p[15:20]      # log-exponents\n\n    # Build positive weights, scales, exponents\n    w = softmax(u)          # shape (5,)\n    b = np.exp(r)           # shape (5,)\n    expo = np.exp(v)        # shape (5,)\n\n    # Mixture score per sample\n    s = X.dot(w)            # shape (N,)\n\n    # Compute output losses\n    # Broadcasting s**expo across outputs\n    Y = a + b * (s[:, None] ** expo[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the scaling law parameters to minimize MSE.\n    Inputs:\n      data_points: array (N,5)\n      loss_values: array (N,5)\n    Returns:\n      params_opt: array length 20\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(\"data_points must be shape (N,5)\")\n    if y.ndim == 1:\n        y = y[:, None]\n    if y.ndim != 2 or y.shape[1] != 5:\n        raise ValueError(\"loss_values must be shape (N,5)\")\n\n    # Initialize parameters:\n    #   u = 0 (uniform mixture), a = mean(y), r = 0 (b=1), v = 0 (expo=1)\n    init_params = np.zeros(20, dtype=float)\n    init_params[5:10] = y.mean(axis=0)\n\n    # Objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - y\n        return np.mean(diff * diff)\n\n    # Optimize with L-BFGS-B (gradients approximated numerically)\n    params_opt, _, _ = fmin_l_bfgs_b(_mse, init_params, approx_grad=True)\n    return params_opt\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a small 2-layer neural network (27 parameters):\n  Layer 1: 5 inputs \u2192 2 hidden units with tanh activation\n  Layer 2: 2 hidden units \u2192 5 outputs (linear)\nThis non\u2010linear mapper can capture simple interactions while remaining\nparameter\u2010efficient (\u2264 35 parameters) and easy to fit.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        params:      1D array of length 27:\n                       - W1: first 10 entries \u2192 (5 \u00d7 2) weight matrix for hidden layer\n                       - b1: next 2 entries  \u2192 (2,) bias for hidden layer\n                       - W2: next 10 entries \u2192 (2 \u00d7 5) weight matrix for output layer\n                       - b2: last 5 entries  \u2192 (5,) bias for output layer\n\n    Returns:\n        preds: ndarray of shape (N,5), the predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,5)\n    if X.ndim == 1:\n        X = X[np.newaxis, :]\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 27:\n        raise ValueError(f\"Expected 27 parameters, got {p.size}\")\n\n    # unpack parameters\n    idx = 0\n    W1 = p[idx:idx + 10].reshape(5, 2); idx += 10\n    b1 = p[idx:idx + 2].reshape(1, 2);     idx += 2\n    W2 = p[idx:idx + 10].reshape(2, 5);    idx += 10\n    b2 = p[idx:idx + 5].reshape(1, 5)\n\n    # forward pass\n    H = np.tanh(X.dot(W1) + b1)       # shape (N,2)\n    preds = H.dot(W2) + b2            # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2-layer scaling law by minimizing MSE via L-BFGS-B.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        loss_values: array\u2010like of shape (N,5) of observed losses.\n\n    Returns:\n        params_opt: ndarray of length 27, the optimized parameters.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n\n    # initialize parameters:\n    #  - W1 small random or zeros\n    #  - b1 zeros\n    #  - W2 zeros\n    #  - b2 set to mean observed losses for stability\n    init_params = np.zeros(27, dtype=float)\n    init_params[-5:] = Y.mean(axis=0)\n\n    # objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - Y\n        return np.mean(diff * diff)\n\n    # optimize with L-BFGS-B using numerical gradients\n    params_opt, _, _ = fmin_l_bfgs_b(_mse,\n                                     x0=init_params,\n                                     approx_grad=True,\n                                     maxiter=500,\n                                     disp=False)\n    return params_opt\n\n# EVOLVE-BLOCK-END\n```"]}}}