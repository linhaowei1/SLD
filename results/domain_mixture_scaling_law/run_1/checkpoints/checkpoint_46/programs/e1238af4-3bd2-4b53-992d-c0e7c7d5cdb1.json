{"id": "e1238af4-3bd2-4b53-992d-c0e7c7d5cdb1", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a nonlinear feature\u2010exponent model: each input proportion x_i \nis raised to a learned exponent p_i, then linearly combined into each output loss.\nTotal parameters = 5 exponents + 25 weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions via\n    a feature\u2010exponent nonlinear transform followed by an affine map.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                       - params[0:5]   = log\u2010exponents u (so p = exp(u))\n                       - params[5:30]  = weight matrix W of shape (5,5), row\u2010major,\n                                         where preds[:,j] = sum_i X^p[:,i] * W[j,i] + b[j]\n                       - params[30:35] = bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected 5 input features, got {X.shape[1]}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                          # (5,) logs of exponents\n    W = p[5:30].reshape(5, 5)           # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)          # (1,5) bias\n\n    # compute positive exponents\n    exponents = np.exp(u)               # (5,)\n\n    # nonlinear feature transform: x_i^p_i\n    Xp = np.power(X, exponents)         # (N,5)\n\n    # affine combination\n    preds = Xp.dot(W.T) + b             # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the feature\u2010exponent affine model by initializing from a ridge regression\n    and then refining all 35 parameters via L-BFGS-B to minimize MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (optimized log\u2010exponents, weights, biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_shapes (N,5), got {X.shape}, {Y.shape}\")\n\n    # 1) Ridge\u2010regularized linear fit to initialize W and b\n    #    Solve min ||X\u00b7W_lin + b_lin - Y||^2 + \u03bb||\u0398||^2\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    lam = 1e-6\n    D = F + 1\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)               # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n    Theta = np.linalg.solve(A, B)                          # (6,5)\n    W_lin = Theta[:F, :]                                   # (5,5)\n    b_lin = Theta[F, :]                                    # (5,)\n\n    # 2) Build initial parameter vector\n    #    - log\u2010exponents u_i = 0  (\u2192 p_i=1, identity transform)\n    #    - weights W[j,i] = W_lin[i,j]\n    #    - bias b = b_lin\n    init_u = np.zeros(5)\n    init_W = W_lin.T.ravel()\n    init_b = b_lin.copy()\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # 3) Set bounds: keep log\u2010exponents in [\u22123,3] for numerical stability\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # 4) Objective: mean squared error\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        return np.mean((Y_pred - Y) ** 2)\n\n    # 5) Optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n", "language": "python", "parent_id": "5d11a912-d9dd-4b24-ae03-85137b0ce61c", "generation": 4, "timestamp": 1754716102.840025, "iteration_found": 43, "metrics": {"nmse": 0.014284129665061637, "nmae": 0.11109173439444073, "r2": 0.9857158703349383, "combined_score": 0.9859170332579507}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.018360804339811472, "nmae": 0.13690427617636788, "r2": 0.9816391956601885, "combined_score": 0.9819702366179396}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0184\n- nmae: 0.1369\n- r2: 0.9816\n- combined_score: 0.9820\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0128, nmae: 0.1170, r2: 0.9872, combined_score: 0.9874\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0010, nmae: 0.0240, r2: 0.9990, combined_score: 0.9990\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5058)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear feature\u2010exponent model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 exponent\u2010log vector u (for positive exponents p=exp(u))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) logarithms of exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix W[j,i]\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # positive exponents\n    exponents = np.exp(u)              # p_i \u2265 0, (5,)\n\n    # nonlinear transform of inputs\n    # x_{n,i}^{p_i}\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # Initialization:\n    # - log\u2010exponents u_i = 0 \u2192 exponents p_i = 1 (identity)\n    # - weights W = 0\n    # - biases b = mean of each output\n    mean_Y = np.mean(Y, axis=0)                  # (5,)\n    init_u = np.zeros(5)                         # (5,)\n    init_W = np.zeros(25)                        # flattened (5\u00d75)\n    init_b = mean_Y.copy()                       # (5,)\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # Bound the log\u2010exponents to keep p_i in a reasonable range\n    # here u_i \u2208 [\u22123, 3] \u21d2 p_i \u2208 [exp(\u22123), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        # mean squared error\n        return np.mean((Y_pred - Y) ** 2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial params if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0010), Performs well on nmae (0.0240), Performs well on r2 (0.9990), Performs well on combined_score (0.9990)\n\n\n### Program 2 (Score: 0.5261)\n```python\n\"\"\"\nEnhanced scaling law for LLM multi-domain loss prediction:\nCombines a per-domain linear term with a shared-mixture power-law term.\nTotal parameters = 5 (u logits) + 5 (nonlin biases a) + 5 (log-scales r)\n                 + 5 (log-exponents v) + 5 (linear coefs c) = 25 \u2264 35\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a hybrid linear + shared-mixture power law per output.\n\n    Args:\n        data_points: array of shape (N,5) of domain proportions.\n        params:      flat array of length 25:\n                     - [0:5]:   unnormalized logits u for mixture weights w = softmax(u)\n                     - [5:10]:  non-linear biases a_j for each domain\n                     - [10:15]: log-scales r_j so that b_j = exp(r_j) >= 0\n                     - [15:20]: log-exponents v_j so that p_j = exp(v_j) >= 0\n                     - [20:25]: linear coefficients c_j for each domain\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of 5 domains.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 25:\n        raise ValueError(f\"Expected 25 parameters, got {p.size}\")\n\n    # 1) Mixture weights w = softmax(u)\n    u = p[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)          # shape (5,)\n\n    # 2) Unpack non-linear parameters\n    a = p[5:10]                        # non-linear biases (5,)\n    r = p[10:15]                       # log-scales (5,)\n    v = p[15:20]                       # log-exponents (5,)\n    b = np.exp(r)                      # scales >= 0 (5,)\n    expo = np.exp(v)                   # exponents >= 0 (5,)\n\n    # 3) Linear coefficients per domain\n    c = p[20:25]                       # linear multipliers on X[:,j]\n\n    # 4) Compute mixture score\n    s = X.dot(w)                       # shape (N,)\n\n    # 5) Predict: y_nj = a_j + c_j * x_nj + b_j * s_n^expo_j\n    #    Broadcast s_n^expo_j across domains\n    Y_nl = a[None, :] + b[None, :] * (s[:, None] ** expo[None, :])\n    Y_lin = X * c[None, :]             # shape (N,5)\n    Y = Y_nl + Y_lin\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the hybrid scaling law parameters via L-BFGS-B optimization.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 25 (optimized).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(\"data_points must be shape (N,5)\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(\"loss_values must be shape (N,5)\")\n\n    N = X.shape[0]\n\n    # Initialize parameters\n    #  u = 0         -> uniform mixture\n    #  a = mean(Y)   -> non-linear bias\n    #  r = log(std)  -> scale approx\n    #  v = 0         -> exponent \u2248 1\n    #  c = slope_j   -> init from linear regression per domain on its own proportion\n    mean_y = Y.mean(axis=0)\n    std_y = Y.std(axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n\n    # simple univariate slope estimate: cov(x_j, y_j)/var(x_j)\n    cov = np.sum((X - X.mean(axis=0)) * (Y - mean_y), axis=0)\n    var_x = np.sum((X - X.mean(axis=0))**2, axis=0) + 1e-6\n    init_c = cov / var_x\n    # clip extreme\n    init_c = np.clip(init_c, -10.0, 10.0)\n\n    init_params = np.concatenate([init_u, init_a, init_r, init_v, init_c])\n\n    # Regularization strengths\n    lam_rv = 1e-2    # on r and v\n    lam_c  = 1e-3    # on linear coefs\n\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        mse = np.mean((pred - Y)**2)\n        # L2 penalties\n        r = p[10:15]\n        v = p[15:20]\n        c = p[20:25]\n        reg = lam_rv*(np.sum(r**2)+np.sum(v**2))/10.0 + lam_c*np.sum(c**2)/5.0\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective,\n                      init_params,\n                      method='L-BFGS-B',\n                      options={'maxiter': 1000, 'ftol': 1e-9})\n    if result.success:\n        return result.x\n    else:\n        # fallback\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0128), Performs well on nmae (0.1170), Performs well on r2 (0.9872), Performs well on combined_score (0.9874)\n\n\n### Program 3 (Score: 0.5297)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a parameter\u2010efficient affine mixture\u2010of\u2010experts model.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # (5,5)\n    b = p[25:].reshape(1, 5)    # (1,5)\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine mixture\u2010of\u2010experts model by ridge\u2010regularized\n    least squares. Returns 30 parameters (25 weights + 5 biases).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) with observed domain losses.\n\n    Returns:\n        params: flat array of length 30.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Input shapes must be (N,5) for both data and losses\")\n\n    # Augment with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # Ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # Solve linear system A @ Theta = B\n    Theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # Extract weights and biases\n    W = Theta[:F, :]   # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n\n    # Flatten parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter-efficient affine model:\n    y = X W + b\nTotal parameters = 5\u00d75 (W) + 5 (b) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    \n    p = np.asarray(params).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)  # (5,5)\n    b = p[25:].reshape(1, 5)  # (1,5)\n\n    # affine prediction\n    preds = X.dot(W) + b      # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law by ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))  # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_points (N,5) and loss_values (N,5), got {X.shape}, {Y.shape}\")\n\n    # augment with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization\n    lam = 1e-6\n    D = F + 1  # 5 features + 1 bias\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)               # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack parameters\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten\n    params = np.concatenate([W.ravel(), b])\n    return params\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5058, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient nonlinear feature\u2010exponent model:\neach input proportion is raised to a learned exponent, then\nlinearly combined into each output loss.\n\nTotal parameters = 5 exponents + 25 linear weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - entries 0\u20134   \u2192 exponent\u2010log vector u (for positive exponents p=exp(u))\n                     - entries 5\u201329  \u2192 weight matrix W of shape (5,5), flattened row\u2010major\n                     - entries 30\u201334 \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    u = p[0:5]                         # (5,) logarithms of exponents\n    W = p[5:30].reshape(5, 5)          # (5,5) weight matrix W[j,i]\n    b = p[30:35].reshape(1, 5)         # (1,5) bias vector\n\n    # positive exponents\n    exponents = np.exp(u)              # p_i \u2265 0, (5,)\n\n    # nonlinear transform of inputs\n    # x_{n,i}^{p_i}\n    X_p = np.power(X, exponents)       # (N,5)\n\n    # affine combination\n    preds = X_p.dot(W.T) + b           # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the nonlinear exponent + linear weights model by minimizing MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (5 exponents + 25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # Initialization:\n    # - log\u2010exponents u_i = 0 \u2192 exponents p_i = 1 (identity)\n    # - weights W = 0\n    # - biases b = mean of each output\n    mean_Y = np.mean(Y, axis=0)                  # (5,)\n    init_u = np.zeros(5)                         # (5,)\n    init_W = np.zeros(25)                        # flattened (5\u00d75)\n    init_b = mean_Y.copy()                       # (5,)\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # Bound the log\u2010exponents to keep p_i in a reasonable range\n    # here u_i \u2208 [\u22123, 3] \u21d2 p_i \u2208 [exp(\u22123), exp(3)] \u2248 [0.05, 20]\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        # mean squared error\n        return np.mean((Y_pred - Y) ** 2)\n\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial params if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 0.5307, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a shared-mixture power law per output.\n\n    Args:\n        data_points: array of shape (N,5) of domain proportions.\n        params:      flat array of length 20:\n                     - [0:5]:   unnormalized logits u for mixture weights w = softmax(u)\n                     - [5:10]:  biases a_j for each domain loss\n                     - [10:15]: log-scales r_j so that b_j = exp(r_j) >= 0\n                     - [15:20]: log-exponents v_j so that p_j = exp(v_j) >= 0\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    prm = np.asarray(params).ravel()\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture weights w = softmax(u)\n    u = prm[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)                 # (5,)\n\n    # 2) Output\u2010specific parameters\n    a = prm[5:10]                             # biases (5,)\n    r = prm[10:15]                            # log\u2010scales (5,)\n    v = prm[15:20]                            # log\u2010exponents (5,)\n    b = np.exp(r)                             # scales >= 0 (5,)\n    p = np.exp(v)                             # exponents >= 0 (5,)\n\n    # 3) Mixture score for each sample\n    s = X.dot(w)                              # (N,)\n\n    # 4) Predict each domain loss: y_j = a_j + b_j * s^p_j\n    # Broadcasting to (N,5)\n    Y = a[None, :] + b[None, :] * (s[:, None] ** p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the shared\u2010mixture power\u2010law scaling function via L-BFGS optimization.\n\n    Args:\n        data_points:  array of shape (N,5) of domain proportions.\n        loss_values:  array of shape (N,5) of observed domain losses.\n\n    Returns:\n        params: flat array of length 20 (optimized).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))   # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))   # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Expected inputs of shape (N,5) and losses of shape (N,5)\")\n\n    # Initialize parameters\n    #  u = 0       => uniform mixture\n    #  a = mean(Y) => bias approx\n    #  r = log(std(Y)) => scale approx\n    #  v = 0       => exponent \u2248 1\n    mean_y = np.mean(Y, axis=0)\n    std_y  = np.std(Y, axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])\n\n    # Regularization strength for scale/exponent terms\n    lam_reg = 1e-2\n\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        mse = np.mean((pred - Y) ** 2)\n        # L2 penalty on r and v for numerical stability\n        r = params[10:15]\n        v = params[15:20]\n        reg = lam_reg * (np.sum(r**2) + np.sum(v**2)) / params.size\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective,\n                      init_params,\n                      method='L-BFGS-B',\n                      options={'maxiter': 1000, 'ftol': 1e-9})\n    if result.success:\n        return result.x\n    else:\n        # fallback to initialization if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 3 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5261, Type: Experimental)\n```python\n\"\"\"\nEnhanced scaling law for LLM multi-domain loss prediction:\nCombines a per-domain linear term with a shared-mixture power-law term.\nTotal parameters = 5 (u logits) + 5 (nonlin biases a) + 5 (log-scales r)\n                 + 5 (log-exponents v) + 5 (linear coefs c) = 25 \u2264 35\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a hybrid linear + shared-mixture power law per output.\n\n    Args:\n        data_points: array of shape (N,5) of domain proportions.\n        params:      flat array of length 25:\n                     - [0:5]:   unnormalized logits u for mixture weights w = softmax(u)\n                     - [5:10]:  non-linear biases a_j for each domain\n                     - [10:15]: log-scales r_j so that b_j = exp(r_j) >= 0\n                     - [15:20]: log-exponents v_j so that p_j = exp(v_j) >= 0\n                     - [20:25]: linear coefficients c_j for each domain\n\n    Returns:\n        preds: array of shape (N,5), predicted losses for each of 5 domains.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X[None, :]\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 25:\n        raise ValueError(f\"Expected 25 parameters, got {p.size}\")\n\n    # 1) Mixture weights w = softmax(u)\n    u = p[0:5]\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)          # shape (5,)\n\n    # 2) Unpack non-linear parameters\n    a = p[5:10]                        # non-linear biases (5,)\n    r = p[10:15]                       # log-scales (5,)\n    v = p[15:20]                       # log-exponents (5,)\n    b = np.exp(r)                      # scales >= 0 (5,)\n    expo = np.exp(v)                   # exponents >= 0 (5,)\n\n    # 3) Linear coefficients per domain\n    c = p[20:25]                       # linear multipliers on X[:,j]\n\n    # 4) Compute mixture score\n    s = X.dot(w)                       # shape (N,)\n\n    # 5) Predict: y_nj = a_j + c_j * x_nj + b_j * s_n^expo_j\n    #    Broadcast s_n^expo_j across domains\n    Y_nl = a[None, :] + b[None, :] * (s[:, None] ** expo[None, :])\n    Y_lin = X * c[None, :]             # shape (N,5)\n    Y = Y_nl + Y_lin\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the hybrid scaling law parameters via L-BFGS-B optimization.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 25 (optimized).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(\"data_points must be shape (N,5)\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(\"loss_values must be shape (N,5)\")\n\n    N = X.shape[0]\n\n    # Initialize parameters\n    #  u = 0         -> uniform mixture\n    #  a = mean(Y)   -> non-linear bias\n    #  r = log(std)  -> scale approx\n    #  v = 0         -> exponent \u2248 1\n    #  c = slope_j   -> init from linear regression per domain on its own proportion\n    mean_y = Y.mean(axis=0)\n    std_y = Y.std(axis=0, ddof=1)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.log(np.maximum(std_y, 1e-2))\n    init_v = np.zeros(5)\n\n    # simple univariate slope estimate: cov(x_j, y_j)/var(x_j)\n    cov = np.sum((X - X.mean(axis=0)) * (Y - mean_y), axis=0)\n    var_x = np.sum((X - X.mean(axis=0))**2, axis=0) + 1e-6\n    init_c = cov / var_x\n    # clip extreme\n    init_c = np.clip(init_c, -10.0, 10.0)\n\n    init_params = np.concatenate([init_u, init_a, init_r, init_v, init_c])\n\n    # Regularization strengths\n    lam_rv = 1e-2    # on r and v\n    lam_c  = 1e-3    # on linear coefs\n\n    def objective(p):\n        pred = scaling_law_func(X, p)\n        mse = np.mean((pred - Y)**2)\n        # L2 penalties\n        r = p[10:15]\n        v = p[15:20]\n        c = p[20:25]\n        reg = lam_rv*(np.sum(r**2)+np.sum(v**2))/10.0 + lam_c*np.sum(c**2)/5.0\n        return mse + reg\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective,\n                      init_params,\n                      method='L-BFGS-B',\n                      options={'maxiter': 1000, 'ftol': 1e-9})\n    if result.success:\n        return result.x\n    else:\n        # fallback\n        return init_params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions\n    using a parameter\u2010efficient affine mixture\u2010of\u2010experts model.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected 5 input features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # (5,5)\n    b = p[25:].reshape(1, 5)    # (1,5)\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine mixture\u2010of\u2010experts model by ridge\u2010regularized\n    least squares. Returns 30 parameters (25 weights + 5 biases).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) with observed domain losses.\n\n    Returns:\n        params: flat array of length 30.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(\"Input shapes must be (N,5) for both data and losses\")\n\n    # Augment with bias column\n    X_aug = np.concatenate([X, np.ones((N, 1), dtype=float)], axis=1)  # (N,6)\n\n    # Ridge regularization for stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)  # (6,6)\n    B = X_aug.T.dot(Y)                            # (6,5)\n\n    # Solve linear system A @ Theta = B\n    Theta = np.linalg.solve(A, B)                 # (6,5)\n\n    # Extract weights and biases\n    W = Theta[:F, :]   # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n\n    # Flatten parameters\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter-efficient affine model:\n    y = X W + b\nTotal parameters = 5\u00d75 (W) + 5 (b) = 30 \u2264 35.\n\"\"\"\n\nimport numpy as np\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 30:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    \n    p = np.asarray(params).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)  # (5,5)\n    b = p[25:].reshape(1, 5)  # (1,5)\n\n    # affine prediction\n    preds = X.dot(W) + b      # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine scaling law by ridge-regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))  # (N,5)\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_points (N,5) and loss_values (N,5), got {X.shape}, {Y.shape}\")\n\n    # augment with bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization\n    lam = 1e-6\n    D = F + 1  # 5 features + 1 bias\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)               # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve normal equations\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack parameters\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten\n    params = np.concatenate([W.ravel(), b])\n    return params\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a nonlinear feature\u2010exponent model: each input proportion x_i \nis raised to a learned exponent p_i, then linearly combined into each output loss.\nTotal parameters = 5 exponents + 25 weights + 5 biases = 35 \u2264 35.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions via\n    a feature\u2010exponent nonlinear transform followed by an affine map.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                       - params[0:5]   = log\u2010exponents u (so p = exp(u))\n                       - params[5:30]  = weight matrix W of shape (5,5), row\u2010major,\n                                         where preds[:,j] = sum_i X^p[:,i] * W[j,i] + b[j]\n                       - params[30:35] = bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    if X.shape[1] != 5:\n        raise ValueError(f\"Expected 5 input features, got {X.shape[1]}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    u = p[0:5]                          # (5,) logs of exponents\n    W = p[5:30].reshape(5, 5)           # (5,5) weight matrix\n    b = p[30:35].reshape(1, 5)          # (1,5) bias\n\n    # compute positive exponents\n    exponents = np.exp(u)               # (5,)\n\n    # nonlinear feature transform: x_i^p_i\n    Xp = np.power(X, exponents)         # (N,5)\n\n    # affine combination\n    preds = Xp.dot(W.T) + b             # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the feature\u2010exponent affine model by initializing from a ridge regression\n    and then refining all 35 parameters via L-BFGS-B to minimize MSE.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (optimized log\u2010exponents, weights, biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    Y = np.atleast_2d(np.asarray(loss_values, dtype=float))\n    N, F = X.shape\n    if F != 5 or Y.shape != (N, 5):\n        raise ValueError(f\"Expected data_shapes (N,5), got {X.shape}, {Y.shape}\")\n\n    # 1) Ridge\u2010regularized linear fit to initialize W and b\n    #    Solve min ||X\u00b7W_lin + b_lin - Y||^2 + \u03bb||\u0398||^2\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n    lam = 1e-6\n    D = F + 1\n    A = X_aug.T.dot(X_aug) + lam * np.eye(D)               # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n    Theta = np.linalg.solve(A, B)                          # (6,5)\n    W_lin = Theta[:F, :]                                   # (5,5)\n    b_lin = Theta[F, :]                                    # (5,)\n\n    # 2) Build initial parameter vector\n    #    - log\u2010exponents u_i = 0  (\u2192 p_i=1, identity transform)\n    #    - weights W[j,i] = W_lin[i,j]\n    #    - bias b = b_lin\n    init_u = np.zeros(5)\n    init_W = W_lin.T.ravel()\n    init_b = b_lin.copy()\n    init_params = np.concatenate([init_u, init_W, init_b])  # (35,)\n\n    # 3) Set bounds: keep log\u2010exponents in [\u22123,3] for numerical stability\n    bounds = [(-3.0, 3.0)] * 5 + [(None, None)] * 25 + [(None, None)] * 5\n\n    # 4) Objective: mean squared error\n    def objective(p_flat):\n        Y_pred = scaling_law_func(X, p_flat)\n        return np.mean((Y_pred - Y) ** 2)\n\n    # 5) Optimize with L-BFGS-B\n    result = minimize(\n        objective,\n        init_params,\n        method=\"L-BFGS-B\",\n        bounds=bounds,\n        options={\"maxiter\": 500, \"ftol\": 1e-9}\n    )\n\n    if result.success:\n        return result.x\n    else:\n        # fallback if optimization fails\n        return init_params\n\n# EVOLVE-BLOCK-END\n"]}}}