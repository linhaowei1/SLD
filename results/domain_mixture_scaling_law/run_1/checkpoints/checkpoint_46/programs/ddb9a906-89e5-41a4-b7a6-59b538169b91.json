{"id": "ddb9a906-89e5-41a4-b7a6-59b538169b91", "code": "\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear model with a global squared\u2010proportion concentration feature:\n\n    y_j = X\u00b7W[:,j] + \u03b1_j * (\u2211_i x_i\u00b2) + b_j\n\nParameters (35 total):\n    W:     5\u00d75 weight matrix       \u2192 25 params\n    \u03b1:     5 concentration weights \u2192  5 params\n    b:     5 bias terms            \u2192  5 params\n\nThis form adds a single non\u2010linear concentration feature \n(sum of squared domain proportions) to capture simple curvature\nwhile keeping cross\u2010domain interactions linear and parameter\u2010efficient.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W matrix (5\u00d75)\n                - next 5 entries  \u2192 alpha vector (5,)\n                - last 5 entries  \u2192 bias vector b (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W     = p[:25].reshape(5, 5)      # linear weights\n    alpha = p[25:30].reshape(1, 5)    # concentration weights\n    b     = p[30:35].reshape(1, 5)    # biases\n\n    # global concentration feature: sum of squared proportions\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # affine + concentration term\n    preds = X.dot(W) + sq_sum.dot(alpha) + b       # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 alpha + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if Y.ndim == 1:\n        Y = Y.reshape(1, -1)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape {(N,5)}, got {Y.shape}\")\n\n    # build concentration feature\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)       # (N,1)\n\n    # design matrix: [X (5 cols) | sq_sum (1 col) | ones (1 col)] \u2192 (N,7)\n    X_aug = np.hstack([X, sq_sum, np.ones((N, 1), dtype=float)])  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    G = X_aug.T.dot(X_aug)\n    A = G + lam * np.eye(G.shape[0])            # (7,7)\n    B = X_aug.T.dot(Y)                          # (7,5)\n\n    # solve for Theta: shape (7,5)\n    Theta = np.linalg.solve(A, B)\n\n    # unpack into parameters\n    W     = Theta[:5, :]       # (5,5)\n    alpha = Theta[5, :].reshape(5)  # (5,)\n    b     = Theta[6, :].reshape(5)  # (5,)\n\n    # flatten param vector\n    params = np.concatenate([W.ravel(), alpha, b])\n    return params\n\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "a4dafc83-a525-480a-b86b-cedb54f5b4e7", "generation": 3, "timestamp": 1754716062.112418, "iteration_found": 40, "metrics": {"nmse": 0.020984518891261763, "nmae": 0.13039018342445088, "r2": 0.9790154811087383, "combined_score": 0.9794467805309625}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"nmse": 0.03641933229667162, "nmae": 0.1500079071206273, "r2": 0.9635806677033284, "combined_score": 0.964860427471989}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are an expert in scaling laws and machine learning who specializes in discovering and improving scaling law functions for different LLM training scenarios. Your task is to evolve both the `scaling_law_func` function (currently a naive power law) and the `fit_scaling_law` optimization algorithm (currently a naive BFGS) to better model the relationship between domain mixture proportions and multi-domain loss values across different model sizes.\n\n**IMPORTANT: The scaling law function must use no more than 35 parameters.**\n\nFocus on mathematical accuracy across different model sizes, cross-domain generalization, parameter efficiency (simple forms that can be fitted with limited data), and numerical/theoretical stability.\n\n**DATA CHARACTERISTICS:**\n- Features: Domain proportions (5 domains) - array of shape (n_mixtures, 5)\n- Labels: Multi-domain losses (5 domains) - array of shape (n_mixtures, 5)\n- Model sizes: 70M, 160M, 410M, 1B (each is a separate group)\n- Domain proportions vary across different mixture configurations\n- Loss values vary per domain and mixture configuration\n- This is a multi-output regression problem where both inputs and outputs are multi-dimensional\n\nThe function signatures must remain:\n\n```python\ndef scaling_law_func(data_points, params):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # proportions: Array of domain mixture proportions\n    # params: Array of up to 35 parameters\n    # Returns: Predicted multi-domain loss values (N,5)\n\ndef fit_scaling_law(data_points, loss_values):\n    # data_points: (N,5) array with domain proportions for 5 domains\n    # loss_values: Array of corresponding multi-domain losses (N,5)\n    # Returns: Optimized parameters (up to 35 parameters)\n```\n\nWrite all improvements between # EVOLVE-BLOCK-START and # EVOLVE-BLOCK-END markers.\n\nYou are not allowed to use input-dependent feature in scaling_law_func, e.g., median / min / max / etc.\n", "user": "# Current Program Information\n- Current performance metrics: - nmse: 0.0364\n- nmae: 0.1500\n- r2: 0.9636\n- combined_score: 0.9649\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: nmse, nmae. Consider continuing with similar changes.\n- Metrics showing regression: r2, combined_score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: nmse: 0.0184, nmae: 0.1369, r2: 0.9816, combined_score: 0.9820\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: nmse: 0.0044, nmae: 0.0614, r2: 0.9956, combined_score: 0.9956\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.5143)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient affine + domain\u2010wise quadratic model:\nEach domain\u2010loss is modeled as\n    loss_j = \u2211\u2096 W\u2096\u2c7c \u00b7 x\u2096  +  w_sq\u2c7c \u00b7 (x\u2c7c)\u00b2  +  b\u2c7c\nTotal parameters = 5\u00d75 (W) + 5 (w_sq) + 5 (b) = 35 \u2264 35.\nThis adds a simple nonlinearity per domain while keeping cross\u2010domain\ninteractions linear.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - next 5 entries   \u2192 domain\u2010wise quadratic coeffs w_sq (5,)\n                     - last 5 entries   \u2192 bias vector b (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    assert F == 5, f\"Expected input features of size 5, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W_lin = p[:25].reshape(5, 5)     # linear weights\n    w_sq  = p[25:30].reshape(1, 5)    # quadratic coeff per domain\n    b_vec = p[30:35].reshape(1, 5)    # biases\n\n    # compute predictions:\n    # linear term + domain\u2010wise quadratic term + bias\n    preds = X.dot(W_lin) + (X**2).dot(np.diagflat(w_sq)) + b_vec\n    # note: (X**2).dot(diag(w_sq)) == (X**2) * w_sq\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + per\u2010domain quadratic model via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 w_sq + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if Y.ndim == 1:\n        Y = Y.reshape(1, -1)\n    N, F = X.shape\n    assert F == 5, f\"Expected input features of size 5, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # regularization strength\n    lam = 1e-6\n\n    # containers for parameters\n    W_lin = np.zeros((5, 5), dtype=float)\n    w_sq  = np.zeros(5, dtype=float)\n    b_vec = np.zeros(5, dtype=float)\n\n    # Fit each domain\u2010loss independently:\n    # y_j \u2248 X \u00b7 W_lin[:,j]  +  (x_j)**2 * w_sq[j]  +  b_vec[j]\n    for j in range(5):\n        # build design matrix: [ X (5 cols) | x_j^2 (1 col) | 1 (1 col) ] => (N,7)\n        xj_sq = (X[:, j]**2).reshape(N, 1)\n        D = np.hstack([X, xj_sq, np.ones((N, 1), dtype=float)])\n        # normal equations with ridge\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(Y[:, j])\n        theta = np.linalg.solve(A, B)  # shape (7,)\n\n        # unpack\n        W_lin[:, j] = theta[:5]\n        w_sq[j]      = theta[5]\n        b_vec[j]     = theta[6]\n\n    # serialize parameters\n    params = np.concatenate([W_lin.ravel(), w_sq, b_vec])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0044), Performs well on nmae (0.0614), Performs well on r2 (0.9956), Performs well on combined_score (0.9956)\n\n\n### Program 2 (Score: 0.5297)\n```python\n\"\"\"\nEvolved scaling\u2010law model: a simple, parameter\u2010efficient\nlinear mixture\u2010of\u2010experts with ridge regularization.\n\nModel:\n    For each sample n and domain j:\n        \u0177_{n,j} = \u2211_{i=1}^5 X_{n,i} \u00b7 W_{i,j} + b_j\n\nParameters (30 total):\n  W: 5\u00d75 weight matrix (25 params)\n  b: 5\u00d71 bias vector       ( 5 params)\n\nWe solve via ridge\u2010regularized least squares with a small,\ndata\u2010adaptive \u03bb for numerical stability.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi\u2010domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array_like of shape (N,5), each row is a mix of 5 domains.\n        params:      1D array of length 30:\n                     - first 25 entries \u2192 W matrix (5\u00d75)\n                     - last 5 entries   \u2192 bias vector b (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 30:\n        raise ValueError(f\"Expected 30 parameters, got {p.size}\")\n\n    # unpack W and b\n    W = p[:25].reshape(5, 5)   # weight matrix\n    b = p[25:].reshape(1, 5)   # bias row\n\n    preds = X.dot(W) + b       # (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array_like of shape (N,5), domain mixture proportions.\n        loss_values: array_like of shape (N,5), observed losses per domain.\n\n    Returns:\n        params: 1D array of length 30 (25 W + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(\"data_points must be shape (N,5)\")\n    if Y.ndim != 2 or Y.shape[0] != X.shape[0] or Y.shape[1] != 5:\n        raise ValueError(\"loss_values must be shape (N,5)\")\n\n    N, F = X.shape  # F == 5\n\n    # Append constant bias column to X\n    X_aug = np.hstack([X, np.ones((N, 1), dtype=float)])  # (N,6)\n\n    # Compute normal equations: (X\u1d40X + \u03bbI) \u0398 = X\u1d40Y\n    # Choose \u03bb relative to data scale for stability\n    gram = X_aug.T.dot(X_aug)                  # (6,6)\n    trace = np.trace(gram)\n    lam = (trace / (F + 1)) * 1e-6             # small, data\u2010adaptive \u03bb\n\n    A = gram + lam * np.eye(F + 1)             # (6,6)\n    B = X_aug.T.dot(Y)                         # (6,5)\n\n    # Solve for \u0398: shape (6,5)\n    Theta = np.linalg.solve(A, B)\n\n    # Unpack Theta into W (5\u00d75) and b (5,)\n    W = Theta[:F, :]      # (5,5)\n    b = Theta[F, :].reshape(1, 5)  # (1,5)\n\n    params = np.concatenate([W.ravel(), b.ravel()])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n### Program 3 (Score: 0.5297)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on nmse (0.0184), Performs well on nmae (0.1369), Performs well on r2 (0.9816), Performs well on combined_score (0.9820)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.5287)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture-based power law with shared exponent.\n\nModel:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p}\n\nwhere\n    w = softmax(u) \u2208 \u0394^4   (5 logits \u2192 5 mixture weights)\n    b_j = exp(r_j) \u2265 0     (5 scale parameters)\n    p = exp(v) \u2265 0         (single shared exponent)\n    a_j \u2208 \u211d                (5 bias terms)\n\nTotal parameters = 5 (u) + 5 (a) + 5 (r) + 1 (v) = 16 \u2264 35\n\nThis compact form reduces over\u2010parameterization, improves\nnumerical stability via bounding r and v during optimization,\nand maintains strong cross\u2010domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _softmax(logits):\n    \"\"\"Compute stable softmax over 1D array.\"\"\"\n    shifted = logits - np.max(logits)\n    exps = np.exp(shifted)\n    return exps / np.sum(exps)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses for given domain proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (16,)\n            [u(5), a(5), r(5), v(1)]\n\n    Returns:\n        Y_pred: ndarray, shape (N, 5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    prm = np.ravel(params).astype(float)\n    if prm.size != 16:\n        raise ValueError(f\"Expected 16 parameters, got {prm.size}\")\n\n    # Unpack parameters\n    u = prm[0:5]       # logits for mixture weights\n    a = prm[5:10]      # biases for each output\n    r = prm[10:15]     # log\u2010scales\n    v = prm[15]        # log\u2010exponent (shared)\n\n    # Transform to valid domains\n    w = _softmax(u)          # mixture weights \u2208 \u0394^4\n    b = np.exp(r)            # scales \u2265 0\n    p = np.exp(v)            # exponent \u2265 0\n\n    # Mixture score per sample\n    s = X.dot(w)             # (N,)\n\n    # Predict: Y[n, j] = a_j + b_j * s[n]^p\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p)\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 16 parameters of the scaling law by minimizing MSE.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n        loss_values: array-like, shape (N, 5)\n\n    Returns:\n        params_opt: ndarray, shape (16,)\n            Optimized parameters [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(\"Expected input with 5 domain proportions\")\n    y2d = y if y.ndim == 2 else y[:, None]\n    if y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 loss outputs\")\n\n    # Initialization:\n    #   u = 0     \u2192 uniform mixture\n    #   a = mean  \u2192 bias approx\n    #   r = 0     \u2192 scale b = 1\n    #   v = 0     \u2192 exponent p = 1\n    init = np.zeros(16, dtype=float)\n    init[5:10] = np.mean(y2d, axis=0)\n\n    # Bounds for robustness:\n    #   u[0:5], a[5:10]: unconstrained\n    #   r[10:15] \u2208 [-5, 5]   \u2192 b \u2208 [e\u207b\u2075, e\u2075]\n    #   v[15]    \u2208 [-2, 2]   \u2192 p \u2208 [e\u207b\u00b2, e\u00b2]\n    bounds = [(None, None)] * 16\n    for i in range(10, 15):\n        bounds[i] = (-5.0, 5.0)\n    bounds[15] = (-2.0, 2.0)\n\n    def objective(prm):\n        pred = scaling_law_func(X, prm)\n        return np.mean((pred - y2d) ** 2)\n\n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    return result.x if result.success else init\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n\n### Program D2 (Score: 0.5459)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a small 2-layer neural network (27 parameters):\n  Layer 1: 5 inputs \u2192 2 hidden units with tanh activation\n  Layer 2: 2 hidden units \u2192 5 outputs (linear)\nThis non\u2010linear mapper can capture simple interactions while remaining\nparameter\u2010efficient (\u2264 35 parameters) and easy to fit.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        params:      1D array of length 27:\n                       - W1: first 10 entries \u2192 (5 \u00d7 2) weight matrix for hidden layer\n                       - b1: next 2 entries  \u2192 (2,) bias for hidden layer\n                       - W2: next 10 entries \u2192 (2 \u00d7 5) weight matrix for output layer\n                       - b2: last 5 entries  \u2192 (5,) bias for output layer\n\n    Returns:\n        preds: ndarray of shape (N,5), the predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,5)\n    if X.ndim == 1:\n        X = X[np.newaxis, :]\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 27:\n        raise ValueError(f\"Expected 27 parameters, got {p.size}\")\n\n    # unpack parameters\n    idx = 0\n    W1 = p[idx:idx + 10].reshape(5, 2); idx += 10\n    b1 = p[idx:idx + 2].reshape(1, 2);     idx += 2\n    W2 = p[idx:idx + 10].reshape(2, 5);    idx += 10\n    b2 = p[idx:idx + 5].reshape(1, 5)\n\n    # forward pass\n    H = np.tanh(X.dot(W1) + b1)       # shape (N,2)\n    preds = H.dot(W2) + b2            # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2-layer scaling law by minimizing MSE via L-BFGS-B.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        loss_values: array\u2010like of shape (N,5) of observed losses.\n\n    Returns:\n        params_opt: ndarray of length 27, the optimized parameters.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n\n    # initialize parameters:\n    #  - W1 small random or zeros\n    #  - b1 zeros\n    #  - W2 zeros\n    #  - b2 set to mean observed losses for stability\n    init_params = np.zeros(27, dtype=float)\n    init_params[-5:] = Y.mean(axis=0)\n\n    # objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - Y\n        return np.mean(diff * diff)\n\n    # optimize with L-BFGS-B using numerical gradients\n    params_opt, _, _ = fmin_l_bfgs_b(_mse,\n                                     x0=init_params,\n                                     approx_grad=True,\n                                     maxiter=500,\n                                     disp=False)\n    return params_opt\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to nmse, Alternative approach to nmae\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.5143, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a parameter\u2010efficient affine + domain\u2010wise quadratic model:\nEach domain\u2010loss is modeled as\n    loss_j = \u2211\u2096 W\u2096\u2c7c \u00b7 x\u2096  +  w_sq\u2c7c \u00b7 (x\u2c7c)\u00b2  +  b\u2c7c\nTotal parameters = 5\u00d75 (W) + 5 (w_sq) + 5 (b) = 35 \u2264 35.\nThis adds a simple nonlinearity per domain while keeping cross\u2010domain\ninteractions linear.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:      flat array of length 35:\n                     - first 25 entries \u2192 weight matrix W of shape (5,5)\n                     - next 5 entries   \u2192 domain\u2010wise quadratic coeffs w_sq (5,)\n                     - last 5 entries   \u2192 bias vector b (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    assert F == 5, f\"Expected input features of size 5, got {F}\"\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W_lin = p[:25].reshape(5, 5)     # linear weights\n    w_sq  = p[25:30].reshape(1, 5)    # quadratic coeff per domain\n    b_vec = p[30:35].reshape(1, 5)    # biases\n\n    # compute predictions:\n    # linear term + domain\u2010wise quadratic term + bias\n    preds = X.dot(W_lin) + (X**2).dot(np.diagflat(w_sq)) + b_vec\n    # note: (X**2).dot(diag(w_sq)) == (X**2) * w_sq\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the affine + per\u2010domain quadratic model via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 w_sq + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if Y.ndim == 1:\n        Y = Y.reshape(1, -1)\n    N, F = X.shape\n    assert F == 5, f\"Expected input features of size 5, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values shape {(N,5)}, got {Y.shape}\"\n\n    # regularization strength\n    lam = 1e-6\n\n    # containers for parameters\n    W_lin = np.zeros((5, 5), dtype=float)\n    w_sq  = np.zeros(5, dtype=float)\n    b_vec = np.zeros(5, dtype=float)\n\n    # Fit each domain\u2010loss independently:\n    # y_j \u2248 X \u00b7 W_lin[:,j]  +  (x_j)**2 * w_sq[j]  +  b_vec[j]\n    for j in range(5):\n        # build design matrix: [ X (5 cols) | x_j^2 (1 col) | 1 (1 col) ] => (N,7)\n        xj_sq = (X[:, j]**2).reshape(N, 1)\n        D = np.hstack([X, xj_sq, np.ones((N, 1), dtype=float)])\n        # normal equations with ridge\n        A = D.T.dot(D) + lam * np.eye(D.shape[1])\n        B = D.T.dot(Y[:, j])\n        theta = np.linalg.solve(A, B)  # shape (7,)\n\n        # unpack\n        W_lin[:, j] = theta[:5]\n        w_sq[j]      = theta[5]\n        b_vec[j]     = theta[6]\n\n    # serialize parameters\n    params = np.concatenate([W_lin.ravel(), w_sq, b_vec])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 2 (Score: 49999.7500, Type: High-Performer)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear mixture\u2010of\u2010experts with a squared\u2010proportion concentration feature:\n    y_j = sum_i W[i,j] * p_i  +  alpha[j] * (sum_i p_i^2)  +  b[j]\nTotal parameters = 5\u00d75 (W) + 5 (alpha) + 5 (bias) = 35 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions,\n    using a linear term plus a global squared\u2010proportion concentration term.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 weight matrix W of shape (5,5)\n                - next 5 entries  \u2192 alpha vector of shape (5,)\n                - last 5 entries  \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points), dtype=float)  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 domain proportions, got {F}\"\n\n    p = np.asarray(params, dtype=float).ravel()\n    assert p.size == 35, f\"Expected 35 parameters, got {p.size}\"\n\n    # unpack parameters\n    W     = p[:25].reshape(5, 5)    # linear weights\n    alpha = p[25:30].reshape(1, 5)  # squared\u2010proportion weights\n    b     = p[30:35].reshape(1, 5)  # biases\n\n    # compute the global concentration feature per sample\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # affine + concentration term\n    preds = X.dot(W) + sq_sum * alpha + b          # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law:\n        y = X W + (sum(X^2)) \u03b1 + 1\u00b7b\n    via ridge\u2010regularized linear regression (closed\u2010form).\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 weights + 5 alpha + 5 bias).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points), dtype=float)  # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values), dtype=float)  # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected input with 5 domain proportions, got {F}\"\n    assert Y.shape == (N, 5), f\"Expected loss_values with shape (N,5), got {Y.shape}\"\n\n    # build concentration feature and design matrix\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)           # (N,1)\n    X_aug = np.concatenate([X, sq_sum, np.ones((N, 1))], axis=1)  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 2)            # (7,7)\n    B = X_aug.T.dot(Y)                                       # (7,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                           # (7,5)\n\n    # unpack into parameters\n    # Theta rows 0\u20134: linear weights for p1..p5 \u2192 W (5\u00d75)\n    # Theta row 5:  squared\u2010proportion weights \u2192 alpha (5,)\n    # Theta row 6:  bias terms \u2192 b (5,)\n    W     = Theta[:5, :]                                     # (5,5)\n    alpha = Theta[5, :].reshape(5)                           # (5,)\n    b     = Theta[6, :].reshape(5)                           # (5,)\n\n    # flatten into single parameter vector\n    params = np.concatenate([W.ravel(), alpha, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent nmse (100000.000), Excellent nmae (100000.000)\n\n\n### Inspiration 3 (Score: 0.5459, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a small 2-layer neural network (27 parameters):\n  Layer 1: 5 inputs \u2192 2 hidden units with tanh activation\n  Layer 2: 2 hidden units \u2192 5 outputs (linear)\nThis non\u2010linear mapper can capture simple interactions while remaining\nparameter\u2010efficient (\u2264 35 parameters) and easy to fit.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import fmin_l_bfgs_b\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        params:      1D array of length 27:\n                       - W1: first 10 entries \u2192 (5 \u00d7 2) weight matrix for hidden layer\n                       - b1: next 2 entries  \u2192 (2,) bias for hidden layer\n                       - W2: next 10 entries \u2192 (2 \u00d7 5) weight matrix for output layer\n                       - b2: last 5 entries  \u2192 (5,) bias for output layer\n\n    Returns:\n        preds: ndarray of shape (N,5), the predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    # ensure shape (N,5)\n    if X.ndim == 1:\n        X = X[np.newaxis, :]\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 27:\n        raise ValueError(f\"Expected 27 parameters, got {p.size}\")\n\n    # unpack parameters\n    idx = 0\n    W1 = p[idx:idx + 10].reshape(5, 2); idx += 10\n    b1 = p[idx:idx + 2].reshape(1, 2);     idx += 2\n    W2 = p[idx:idx + 10].reshape(2, 5);    idx += 10\n    b2 = p[idx:idx + 5].reshape(1, 5)\n\n    # forward pass\n    H = np.tanh(X.dot(W1) + b1)       # shape (N,2)\n    preds = H.dot(W2) + b2            # shape (N,5)\n    return preds\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 2-layer scaling law by minimizing MSE via L-BFGS-B.\n\n    Args:\n        data_points: array\u2010like of shape (N,5) with domain proportions.\n        loss_values: array\u2010like of shape (N,5) of observed losses.\n\n    Returns:\n        params_opt: ndarray of length 27, the optimized parameters.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim != 2 or X.shape[1] != 5:\n        raise ValueError(f\"Expected data_points of shape (N,5), got {X.shape}\")\n    if Y.ndim != 2 or Y.shape != X.shape:\n        raise ValueError(f\"Expected loss_values of shape {X.shape}, got {Y.shape}\")\n\n    # initialize parameters:\n    #  - W1 small random or zeros\n    #  - b1 zeros\n    #  - W2 zeros\n    #  - b2 set to mean observed losses for stability\n    init_params = np.zeros(27, dtype=float)\n    init_params[-5:] = Y.mean(axis=0)\n\n    # objective: mean squared error\n    def _mse(p):\n        pred = scaling_law_func(X, p)\n        diff = pred - Y\n        return np.mean(diff * diff)\n\n    # optimize with L-BFGS-B using numerical gradients\n    params_opt, _, _ = fmin_l_bfgs_b(_mse,\n                                     x0=init_params,\n                                     approx_grad=True,\n                                     maxiter=500,\n                                     disp=False)\n    return params_opt\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 4 (Score: 0.5416, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved scaling law: mixture-based power law with shared domain mixture weights.\n\nWe model each output loss as:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p_j}\n\nParameters (20 total):\n    u (5):    unnormalized logits for domain-mixture weights w = softmax(u)\n    a (5):    output-specific biases\n    r (5):    log-scales so that b = exp(r) >= 0\n    v (5):    log-exponents so that p = exp(v) >= 0\n\nThis parameterization uses 20 parameters (\u2264 35), enforces positivity\nfor mixture weights, scales, and exponents, and shares the same\nmixture across all outputs for efficiency and cross-domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef scaling_law_func(data_points, params):\n    X = np.atleast_2d(np.asarray(data_points))  # shape (N, 5)\n    prm = np.asarray(params).reshape(-1)\n    if prm.size != 20:\n        raise ValueError(f\"Expected 20 parameters, got {prm.size}\")\n\n    # 1) Mixture logits -> softmax weights\n    u = prm[0:5]                          # (5,)\n    u_max = np.max(u)\n    exp_u = np.exp(u - u_max)\n    w = exp_u / np.sum(exp_u)             # (5,)\n\n    # 2) Output-specific parameters\n    a = prm[5:10]                         # bias terms, (5,)\n    r = prm[10:15]                        # log-scale terms\n    v = prm[15:20]                        # log-exponent terms\n\n    b = np.exp(r)                         # scale >= 0, (5,)\n    p = np.exp(v)                         # exponent >= 0, (5,)\n\n    # 3) Compute the mixture score for each sample\n    #    s_n = sum_i w_i * x_{n,i}\n    s = X.dot(w)                          # (N,)\n\n    # 4) Predict each output\n    #    y_{n,j} = a_j + b_j * s_n^{p_j}\n    # Broadcasting to (N, 5)\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p[None, :])\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    X = np.atleast_2d(np.asarray(data_points))  # (N,5)\n    y = np.asarray(loss_values)\n    if y.ndim == 1:\n        y2d = y[:, None]\n    else:\n        y2d = y\n    N, F = X.shape\n    if F != 5 or y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 domain proportions and 5 loss outputs\")\n\n    # Parameter vector length = 20\n    # Initialize:\n    #   u = 0           => uniform mixture weights\n    #   a = mean(y)     => bias approx\n    #   r = 0           => scale b = 1\n    #   v = 0           => exponent p = 1\n    mean_y = np.mean(y2d, axis=0)               # (5,)\n    init_u = np.zeros(5)\n    init_a = mean_y.copy()\n    init_r = np.zeros(5)\n    init_v = np.zeros(5)\n    init_params = np.concatenate([init_u, init_a, init_r, init_v])  # (20,)\n\n    # Objective: mean squared error\n    def objective(params):\n        pred = scaling_law_func(X, params)\n        return np.mean((pred - y2d) ** 2)\n\n    # Optimize with L-BFGS-B\n    result = minimize(objective, init_params, method='L-BFGS-B')\n    if result.success:\n        return result.x\n    else:\n        # fallback to initial if optimization fails\n        return init_params\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n### Inspiration 5 (Score: 0.5297, Type: Experimental)\n```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nUsing a simple, parameter\u2010efficient linear mixture\u2010of\u2010experts model:\neach output loss is an affine combination of the five domain proportions.\nTotal parameters = 5\u00d75 (weights) + 5 (biases) = 30 \u2264 35.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params:   flat array of length 30:\n                  - first 25 entries \u2192 weight matrix W of shape (5,5)\n                  - last 5 entries    \u2192 bias vector b of shape (5,)\n\n    Returns:\n        preds: array of shape (N,5), the predicted losses for each domain.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n\n    p = np.asarray(params).ravel()\n    assert p.size == 30, f\"Expected 30 parameters, got {p.size}\"\n\n    # unpack parameters\n    W = p[:25].reshape(5, 5)    # weight matrix\n    b = p[25:].reshape(1, 5)    # bias vector\n\n    # affine prediction\n    preds = X.dot(W) + b        # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the linear mixture-of-experts scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points:  array of shape (N,5) with domain proportions.\n        loss_values:  array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 30 (25 weights + 5 biases).\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points))    # (N,5)\n    Y = np.atleast_2d(np.asarray(loss_values))    # (N,5)\n    N, F = X.shape\n    assert F == 5, f\"Expected 5 input features, got {F}\"\n    assert Y.shape[0] == N and Y.shape[1] == 5, \"Expected loss_values shape (N,5)\"\n\n    # augment inputs with constant bias term\n    X_aug = np.concatenate([X, np.ones((N, 1))], axis=1)  # (N,6)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    A = X_aug.T.dot(X_aug) + lam * np.eye(F + 1)           # (6,6)\n    B = X_aug.T.dot(Y)                                     # (6,5)\n\n    # solve for Theta in A @ Theta = B\n    Theta = np.linalg.solve(A, B)                         # (6,5)\n\n    # unpack into W and b\n    W = Theta[:F, :]    # (5,5)\n    b = Theta[F, :]     # (5,)\n\n    # flatten parameters\n    params = np.concatenate([W.ravel(), b])\n    return params\n\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Alternative nmse approach, Alternative nmae approach\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nSimplified mixture-based power law with shared exponent.\n\nModel:\n    y_j = a_j + b_j * (sum_i w_i * x_i)^{p}\n\nwhere\n    w = softmax(u) \u2208 \u0394^4   (5 logits \u2192 5 mixture weights)\n    b_j = exp(r_j) \u2265 0     (5 scale parameters)\n    p = exp(v) \u2265 0         (single shared exponent)\n    a_j \u2208 \u211d                (5 bias terms)\n\nTotal parameters = 5 (u) + 5 (a) + 5 (r) + 1 (v) = 16 \u2264 35\n\nThis compact form reduces over\u2010parameterization, improves\nnumerical stability via bounding r and v during optimization,\nand maintains strong cross\u2010domain generalization.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef _softmax(logits):\n    \"\"\"Compute stable softmax over 1D array.\"\"\"\n    shifted = logits - np.max(logits)\n    exps = np.exp(shifted)\n    return exps / np.sum(exps)\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses for given domain proportions.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n            Each row is a mixture of 5 domain proportions.\n        params: array-like, shape (16,)\n            [u(5), a(5), r(5), v(1)]\n\n    Returns:\n        Y_pred: ndarray, shape (N, 5)\n            Predicted loss values for each of the 5 domains.\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))  # (N,5)\n    prm = np.ravel(params).astype(float)\n    if prm.size != 16:\n        raise ValueError(f\"Expected 16 parameters, got {prm.size}\")\n\n    # Unpack parameters\n    u = prm[0:5]       # logits for mixture weights\n    a = prm[5:10]      # biases for each output\n    r = prm[10:15]     # log\u2010scales\n    v = prm[15]        # log\u2010exponent (shared)\n\n    # Transform to valid domains\n    w = _softmax(u)          # mixture weights \u2208 \u0394^4\n    b = np.exp(r)            # scales \u2265 0\n    p = np.exp(v)            # exponent \u2265 0\n\n    # Mixture score per sample\n    s = X.dot(w)             # (N,)\n\n    # Predict: Y[n, j] = a_j + b_j * s[n]^p\n    Y = a[None, :] + b[None, :] * np.power(s[:, None], p)\n    return Y\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the 16 parameters of the scaling law by minimizing MSE.\n\n    Args:\n        data_points: array-like, shape (N, 5)\n        loss_values: array-like, shape (N, 5)\n\n    Returns:\n        params_opt: ndarray, shape (16,)\n            Optimized parameters [u, a, r, v].\n    \"\"\"\n    X = np.atleast_2d(np.asarray(data_points, dtype=float))\n    y = np.asarray(loss_values, dtype=float)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(\"Expected input with 5 domain proportions\")\n    y2d = y if y.ndim == 2 else y[:, None]\n    if y2d.shape[1] != 5:\n        raise ValueError(\"Expected 5 loss outputs\")\n\n    # Initialization:\n    #   u = 0     \u2192 uniform mixture\n    #   a = mean  \u2192 bias approx\n    #   r = 0     \u2192 scale b = 1\n    #   v = 0     \u2192 exponent p = 1\n    init = np.zeros(16, dtype=float)\n    init[5:10] = np.mean(y2d, axis=0)\n\n    # Bounds for robustness:\n    #   u[0:5], a[5:10]: unconstrained\n    #   r[10:15] \u2208 [-5, 5]   \u2192 b \u2208 [e\u207b\u2075, e\u2075]\n    #   v[15]    \u2208 [-2, 2]   \u2192 p \u2208 [e\u207b\u00b2, e\u00b2]\n    bounds = [(None, None)] * 16\n    for i in range(10, 15):\n        bounds[i] = (-5.0, 5.0)\n    bounds[15] = (-2.0, 2.0)\n\n    def objective(prm):\n        pred = scaling_law_func(X, prm)\n        return np.mean((pred - y2d) ** 2)\n\n    result = minimize(\n        objective,\n        init,\n        method='L-BFGS-B',\n        bounds=bounds,\n        options={'maxiter': 1000, 'ftol': 1e-9}\n    )\n    return result.x if result.success else init\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["```python\n\"\"\"\nScaling law discovery for LLM multi-domain loss prediction\nEnhanced linear model with a global squared\u2010proportion concentration feature:\n\n    y_j = X\u00b7W[:,j] + \u03b1_j * (\u2211_i x_i\u00b2) + b_j\n\nParameters (35 total):\n    W:     5\u00d75 weight matrix       \u2192 25 params\n    \u03b1:     5 concentration weights \u2192  5 params\n    b:     5 bias terms            \u2192  5 params\n\nThis form adds a single non\u2010linear concentration feature \n(sum of squared domain proportions) to capture simple curvature\nwhile keeping cross\u2010domain interactions linear and parameter\u2010efficient.\n\"\"\"\nimport numpy as np\n\n# EVOLVE-BLOCK-START\n\ndef scaling_law_func(data_points, params):\n    \"\"\"\n    Predict multi-domain losses given domain mixture proportions.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        params: flat array of length 35:\n                - first 25 entries \u2192 W matrix (5\u00d75)\n                - next 5 entries  \u2192 alpha vector (5,)\n                - last 5 entries  \u2192 bias vector b (5,)\n\n    Returns:\n        preds: array of shape (N,5), predicted losses per domain.\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    p = np.asarray(params, dtype=float).ravel()\n    if p.size != 35:\n        raise ValueError(f\"Expected 35 parameters, got {p.size}\")\n\n    # unpack parameters\n    W     = p[:25].reshape(5, 5)      # linear weights\n    alpha = p[25:30].reshape(1, 5)    # concentration weights\n    b     = p[30:35].reshape(1, 5)    # biases\n\n    # global concentration feature: sum of squared proportions\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)  # (N,1)\n\n    # affine + concentration term\n    preds = X.dot(W) + sq_sum.dot(alpha) + b       # (N,5)\n    return preds\n\n\ndef fit_scaling_law(data_points, loss_values):\n    \"\"\"\n    Fit the enhanced scaling law via ridge\u2010regularized least squares.\n\n    Args:\n        data_points: array of shape (N,5) with domain proportions.\n        loss_values: array of shape (N,5) of observed multi-domain losses.\n\n    Returns:\n        params: flat array of length 35 (25 W + 5 alpha + 5 b).\n    \"\"\"\n    X = np.asarray(data_points, dtype=float)\n    Y = np.asarray(loss_values, dtype=float)\n    if X.ndim == 1:\n        X = X.reshape(1, -1)\n    if Y.ndim == 1:\n        Y = Y.reshape(1, -1)\n    N, F = X.shape\n    if F != 5:\n        raise ValueError(f\"Expected input with 5 features, got {F}\")\n    if Y.shape != (N, 5):\n        raise ValueError(f\"Expected loss_values shape {(N,5)}, got {Y.shape}\")\n\n    # build concentration feature\n    sq_sum = np.sum(X * X, axis=1, keepdims=True)       # (N,1)\n\n    # design matrix: [X (5 cols) | sq_sum (1 col) | ones (1 col)] \u2192 (N,7)\n    X_aug = np.hstack([X, sq_sum, np.ones((N, 1), dtype=float)])  # (N,7)\n\n    # ridge regularization for numerical stability\n    lam = 1e-6\n    G = X_aug.T.dot(X_aug)\n    A = G + lam * np.eye(G.shape[0])            # (7,7)\n    B = X_aug.T.dot(Y)                          # (7,5)\n\n    # solve for Theta: shape (7,5)\n    Theta = np.linalg.solve(A, B)\n\n    # unpack into parameters\n    W     = Theta[:5, :]       # (5,5)\n    alpha = Theta[5, :].reshape(5)  # (5,)\n    b     = Theta[6, :].reshape(5)  # (5,)\n\n    # flatten param vector\n    params = np.concatenate([W.ravel(), alpha, b])\n    return params\n\n# EVOLVE-BLOCK-END\n```"]}}}